/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * EVE Swagger Interface
 * An OpenAPI for EVE Online
 *
 * OpenAPI spec version: 1.12
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://esi.evetech.net/latest".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * Bad request model
 * @export
 * @interface BadRequest
 */
export interface BadRequest {
    /**
     * Bad request message
     * @type {string}
     * @memberof BadRequest
     */
    error: string;
}

/**
 * Unprocessable entity
 * @export
 * @interface DeleteCharactersCharacterIdMailLabelsLabelIdUnprocessableEntity
 */
export interface DeleteCharactersCharacterIdMailLabelsLabelIdUnprocessableEntity {
    /**
     * Unprocessable entity message
     * @type {string}
     * @memberof DeleteCharactersCharacterIdMailLabelsLabelIdUnprocessableEntity
     */
    error?: string;
}

/**
 * Not found
 * @export
 * @interface DeleteFleetsFleetIdMembersMemberIdNotFound
 */
export interface DeleteFleetsFleetIdMembersMemberIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof DeleteFleetsFleetIdMembersMemberIdNotFound
     */
    error?: string;
}

/**
 * Not found
 * @export
 * @interface DeleteFleetsFleetIdSquadsSquadIdNotFound
 */
export interface DeleteFleetsFleetIdSquadsSquadIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof DeleteFleetsFleetIdSquadsSquadIdNotFound
     */
    error?: string;
}

/**
 * Not found
 * @export
 * @interface DeleteFleetsFleetIdWingsWingIdNotFound
 */
export interface DeleteFleetsFleetIdWingsWingIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof DeleteFleetsFleetIdWingsWingIdNotFound
     */
    error?: string;
}

/**
 * Error limited model
 * @export
 * @interface ErrorLimited
 */
export interface ErrorLimited {
    /**
     * Error limited message
     * @type {string}
     * @memberof ErrorLimited
     */
    error: string;
}

/**
 * Forbidden model
 * @export
 * @interface Forbidden
 */
export interface Forbidden {
    /**
     * Forbidden message
     * @type {string}
     * @memberof Forbidden
     */
    error: string;
    /**
     * status code received from SSO
     * @type {number}
     * @memberof Forbidden
     */
    ssoStatus?: number;
}

/**
 * Gateway timeout model
 * @export
 * @interface GatewayTimeout
 */
export interface GatewayTimeout {
    /**
     * Gateway timeout message
     * @type {string}
     * @memberof GatewayTimeout
     */
    error: string;
    /**
     * number of seconds the request was given
     * @type {number}
     * @memberof GatewayTimeout
     */
    timeout?: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetAlliancesAllianceIdContacts200Ok
 */
export interface GetAlliancesAllianceIdContacts200Ok {
    /**
     * contact_id integer
     * @type {number}
     * @memberof GetAlliancesAllianceIdContacts200Ok
     */
    contactId: number;
    /**
     * contact_type string
     * @type {string}
     * @memberof GetAlliancesAllianceIdContacts200Ok
     */
    contactType: GetAlliancesAllianceIdContacts200Ok.ContactTypeEnum;
    /**
     * label_ids array
     * @type {Array<number>}
     * @memberof GetAlliancesAllianceIdContacts200Ok
     */
    labelIds?: Array<number>;
    /**
     * Standing of the contact
     * @type {number}
     * @memberof GetAlliancesAllianceIdContacts200Ok
     */
    standing: number;
}

/**
 * @export
 * @namespace GetAlliancesAllianceIdContacts200Ok
 */
export namespace GetAlliancesAllianceIdContacts200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum ContactTypeEnum {
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        Alliance = <any> 'alliance',
        Faction = <any> 'faction'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetAlliancesAllianceIdContactsLabels200Ok
 */
export interface GetAlliancesAllianceIdContactsLabels200Ok {
    /**
     * label_id integer
     * @type {number}
     * @memberof GetAlliancesAllianceIdContactsLabels200Ok
     */
    labelId: number;
    /**
     * label_name string
     * @type {string}
     * @memberof GetAlliancesAllianceIdContactsLabels200Ok
     */
    labelName: string;
}

/**
 * No image server for this datasource
 * @export
 * @interface GetAlliancesAllianceIdIconsNotFound
 */
export interface GetAlliancesAllianceIdIconsNotFound {
    /**
     * error message
     * @type {string}
     * @memberof GetAlliancesAllianceIdIconsNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetAlliancesAllianceIdIconsOk
 */
export interface GetAlliancesAllianceIdIconsOk {
    /**
     * px128x128 string
     * @type {string}
     * @memberof GetAlliancesAllianceIdIconsOk
     */
    px128x128?: string;
    /**
     * px64x64 string
     * @type {string}
     * @memberof GetAlliancesAllianceIdIconsOk
     */
    px64x64?: string;
}

/**
 * Not found
 * @export
 * @interface GetAlliancesAllianceIdNotFound
 */
export interface GetAlliancesAllianceIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetAlliancesAllianceIdNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetAlliancesAllianceIdOk
 */
export interface GetAlliancesAllianceIdOk {
    /**
     * ID of the corporation that created the alliance
     * @type {number}
     * @memberof GetAlliancesAllianceIdOk
     */
    creatorCorporationId: number;
    /**
     * ID of the character that created the alliance
     * @type {number}
     * @memberof GetAlliancesAllianceIdOk
     */
    creatorId: number;
    /**
     * date_founded string
     * @type {Date}
     * @memberof GetAlliancesAllianceIdOk
     */
    dateFounded: Date;
    /**
     * the executor corporation ID, if this alliance is not closed
     * @type {number}
     * @memberof GetAlliancesAllianceIdOk
     */
    executorCorporationId?: number;
    /**
     * Faction ID this alliance is fighting for, if this alliance is enlisted in factional warfare
     * @type {number}
     * @memberof GetAlliancesAllianceIdOk
     */
    factionId?: number;
    /**
     * the full name of the alliance
     * @type {string}
     * @memberof GetAlliancesAllianceIdOk
     */
    name: string;
    /**
     * the short name of the alliance
     * @type {string}
     * @memberof GetAlliancesAllianceIdOk
     */
    ticker: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdAgentsResearch200Ok
 */
export interface GetCharactersCharacterIdAgentsResearch200Ok {
    /**
     * agent_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdAgentsResearch200Ok
     */
    agentId: number;
    /**
     * points_per_day number
     * @type {number}
     * @memberof GetCharactersCharacterIdAgentsResearch200Ok
     */
    pointsPerDay: number;
    /**
     * remainder_points number
     * @type {number}
     * @memberof GetCharactersCharacterIdAgentsResearch200Ok
     */
    remainderPoints: number;
    /**
     * skill_type_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdAgentsResearch200Ok
     */
    skillTypeId: number;
    /**
     * started_at string
     * @type {Date}
     * @memberof GetCharactersCharacterIdAgentsResearch200Ok
     */
    startedAt: Date;
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdAssets200Ok
 */
export interface GetCharactersCharacterIdAssets200Ok {
    /**
     * is_blueprint_copy boolean
     * @type {boolean}
     * @memberof GetCharactersCharacterIdAssets200Ok
     */
    isBlueprintCopy?: boolean;
    /**
     * is_singleton boolean
     * @type {boolean}
     * @memberof GetCharactersCharacterIdAssets200Ok
     */
    isSingleton: boolean;
    /**
     * item_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdAssets200Ok
     */
    itemId: number;
    /**
     * location_flag string
     * @type {string}
     * @memberof GetCharactersCharacterIdAssets200Ok
     */
    locationFlag: GetCharactersCharacterIdAssets200Ok.LocationFlagEnum;
    /**
     * location_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdAssets200Ok
     */
    locationId: number;
    /**
     * location_type string
     * @type {string}
     * @memberof GetCharactersCharacterIdAssets200Ok
     */
    locationType: GetCharactersCharacterIdAssets200Ok.LocationTypeEnum;
    /**
     * quantity integer
     * @type {number}
     * @memberof GetCharactersCharacterIdAssets200Ok
     */
    quantity: number;
    /**
     * type_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdAssets200Ok
     */
    typeId: number;
}

/**
 * @export
 * @namespace GetCharactersCharacterIdAssets200Ok
 */
export namespace GetCharactersCharacterIdAssets200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum LocationFlagEnum {
        AssetSafety = <any> 'AssetSafety',
        AutoFit = <any> 'AutoFit',
        BoosterBay = <any> 'BoosterBay',
        Cargo = <any> 'Cargo',
        CorpseBay = <any> 'CorpseBay',
        Deliveries = <any> 'Deliveries',
        DroneBay = <any> 'DroneBay',
        FighterBay = <any> 'FighterBay',
        FighterTube0 = <any> 'FighterTube0',
        FighterTube1 = <any> 'FighterTube1',
        FighterTube2 = <any> 'FighterTube2',
        FighterTube3 = <any> 'FighterTube3',
        FighterTube4 = <any> 'FighterTube4',
        FleetHangar = <any> 'FleetHangar',
        FrigateEscapeBay = <any> 'FrigateEscapeBay',
        Hangar = <any> 'Hangar',
        HangarAll = <any> 'HangarAll',
        HiSlot0 = <any> 'HiSlot0',
        HiSlot1 = <any> 'HiSlot1',
        HiSlot2 = <any> 'HiSlot2',
        HiSlot3 = <any> 'HiSlot3',
        HiSlot4 = <any> 'HiSlot4',
        HiSlot5 = <any> 'HiSlot5',
        HiSlot6 = <any> 'HiSlot6',
        HiSlot7 = <any> 'HiSlot7',
        HiddenModifiers = <any> 'HiddenModifiers',
        Implant = <any> 'Implant',
        LoSlot0 = <any> 'LoSlot0',
        LoSlot1 = <any> 'LoSlot1',
        LoSlot2 = <any> 'LoSlot2',
        LoSlot3 = <any> 'LoSlot3',
        LoSlot4 = <any> 'LoSlot4',
        LoSlot5 = <any> 'LoSlot5',
        LoSlot6 = <any> 'LoSlot6',
        LoSlot7 = <any> 'LoSlot7',
        Locked = <any> 'Locked',
        MedSlot0 = <any> 'MedSlot0',
        MedSlot1 = <any> 'MedSlot1',
        MedSlot2 = <any> 'MedSlot2',
        MedSlot3 = <any> 'MedSlot3',
        MedSlot4 = <any> 'MedSlot4',
        MedSlot5 = <any> 'MedSlot5',
        MedSlot6 = <any> 'MedSlot6',
        MedSlot7 = <any> 'MedSlot7',
        QuafeBay = <any> 'QuafeBay',
        RigSlot0 = <any> 'RigSlot0',
        RigSlot1 = <any> 'RigSlot1',
        RigSlot2 = <any> 'RigSlot2',
        RigSlot3 = <any> 'RigSlot3',
        RigSlot4 = <any> 'RigSlot4',
        RigSlot5 = <any> 'RigSlot5',
        RigSlot6 = <any> 'RigSlot6',
        RigSlot7 = <any> 'RigSlot7',
        ShipHangar = <any> 'ShipHangar',
        Skill = <any> 'Skill',
        SpecializedAmmoHold = <any> 'SpecializedAmmoHold',
        SpecializedAsteroidHold = <any> 'SpecializedAsteroidHold',
        SpecializedCommandCenterHold = <any> 'SpecializedCommandCenterHold',
        SpecializedFuelBay = <any> 'SpecializedFuelBay',
        SpecializedGasHold = <any> 'SpecializedGasHold',
        SpecializedIceHold = <any> 'SpecializedIceHold',
        SpecializedIndustrialShipHold = <any> 'SpecializedIndustrialShipHold',
        SpecializedLargeShipHold = <any> 'SpecializedLargeShipHold',
        SpecializedMaterialBay = <any> 'SpecializedMaterialBay',
        SpecializedMediumShipHold = <any> 'SpecializedMediumShipHold',
        SpecializedMineralHold = <any> 'SpecializedMineralHold',
        SpecializedOreHold = <any> 'SpecializedOreHold',
        SpecializedPlanetaryCommoditiesHold = <any> 'SpecializedPlanetaryCommoditiesHold',
        SpecializedSalvageHold = <any> 'SpecializedSalvageHold',
        SpecializedShipHold = <any> 'SpecializedShipHold',
        SpecializedSmallShipHold = <any> 'SpecializedSmallShipHold',
        StructureDeedBay = <any> 'StructureDeedBay',
        SubSystemBay = <any> 'SubSystemBay',
        SubSystemSlot0 = <any> 'SubSystemSlot0',
        SubSystemSlot1 = <any> 'SubSystemSlot1',
        SubSystemSlot2 = <any> 'SubSystemSlot2',
        SubSystemSlot3 = <any> 'SubSystemSlot3',
        SubSystemSlot4 = <any> 'SubSystemSlot4',
        SubSystemSlot5 = <any> 'SubSystemSlot5',
        SubSystemSlot6 = <any> 'SubSystemSlot6',
        SubSystemSlot7 = <any> 'SubSystemSlot7',
        Unlocked = <any> 'Unlocked',
        Wardrobe = <any> 'Wardrobe'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum LocationTypeEnum {
        Station = <any> 'station',
        SolarSystem = <any> 'solar_system',
        Item = <any> 'item',
        Other = <any> 'other'
    }
}

/**
 * Requested page does not exist
 * @export
 * @interface GetCharactersCharacterIdAssetsNotFound
 */
export interface GetCharactersCharacterIdAssetsNotFound {
    /**
     * error message
     * @type {string}
     * @memberof GetCharactersCharacterIdAssetsNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdAttributesOk
 */
export interface GetCharactersCharacterIdAttributesOk {
    /**
     * Neural remapping cooldown after a character uses remap accrued over time
     * @type {Date}
     * @memberof GetCharactersCharacterIdAttributesOk
     */
    accruedRemapCooldownDate?: Date;
    /**
     * Number of available bonus character neural remaps
     * @type {number}
     * @memberof GetCharactersCharacterIdAttributesOk
     */
    bonusRemaps?: number;
    /**
     * charisma integer
     * @type {number}
     * @memberof GetCharactersCharacterIdAttributesOk
     */
    charisma: number;
    /**
     * intelligence integer
     * @type {number}
     * @memberof GetCharactersCharacterIdAttributesOk
     */
    intelligence: number;
    /**
     * Datetime of last neural remap, including usage of bonus remaps
     * @type {Date}
     * @memberof GetCharactersCharacterIdAttributesOk
     */
    lastRemapDate?: Date;
    /**
     * memory integer
     * @type {number}
     * @memberof GetCharactersCharacterIdAttributesOk
     */
    memory: number;
    /**
     * perception integer
     * @type {number}
     * @memberof GetCharactersCharacterIdAttributesOk
     */
    perception: number;
    /**
     * willpower integer
     * @type {number}
     * @memberof GetCharactersCharacterIdAttributesOk
     */
    willpower: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdBlueprints200Ok
 */
export interface GetCharactersCharacterIdBlueprints200Ok {
    /**
     * Unique ID for this item.
     * @type {number}
     * @memberof GetCharactersCharacterIdBlueprints200Ok
     */
    itemId: number;
    /**
     * Type of the location_id
     * @type {string}
     * @memberof GetCharactersCharacterIdBlueprints200Ok
     */
    locationFlag: GetCharactersCharacterIdBlueprints200Ok.LocationFlagEnum;
    /**
     * References a station, a ship or an item_id if this blueprint is located within a container. If the return value is an item_id, then the Character AssetList API must be queried to find the container using the given item_id to determine the correct location of the Blueprint.
     * @type {number}
     * @memberof GetCharactersCharacterIdBlueprints200Ok
     */
    locationId: number;
    /**
     * Material Efficiency Level of the blueprint.
     * @type {number}
     * @memberof GetCharactersCharacterIdBlueprints200Ok
     */
    materialEfficiency: number;
    /**
     * A range of numbers with a minimum of -2 and no maximum value where -1 is an original and -2 is a copy. It can be a positive integer if it is a stack of blueprint originals fresh from the market (e.g. no activities performed on them yet).
     * @type {number}
     * @memberof GetCharactersCharacterIdBlueprints200Ok
     */
    quantity: number;
    /**
     * Number of runs remaining if the blueprint is a copy, -1 if it is an original.
     * @type {number}
     * @memberof GetCharactersCharacterIdBlueprints200Ok
     */
    runs: number;
    /**
     * Time Efficiency Level of the blueprint.
     * @type {number}
     * @memberof GetCharactersCharacterIdBlueprints200Ok
     */
    timeEfficiency: number;
    /**
     * type_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdBlueprints200Ok
     */
    typeId: number;
}

/**
 * @export
 * @namespace GetCharactersCharacterIdBlueprints200Ok
 */
export namespace GetCharactersCharacterIdBlueprints200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum LocationFlagEnum {
        AutoFit = <any> 'AutoFit',
        Cargo = <any> 'Cargo',
        CorpseBay = <any> 'CorpseBay',
        DroneBay = <any> 'DroneBay',
        FleetHangar = <any> 'FleetHangar',
        Deliveries = <any> 'Deliveries',
        HiddenModifiers = <any> 'HiddenModifiers',
        Hangar = <any> 'Hangar',
        HangarAll = <any> 'HangarAll',
        LoSlot0 = <any> 'LoSlot0',
        LoSlot1 = <any> 'LoSlot1',
        LoSlot2 = <any> 'LoSlot2',
        LoSlot3 = <any> 'LoSlot3',
        LoSlot4 = <any> 'LoSlot4',
        LoSlot5 = <any> 'LoSlot5',
        LoSlot6 = <any> 'LoSlot6',
        LoSlot7 = <any> 'LoSlot7',
        MedSlot0 = <any> 'MedSlot0',
        MedSlot1 = <any> 'MedSlot1',
        MedSlot2 = <any> 'MedSlot2',
        MedSlot3 = <any> 'MedSlot3',
        MedSlot4 = <any> 'MedSlot4',
        MedSlot5 = <any> 'MedSlot5',
        MedSlot6 = <any> 'MedSlot6',
        MedSlot7 = <any> 'MedSlot7',
        HiSlot0 = <any> 'HiSlot0',
        HiSlot1 = <any> 'HiSlot1',
        HiSlot2 = <any> 'HiSlot2',
        HiSlot3 = <any> 'HiSlot3',
        HiSlot4 = <any> 'HiSlot4',
        HiSlot5 = <any> 'HiSlot5',
        HiSlot6 = <any> 'HiSlot6',
        HiSlot7 = <any> 'HiSlot7',
        AssetSafety = <any> 'AssetSafety',
        Locked = <any> 'Locked',
        Unlocked = <any> 'Unlocked',
        Implant = <any> 'Implant',
        QuafeBay = <any> 'QuafeBay',
        RigSlot0 = <any> 'RigSlot0',
        RigSlot1 = <any> 'RigSlot1',
        RigSlot2 = <any> 'RigSlot2',
        RigSlot3 = <any> 'RigSlot3',
        RigSlot4 = <any> 'RigSlot4',
        RigSlot5 = <any> 'RigSlot5',
        RigSlot6 = <any> 'RigSlot6',
        RigSlot7 = <any> 'RigSlot7',
        ShipHangar = <any> 'ShipHangar',
        SpecializedFuelBay = <any> 'SpecializedFuelBay',
        SpecializedOreHold = <any> 'SpecializedOreHold',
        SpecializedGasHold = <any> 'SpecializedGasHold',
        SpecializedMineralHold = <any> 'SpecializedMineralHold',
        SpecializedSalvageHold = <any> 'SpecializedSalvageHold',
        SpecializedShipHold = <any> 'SpecializedShipHold',
        SpecializedSmallShipHold = <any> 'SpecializedSmallShipHold',
        SpecializedMediumShipHold = <any> 'SpecializedMediumShipHold',
        SpecializedLargeShipHold = <any> 'SpecializedLargeShipHold',
        SpecializedIndustrialShipHold = <any> 'SpecializedIndustrialShipHold',
        SpecializedAmmoHold = <any> 'SpecializedAmmoHold',
        SpecializedCommandCenterHold = <any> 'SpecializedCommandCenterHold',
        SpecializedPlanetaryCommoditiesHold = <any> 'SpecializedPlanetaryCommoditiesHold',
        SpecializedMaterialBay = <any> 'SpecializedMaterialBay',
        SubSystemSlot0 = <any> 'SubSystemSlot0',
        SubSystemSlot1 = <any> 'SubSystemSlot1',
        SubSystemSlot2 = <any> 'SubSystemSlot2',
        SubSystemSlot3 = <any> 'SubSystemSlot3',
        SubSystemSlot4 = <any> 'SubSystemSlot4',
        SubSystemSlot5 = <any> 'SubSystemSlot5',
        SubSystemSlot6 = <any> 'SubSystemSlot6',
        SubSystemSlot7 = <any> 'SubSystemSlot7',
        FighterBay = <any> 'FighterBay',
        FighterTube0 = <any> 'FighterTube0',
        FighterTube1 = <any> 'FighterTube1',
        FighterTube2 = <any> 'FighterTube2',
        FighterTube3 = <any> 'FighterTube3',
        FighterTube4 = <any> 'FighterTube4',
        Module = <any> 'Module'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdBookmarks200Ok
 */
export interface GetCharactersCharacterIdBookmarks200Ok {
    /**
     * bookmark_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdBookmarks200Ok
     */
    bookmarkId: number;
    /**
     * 
     * @type {GetCharactersCharacterIdBookmarksCoordinates}
     * @memberof GetCharactersCharacterIdBookmarks200Ok
     */
    coordinates?: GetCharactersCharacterIdBookmarksCoordinates;
    /**
     * created string
     * @type {Date}
     * @memberof GetCharactersCharacterIdBookmarks200Ok
     */
    created: Date;
    /**
     * creator_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdBookmarks200Ok
     */
    creatorId: number;
    /**
     * folder_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdBookmarks200Ok
     */
    folderId?: number;
    /**
     * 
     * @type {GetCharactersCharacterIdBookmarksItem}
     * @memberof GetCharactersCharacterIdBookmarks200Ok
     */
    item?: GetCharactersCharacterIdBookmarksItem;
    /**
     * label string
     * @type {string}
     * @memberof GetCharactersCharacterIdBookmarks200Ok
     */
    label: string;
    /**
     * location_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdBookmarks200Ok
     */
    locationId: number;
    /**
     * notes string
     * @type {string}
     * @memberof GetCharactersCharacterIdBookmarks200Ok
     */
    notes: string;
}

/**
 * Optional object that is returned if a bookmark was made on a planet or a random location in space.
 * @export
 * @interface GetCharactersCharacterIdBookmarksCoordinates
 */
export interface GetCharactersCharacterIdBookmarksCoordinates {
    /**
     * x number
     * @type {number}
     * @memberof GetCharactersCharacterIdBookmarksCoordinates
     */
    x: number;
    /**
     * y number
     * @type {number}
     * @memberof GetCharactersCharacterIdBookmarksCoordinates
     */
    y: number;
    /**
     * z number
     * @type {number}
     * @memberof GetCharactersCharacterIdBookmarksCoordinates
     */
    z: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdBookmarksFolders200Ok
 */
export interface GetCharactersCharacterIdBookmarksFolders200Ok {
    /**
     * folder_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdBookmarksFolders200Ok
     */
    folderId: number;
    /**
     * name string
     * @type {string}
     * @memberof GetCharactersCharacterIdBookmarksFolders200Ok
     */
    name: string;
}

/**
 * Optional object that is returned if a bookmark was made on a particular item.
 * @export
 * @interface GetCharactersCharacterIdBookmarksItem
 */
export interface GetCharactersCharacterIdBookmarksItem {
    /**
     * item_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdBookmarksItem
     */
    itemId: number;
    /**
     * type_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdBookmarksItem
     */
    typeId: number;
}

/**
 * event
 * @export
 * @interface GetCharactersCharacterIdCalendar200Ok
 */
export interface GetCharactersCharacterIdCalendar200Ok {
    /**
     * event_date string
     * @type {Date}
     * @memberof GetCharactersCharacterIdCalendar200Ok
     */
    eventDate?: Date;
    /**
     * event_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdCalendar200Ok
     */
    eventId?: number;
    /**
     * event_response string
     * @type {string}
     * @memberof GetCharactersCharacterIdCalendar200Ok
     */
    eventResponse?: GetCharactersCharacterIdCalendar200Ok.EventResponseEnum;
    /**
     * importance integer
     * @type {number}
     * @memberof GetCharactersCharacterIdCalendar200Ok
     */
    importance?: number;
    /**
     * title string
     * @type {string}
     * @memberof GetCharactersCharacterIdCalendar200Ok
     */
    title?: string;
}

/**
 * @export
 * @namespace GetCharactersCharacterIdCalendar200Ok
 */
export namespace GetCharactersCharacterIdCalendar200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum EventResponseEnum {
        Declined = <any> 'declined',
        NotResponded = <any> 'not_responded',
        Accepted = <any> 'accepted',
        Tentative = <any> 'tentative'
    }
}

/**
 * character_id and response of an attendee
 * @export
 * @interface GetCharactersCharacterIdCalendarEventIdAttendees200Ok
 */
export interface GetCharactersCharacterIdCalendarEventIdAttendees200Ok {
    /**
     * character_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdCalendarEventIdAttendees200Ok
     */
    characterId?: number;
    /**
     * event_response string
     * @type {string}
     * @memberof GetCharactersCharacterIdCalendarEventIdAttendees200Ok
     */
    eventResponse?: GetCharactersCharacterIdCalendarEventIdAttendees200Ok.EventResponseEnum;
}

/**
 * @export
 * @namespace GetCharactersCharacterIdCalendarEventIdAttendees200Ok
 */
export namespace GetCharactersCharacterIdCalendarEventIdAttendees200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum EventResponseEnum {
        Declined = <any> 'declined',
        NotResponded = <any> 'not_responded',
        Accepted = <any> 'accepted',
        Tentative = <any> 'tentative'
    }
}

/**
 * Not found
 * @export
 * @interface GetCharactersCharacterIdCalendarEventIdAttendeesNotFound
 */
export interface GetCharactersCharacterIdCalendarEventIdAttendeesNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetCharactersCharacterIdCalendarEventIdAttendeesNotFound
     */
    error?: string;
}

/**
 * Not found
 * @export
 * @interface GetCharactersCharacterIdCalendarEventIdNotFound
 */
export interface GetCharactersCharacterIdCalendarEventIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetCharactersCharacterIdCalendarEventIdNotFound
     */
    error?: string;
}

/**
 * Full details of a specific event
 * @export
 * @interface GetCharactersCharacterIdCalendarEventIdOk
 */
export interface GetCharactersCharacterIdCalendarEventIdOk {
    /**
     * date string
     * @type {Date}
     * @memberof GetCharactersCharacterIdCalendarEventIdOk
     */
    date: Date;
    /**
     * Length in minutes
     * @type {number}
     * @memberof GetCharactersCharacterIdCalendarEventIdOk
     */
    duration: number;
    /**
     * event_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdCalendarEventIdOk
     */
    eventId: number;
    /**
     * importance integer
     * @type {number}
     * @memberof GetCharactersCharacterIdCalendarEventIdOk
     */
    importance: number;
    /**
     * owner_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdCalendarEventIdOk
     */
    ownerId: number;
    /**
     * owner_name string
     * @type {string}
     * @memberof GetCharactersCharacterIdCalendarEventIdOk
     */
    ownerName: string;
    /**
     * owner_type string
     * @type {string}
     * @memberof GetCharactersCharacterIdCalendarEventIdOk
     */
    ownerType: GetCharactersCharacterIdCalendarEventIdOk.OwnerTypeEnum;
    /**
     * response string
     * @type {string}
     * @memberof GetCharactersCharacterIdCalendarEventIdOk
     */
    response: string;
    /**
     * text string
     * @type {string}
     * @memberof GetCharactersCharacterIdCalendarEventIdOk
     */
    text: string;
    /**
     * title string
     * @type {string}
     * @memberof GetCharactersCharacterIdCalendarEventIdOk
     */
    title: string;
}

/**
 * @export
 * @namespace GetCharactersCharacterIdCalendarEventIdOk
 */
export namespace GetCharactersCharacterIdCalendarEventIdOk {
    /**
     * @export
     * @enum {string}
     */
    export enum OwnerTypeEnum {
        EveServer = <any> 'eve_server',
        Corporation = <any> 'corporation',
        Faction = <any> 'faction',
        Character = <any> 'character',
        Alliance = <any> 'alliance'
    }
}

/**
 * home_location object
 * @export
 * @interface GetCharactersCharacterIdClonesHomeLocation
 */
export interface GetCharactersCharacterIdClonesHomeLocation {
    /**
     * location_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdClonesHomeLocation
     */
    locationId?: number;
    /**
     * location_type string
     * @type {string}
     * @memberof GetCharactersCharacterIdClonesHomeLocation
     */
    locationType?: GetCharactersCharacterIdClonesHomeLocation.LocationTypeEnum;
}

/**
 * @export
 * @namespace GetCharactersCharacterIdClonesHomeLocation
 */
export namespace GetCharactersCharacterIdClonesHomeLocation {
    /**
     * @export
     * @enum {string}
     */
    export enum LocationTypeEnum {
        Station = <any> 'station',
        Structure = <any> 'structure'
    }
}

/**
 * jump_clone object
 * @export
 * @interface GetCharactersCharacterIdClonesJumpClone
 */
export interface GetCharactersCharacterIdClonesJumpClone {
    /**
     * implants array
     * @type {Array<number>}
     * @memberof GetCharactersCharacterIdClonesJumpClone
     */
    implants: Array<number>;
    /**
     * jump_clone_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdClonesJumpClone
     */
    jumpCloneId: number;
    /**
     * location_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdClonesJumpClone
     */
    locationId: number;
    /**
     * location_type string
     * @type {string}
     * @memberof GetCharactersCharacterIdClonesJumpClone
     */
    locationType: GetCharactersCharacterIdClonesJumpClone.LocationTypeEnum;
    /**
     * name string
     * @type {string}
     * @memberof GetCharactersCharacterIdClonesJumpClone
     */
    name?: string;
}

/**
 * @export
 * @namespace GetCharactersCharacterIdClonesJumpClone
 */
export namespace GetCharactersCharacterIdClonesJumpClone {
    /**
     * @export
     * @enum {string}
     */
    export enum LocationTypeEnum {
        Station = <any> 'station',
        Structure = <any> 'structure'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdClonesOk
 */
export interface GetCharactersCharacterIdClonesOk {
    /**
     * 
     * @type {GetCharactersCharacterIdClonesHomeLocation}
     * @memberof GetCharactersCharacterIdClonesOk
     */
    homeLocation?: GetCharactersCharacterIdClonesHomeLocation;
    /**
     * jump_clones array
     * @type {Array<GetCharactersCharacterIdClonesJumpClone>}
     * @memberof GetCharactersCharacterIdClonesOk
     */
    jumpClones: Array<GetCharactersCharacterIdClonesJumpClone>;
    /**
     * last_clone_jump_date string
     * @type {Date}
     * @memberof GetCharactersCharacterIdClonesOk
     */
    lastCloneJumpDate?: Date;
    /**
     * last_station_change_date string
     * @type {Date}
     * @memberof GetCharactersCharacterIdClonesOk
     */
    lastStationChangeDate?: Date;
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdContacts200Ok
 */
export interface GetCharactersCharacterIdContacts200Ok {
    /**
     * contact_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdContacts200Ok
     */
    contactId: number;
    /**
     * contact_type string
     * @type {string}
     * @memberof GetCharactersCharacterIdContacts200Ok
     */
    contactType: GetCharactersCharacterIdContacts200Ok.ContactTypeEnum;
    /**
     * Whether this contact is in the blocked list. Note a missing value denotes unknown, not true or false
     * @type {boolean}
     * @memberof GetCharactersCharacterIdContacts200Ok
     */
    isBlocked?: boolean;
    /**
     * Whether this contact is being watched
     * @type {boolean}
     * @memberof GetCharactersCharacterIdContacts200Ok
     */
    isWatched?: boolean;
    /**
     * label_ids array
     * @type {Array<number>}
     * @memberof GetCharactersCharacterIdContacts200Ok
     */
    labelIds?: Array<number>;
    /**
     * Standing of the contact
     * @type {number}
     * @memberof GetCharactersCharacterIdContacts200Ok
     */
    standing: number;
}

/**
 * @export
 * @namespace GetCharactersCharacterIdContacts200Ok
 */
export namespace GetCharactersCharacterIdContacts200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum ContactTypeEnum {
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        Alliance = <any> 'alliance',
        Faction = <any> 'faction'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdContactsLabels200Ok
 */
export interface GetCharactersCharacterIdContactsLabels200Ok {
    /**
     * label_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdContactsLabels200Ok
     */
    labelId: number;
    /**
     * label_name string
     * @type {string}
     * @memberof GetCharactersCharacterIdContactsLabels200Ok
     */
    labelName: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdContracts200Ok
 */
export interface GetCharactersCharacterIdContracts200Ok {
    /**
     * Who will accept the contract
     * @type {number}
     * @memberof GetCharactersCharacterIdContracts200Ok
     */
    acceptorId: number;
    /**
     * ID to whom the contract is assigned, can be alliance, corporation or character ID
     * @type {number}
     * @memberof GetCharactersCharacterIdContracts200Ok
     */
    assigneeId: number;
    /**
     * To whom the contract is available
     * @type {string}
     * @memberof GetCharactersCharacterIdContracts200Ok
     */
    availability: GetCharactersCharacterIdContracts200Ok.AvailabilityEnum;
    /**
     * Buyout price (for Auctions only)
     * @type {number}
     * @memberof GetCharactersCharacterIdContracts200Ok
     */
    buyout?: number;
    /**
     * Collateral price (for Couriers only)
     * @type {number}
     * @memberof GetCharactersCharacterIdContracts200Ok
     */
    collateral?: number;
    /**
     * contract_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdContracts200Ok
     */
    contractId: number;
    /**
     * Date of confirmation of contract
     * @type {Date}
     * @memberof GetCharactersCharacterIdContracts200Ok
     */
    dateAccepted?: Date;
    /**
     * Date of completed of contract
     * @type {Date}
     * @memberof GetCharactersCharacterIdContracts200Ok
     */
    dateCompleted?: Date;
    /**
     * Expiration date of the contract
     * @type {Date}
     * @memberof GetCharactersCharacterIdContracts200Ok
     */
    dateExpired: Date;
    /**
     * Сreation date of the contract
     * @type {Date}
     * @memberof GetCharactersCharacterIdContracts200Ok
     */
    dateIssued: Date;
    /**
     * Number of days to perform the contract
     * @type {number}
     * @memberof GetCharactersCharacterIdContracts200Ok
     */
    daysToComplete?: number;
    /**
     * End location ID (for Couriers contract)
     * @type {number}
     * @memberof GetCharactersCharacterIdContracts200Ok
     */
    endLocationId?: number;
    /**
     * true if the contract was issued on behalf of the issuer's corporation
     * @type {boolean}
     * @memberof GetCharactersCharacterIdContracts200Ok
     */
    forCorporation: boolean;
    /**
     * Character's corporation ID for the issuer
     * @type {number}
     * @memberof GetCharactersCharacterIdContracts200Ok
     */
    issuerCorporationId: number;
    /**
     * Character ID for the issuer
     * @type {number}
     * @memberof GetCharactersCharacterIdContracts200Ok
     */
    issuerId: number;
    /**
     * Price of contract (for ItemsExchange and Auctions)
     * @type {number}
     * @memberof GetCharactersCharacterIdContracts200Ok
     */
    price?: number;
    /**
     * Remuneration for contract (for Couriers only)
     * @type {number}
     * @memberof GetCharactersCharacterIdContracts200Ok
     */
    reward?: number;
    /**
     * Start location ID (for Couriers contract)
     * @type {number}
     * @memberof GetCharactersCharacterIdContracts200Ok
     */
    startLocationId?: number;
    /**
     * Status of the the contract
     * @type {string}
     * @memberof GetCharactersCharacterIdContracts200Ok
     */
    status: GetCharactersCharacterIdContracts200Ok.StatusEnum;
    /**
     * Title of the contract
     * @type {string}
     * @memberof GetCharactersCharacterIdContracts200Ok
     */
    title?: string;
    /**
     * Type of the contract
     * @type {string}
     * @memberof GetCharactersCharacterIdContracts200Ok
     */
    type: GetCharactersCharacterIdContracts200Ok.TypeEnum;
    /**
     * Volume of items in the contract
     * @type {number}
     * @memberof GetCharactersCharacterIdContracts200Ok
     */
    volume?: number;
}

/**
 * @export
 * @namespace GetCharactersCharacterIdContracts200Ok
 */
export namespace GetCharactersCharacterIdContracts200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum AvailabilityEnum {
        Public = <any> 'public',
        Personal = <any> 'personal',
        Corporation = <any> 'corporation',
        Alliance = <any> 'alliance'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Outstanding = <any> 'outstanding',
        InProgress = <any> 'in_progress',
        FinishedIssuer = <any> 'finished_issuer',
        FinishedContractor = <any> 'finished_contractor',
        Finished = <any> 'finished',
        Cancelled = <any> 'cancelled',
        Rejected = <any> 'rejected',
        Failed = <any> 'failed',
        Deleted = <any> 'deleted',
        Reversed = <any> 'reversed'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Unknown = <any> 'unknown',
        ItemExchange = <any> 'item_exchange',
        Auction = <any> 'auction',
        Courier = <any> 'courier',
        Loan = <any> 'loan'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdContractsContractIdBids200Ok
 */
export interface GetCharactersCharacterIdContractsContractIdBids200Ok {
    /**
     * The amount bid, in ISK
     * @type {number}
     * @memberof GetCharactersCharacterIdContractsContractIdBids200Ok
     */
    amount: number;
    /**
     * Unique ID for the bid
     * @type {number}
     * @memberof GetCharactersCharacterIdContractsContractIdBids200Ok
     */
    bidId: number;
    /**
     * Character ID of the bidder
     * @type {number}
     * @memberof GetCharactersCharacterIdContractsContractIdBids200Ok
     */
    bidderId: number;
    /**
     * Datetime when the bid was placed
     * @type {Date}
     * @memberof GetCharactersCharacterIdContractsContractIdBids200Ok
     */
    dateBid: Date;
}

/**
 * Not found
 * @export
 * @interface GetCharactersCharacterIdContractsContractIdBidsNotFound
 */
export interface GetCharactersCharacterIdContractsContractIdBidsNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetCharactersCharacterIdContractsContractIdBidsNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdContractsContractIdItems200Ok
 */
export interface GetCharactersCharacterIdContractsContractIdItems200Ok {
    /**
     * true if the contract issuer has submitted this item with the contract, false if the isser is asking for this item in the contract
     * @type {boolean}
     * @memberof GetCharactersCharacterIdContractsContractIdItems200Ok
     */
    isIncluded: boolean;
    /**
     * is_singleton boolean
     * @type {boolean}
     * @memberof GetCharactersCharacterIdContractsContractIdItems200Ok
     */
    isSingleton: boolean;
    /**
     * Number of items in the stack
     * @type {number}
     * @memberof GetCharactersCharacterIdContractsContractIdItems200Ok
     */
    quantity: number;
    /**
     * -1 indicates that the item is a singleton (non-stackable). If the item happens to be a Blueprint, -1 is an Original and -2 is a Blueprint Copy
     * @type {number}
     * @memberof GetCharactersCharacterIdContractsContractIdItems200Ok
     */
    rawQuantity?: number;
    /**
     * Unique ID for the item
     * @type {number}
     * @memberof GetCharactersCharacterIdContractsContractIdItems200Ok
     */
    recordId: number;
    /**
     * Type ID for item
     * @type {number}
     * @memberof GetCharactersCharacterIdContractsContractIdItems200Ok
     */
    typeId: number;
}

/**
 * Not found
 * @export
 * @interface GetCharactersCharacterIdContractsContractIdItemsNotFound
 */
export interface GetCharactersCharacterIdContractsContractIdItemsNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetCharactersCharacterIdContractsContractIdItemsNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdCorporationhistory200Ok
 */
export interface GetCharactersCharacterIdCorporationhistory200Ok {
    /**
     * corporation_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdCorporationhistory200Ok
     */
    corporationId: number;
    /**
     * True if the corporation has been deleted
     * @type {boolean}
     * @memberof GetCharactersCharacterIdCorporationhistory200Ok
     */
    isDeleted?: boolean;
    /**
     * An incrementing ID that can be used to canonically establish order of records in cases where dates may be ambiguous
     * @type {number}
     * @memberof GetCharactersCharacterIdCorporationhistory200Ok
     */
    recordId: number;
    /**
     * start_date string
     * @type {Date}
     * @memberof GetCharactersCharacterIdCorporationhistory200Ok
     */
    startDate: Date;
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdFatigueOk
 */
export interface GetCharactersCharacterIdFatigueOk {
    /**
     * Character's jump fatigue expiry
     * @type {Date}
     * @memberof GetCharactersCharacterIdFatigueOk
     */
    jumpFatigueExpireDate?: Date;
    /**
     * Character's last jump activation
     * @type {Date}
     * @memberof GetCharactersCharacterIdFatigueOk
     */
    lastJumpDate?: Date;
    /**
     * Character's last jump update
     * @type {Date}
     * @memberof GetCharactersCharacterIdFatigueOk
     */
    lastUpdateDate?: Date;
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdFittings200Ok
 */
export interface GetCharactersCharacterIdFittings200Ok {
    /**
     * description string
     * @type {string}
     * @memberof GetCharactersCharacterIdFittings200Ok
     */
    description: string;
    /**
     * fitting_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdFittings200Ok
     */
    fittingId: number;
    /**
     * items array
     * @type {Array<GetCharactersCharacterIdFittingsItem>}
     * @memberof GetCharactersCharacterIdFittings200Ok
     */
    items: Array<GetCharactersCharacterIdFittingsItem>;
    /**
     * name string
     * @type {string}
     * @memberof GetCharactersCharacterIdFittings200Ok
     */
    name: string;
    /**
     * ship_type_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdFittings200Ok
     */
    shipTypeId: number;
}

/**
 * item object
 * @export
 * @interface GetCharactersCharacterIdFittingsItem
 */
export interface GetCharactersCharacterIdFittingsItem {
    /**
     * flag string
     * @type {string}
     * @memberof GetCharactersCharacterIdFittingsItem
     */
    flag: GetCharactersCharacterIdFittingsItem.FlagEnum;
    /**
     * quantity integer
     * @type {number}
     * @memberof GetCharactersCharacterIdFittingsItem
     */
    quantity: number;
    /**
     * type_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdFittingsItem
     */
    typeId: number;
}

/**
 * @export
 * @namespace GetCharactersCharacterIdFittingsItem
 */
export namespace GetCharactersCharacterIdFittingsItem {
    /**
     * @export
     * @enum {string}
     */
    export enum FlagEnum {
        Cargo = <any> 'Cargo',
        DroneBay = <any> 'DroneBay',
        FighterBay = <any> 'FighterBay',
        HiSlot0 = <any> 'HiSlot0',
        HiSlot1 = <any> 'HiSlot1',
        HiSlot2 = <any> 'HiSlot2',
        HiSlot3 = <any> 'HiSlot3',
        HiSlot4 = <any> 'HiSlot4',
        HiSlot5 = <any> 'HiSlot5',
        HiSlot6 = <any> 'HiSlot6',
        HiSlot7 = <any> 'HiSlot7',
        Invalid = <any> 'Invalid',
        LoSlot0 = <any> 'LoSlot0',
        LoSlot1 = <any> 'LoSlot1',
        LoSlot2 = <any> 'LoSlot2',
        LoSlot3 = <any> 'LoSlot3',
        LoSlot4 = <any> 'LoSlot4',
        LoSlot5 = <any> 'LoSlot5',
        LoSlot6 = <any> 'LoSlot6',
        LoSlot7 = <any> 'LoSlot7',
        MedSlot0 = <any> 'MedSlot0',
        MedSlot1 = <any> 'MedSlot1',
        MedSlot2 = <any> 'MedSlot2',
        MedSlot3 = <any> 'MedSlot3',
        MedSlot4 = <any> 'MedSlot4',
        MedSlot5 = <any> 'MedSlot5',
        MedSlot6 = <any> 'MedSlot6',
        MedSlot7 = <any> 'MedSlot7',
        RigSlot0 = <any> 'RigSlot0',
        RigSlot1 = <any> 'RigSlot1',
        RigSlot2 = <any> 'RigSlot2',
        ServiceSlot0 = <any> 'ServiceSlot0',
        ServiceSlot1 = <any> 'ServiceSlot1',
        ServiceSlot2 = <any> 'ServiceSlot2',
        ServiceSlot3 = <any> 'ServiceSlot3',
        ServiceSlot4 = <any> 'ServiceSlot4',
        ServiceSlot5 = <any> 'ServiceSlot5',
        ServiceSlot6 = <any> 'ServiceSlot6',
        ServiceSlot7 = <any> 'ServiceSlot7',
        SubSystemSlot0 = <any> 'SubSystemSlot0',
        SubSystemSlot1 = <any> 'SubSystemSlot1',
        SubSystemSlot2 = <any> 'SubSystemSlot2',
        SubSystemSlot3 = <any> 'SubSystemSlot3'
    }
}

/**
 * Not found
 * @export
 * @interface GetCharactersCharacterIdFleetNotFound
 */
export interface GetCharactersCharacterIdFleetNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetCharactersCharacterIdFleetNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdFleetOk
 */
export interface GetCharactersCharacterIdFleetOk {
    /**
     * The character's current fleet ID
     * @type {number}
     * @memberof GetCharactersCharacterIdFleetOk
     */
    fleetId: number;
    /**
     * Member’s role in fleet
     * @type {string}
     * @memberof GetCharactersCharacterIdFleetOk
     */
    role: GetCharactersCharacterIdFleetOk.RoleEnum;
    /**
     * ID of the squad the member is in. If not applicable, will be set to -1
     * @type {number}
     * @memberof GetCharactersCharacterIdFleetOk
     */
    squadId: number;
    /**
     * ID of the wing the member is in. If not applicable, will be set to -1
     * @type {number}
     * @memberof GetCharactersCharacterIdFleetOk
     */
    wingId: number;
}

/**
 * @export
 * @namespace GetCharactersCharacterIdFleetOk
 */
export namespace GetCharactersCharacterIdFleetOk {
    /**
     * @export
     * @enum {string}
     */
    export enum RoleEnum {
        FleetCommander = <any> 'fleet_commander',
        SquadCommander = <any> 'squad_commander',
        SquadMember = <any> 'squad_member',
        WingCommander = <any> 'wing_commander'
    }
}

/**
 * Summary of kills done by the given character against enemy factions
 * @export
 * @interface GetCharactersCharacterIdFwStatsKills
 */
export interface GetCharactersCharacterIdFwStatsKills {
    /**
     * Last week's total number of kills by a given character against enemy factions
     * @type {number}
     * @memberof GetCharactersCharacterIdFwStatsKills
     */
    lastWeek: number;
    /**
     * Total number of kills by a given character against enemy factions since the character enlisted
     * @type {number}
     * @memberof GetCharactersCharacterIdFwStatsKills
     */
    total: number;
    /**
     * Yesterday's total number of kills by a given character against enemy factions
     * @type {number}
     * @memberof GetCharactersCharacterIdFwStatsKills
     */
    yesterday: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdFwStatsOk
 */
export interface GetCharactersCharacterIdFwStatsOk {
    /**
     * The given character's current faction rank
     * @type {number}
     * @memberof GetCharactersCharacterIdFwStatsOk
     */
    currentRank?: number;
    /**
     * The enlistment date of the given character into faction warfare. Will not be included if character is not enlisted in faction warfare
     * @type {Date}
     * @memberof GetCharactersCharacterIdFwStatsOk
     */
    enlistedOn?: Date;
    /**
     * The faction the given character is enlisted to fight for. Will not be included if character is not enlisted in faction warfare
     * @type {number}
     * @memberof GetCharactersCharacterIdFwStatsOk
     */
    factionId?: number;
    /**
     * The given character's highest faction rank achieved
     * @type {number}
     * @memberof GetCharactersCharacterIdFwStatsOk
     */
    highestRank?: number;
    /**
     * 
     * @type {GetCharactersCharacterIdFwStatsKills}
     * @memberof GetCharactersCharacterIdFwStatsOk
     */
    kills: GetCharactersCharacterIdFwStatsKills;
    /**
     * 
     * @type {GetCharactersCharacterIdFwStatsVictoryPoints}
     * @memberof GetCharactersCharacterIdFwStatsOk
     */
    victoryPoints: GetCharactersCharacterIdFwStatsVictoryPoints;
}

/**
 * Summary of victory points gained by the given character for the enlisted faction
 * @export
 * @interface GetCharactersCharacterIdFwStatsVictoryPoints
 */
export interface GetCharactersCharacterIdFwStatsVictoryPoints {
    /**
     * Last week's victory points gained by the given character
     * @type {number}
     * @memberof GetCharactersCharacterIdFwStatsVictoryPoints
     */
    lastWeek: number;
    /**
     * Total victory points gained since the given character enlisted
     * @type {number}
     * @memberof GetCharactersCharacterIdFwStatsVictoryPoints
     */
    total: number;
    /**
     * Yesterday's victory points gained by the given character
     * @type {number}
     * @memberof GetCharactersCharacterIdFwStatsVictoryPoints
     */
    yesterday: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdIndustryJobs200Ok
 */
export interface GetCharactersCharacterIdIndustryJobs200Ok {
    /**
     * Job activity ID
     * @type {number}
     * @memberof GetCharactersCharacterIdIndustryJobs200Ok
     */
    activityId: number;
    /**
     * blueprint_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdIndustryJobs200Ok
     */
    blueprintId: number;
    /**
     * Location ID of the location from which the blueprint was installed. Normally a station ID, but can also be an asset (e.g. container) or corporation facility
     * @type {number}
     * @memberof GetCharactersCharacterIdIndustryJobs200Ok
     */
    blueprintLocationId: number;
    /**
     * blueprint_type_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdIndustryJobs200Ok
     */
    blueprintTypeId: number;
    /**
     * ID of the character which completed this job
     * @type {number}
     * @memberof GetCharactersCharacterIdIndustryJobs200Ok
     */
    completedCharacterId?: number;
    /**
     * Date and time when this job was completed
     * @type {Date}
     * @memberof GetCharactersCharacterIdIndustryJobs200Ok
     */
    completedDate?: Date;
    /**
     * The sume of job installation fee and industry facility tax
     * @type {number}
     * @memberof GetCharactersCharacterIdIndustryJobs200Ok
     */
    cost?: number;
    /**
     * Job duration in seconds
     * @type {number}
     * @memberof GetCharactersCharacterIdIndustryJobs200Ok
     */
    duration: number;
    /**
     * Date and time when this job finished
     * @type {Date}
     * @memberof GetCharactersCharacterIdIndustryJobs200Ok
     */
    endDate: Date;
    /**
     * ID of the facility where this job is running
     * @type {number}
     * @memberof GetCharactersCharacterIdIndustryJobs200Ok
     */
    facilityId: number;
    /**
     * ID of the character which installed this job
     * @type {number}
     * @memberof GetCharactersCharacterIdIndustryJobs200Ok
     */
    installerId: number;
    /**
     * Unique job ID
     * @type {number}
     * @memberof GetCharactersCharacterIdIndustryJobs200Ok
     */
    jobId: number;
    /**
     * Number of runs blueprint is licensed for
     * @type {number}
     * @memberof GetCharactersCharacterIdIndustryJobs200Ok
     */
    licensedRuns?: number;
    /**
     * Location ID of the location to which the output of the job will be delivered. Normally a station ID, but can also be a corporation facility
     * @type {number}
     * @memberof GetCharactersCharacterIdIndustryJobs200Ok
     */
    outputLocationId: number;
    /**
     * Date and time when this job was paused (i.e. time when the facility where this job was installed went offline)
     * @type {Date}
     * @memberof GetCharactersCharacterIdIndustryJobs200Ok
     */
    pauseDate?: Date;
    /**
     * Chance of success for invention
     * @type {number}
     * @memberof GetCharactersCharacterIdIndustryJobs200Ok
     */
    probability?: number;
    /**
     * Type ID of product (manufactured, copied or invented)
     * @type {number}
     * @memberof GetCharactersCharacterIdIndustryJobs200Ok
     */
    productTypeId?: number;
    /**
     * Number of runs for a manufacturing job, or number of copies to make for a blueprint copy
     * @type {number}
     * @memberof GetCharactersCharacterIdIndustryJobs200Ok
     */
    runs: number;
    /**
     * Date and time when this job started
     * @type {Date}
     * @memberof GetCharactersCharacterIdIndustryJobs200Ok
     */
    startDate: Date;
    /**
     * ID of the station where industry facility is located
     * @type {number}
     * @memberof GetCharactersCharacterIdIndustryJobs200Ok
     */
    stationId: number;
    /**
     * status string
     * @type {string}
     * @memberof GetCharactersCharacterIdIndustryJobs200Ok
     */
    status: GetCharactersCharacterIdIndustryJobs200Ok.StatusEnum;
    /**
     * Number of successful runs for this job. Equal to runs unless this is an invention job
     * @type {number}
     * @memberof GetCharactersCharacterIdIndustryJobs200Ok
     */
    successfulRuns?: number;
}

/**
 * @export
 * @namespace GetCharactersCharacterIdIndustryJobs200Ok
 */
export namespace GetCharactersCharacterIdIndustryJobs200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Active = <any> 'active',
        Cancelled = <any> 'cancelled',
        Delivered = <any> 'delivered',
        Paused = <any> 'paused',
        Ready = <any> 'ready',
        Reverted = <any> 'reverted'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdKillmailsRecent200Ok
 */
export interface GetCharactersCharacterIdKillmailsRecent200Ok {
    /**
     * A hash of this killmail
     * @type {string}
     * @memberof GetCharactersCharacterIdKillmailsRecent200Ok
     */
    killmailHash: string;
    /**
     * ID of this killmail
     * @type {number}
     * @memberof GetCharactersCharacterIdKillmailsRecent200Ok
     */
    killmailId: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdLocationOk
 */
export interface GetCharactersCharacterIdLocationOk {
    /**
     * solar_system_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdLocationOk
     */
    solarSystemId: number;
    /**
     * station_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdLocationOk
     */
    stationId?: number;
    /**
     * structure_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdLocationOk
     */
    structureId?: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdLoyaltyPoints200Ok
 */
export interface GetCharactersCharacterIdLoyaltyPoints200Ok {
    /**
     * corporation_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdLoyaltyPoints200Ok
     */
    corporationId: number;
    /**
     * loyalty_points integer
     * @type {number}
     * @memberof GetCharactersCharacterIdLoyaltyPoints200Ok
     */
    loyaltyPoints: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdMail200Ok
 */
export interface GetCharactersCharacterIdMail200Ok {
    /**
     * From whom the mail was sent
     * @type {number}
     * @memberof GetCharactersCharacterIdMail200Ok
     */
    from?: number;
    /**
     * is_read boolean
     * @type {boolean}
     * @memberof GetCharactersCharacterIdMail200Ok
     */
    isRead?: boolean;
    /**
     * labels array
     * @type {Array<number>}
     * @memberof GetCharactersCharacterIdMail200Ok
     */
    labels?: Array<number>;
    /**
     * mail_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdMail200Ok
     */
    mailId?: number;
    /**
     * Recipients of the mail
     * @type {Array<GetCharactersCharacterIdMailRecipient>}
     * @memberof GetCharactersCharacterIdMail200Ok
     */
    recipients?: Array<GetCharactersCharacterIdMailRecipient>;
    /**
     * Mail subject
     * @type {string}
     * @memberof GetCharactersCharacterIdMail200Ok
     */
    subject?: string;
    /**
     * When the mail was sent
     * @type {Date}
     * @memberof GetCharactersCharacterIdMail200Ok
     */
    timestamp?: Date;
}

/**
 * label object
 * @export
 * @interface GetCharactersCharacterIdMailLabelsLabel
 */
export interface GetCharactersCharacterIdMailLabelsLabel {
    /**
     * color string
     * @type {string}
     * @memberof GetCharactersCharacterIdMailLabelsLabel
     */
    color?: GetCharactersCharacterIdMailLabelsLabel.ColorEnum;
    /**
     * label_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdMailLabelsLabel
     */
    labelId?: number;
    /**
     * name string
     * @type {string}
     * @memberof GetCharactersCharacterIdMailLabelsLabel
     */
    name?: string;
    /**
     * unread_count integer
     * @type {number}
     * @memberof GetCharactersCharacterIdMailLabelsLabel
     */
    unreadCount?: number;
}

/**
 * @export
 * @namespace GetCharactersCharacterIdMailLabelsLabel
 */
export namespace GetCharactersCharacterIdMailLabelsLabel {
    /**
     * @export
     * @enum {string}
     */
    export enum ColorEnum {
        _0000fe = <any> '#0000fe',
        _006634 = <any> '#006634',
        _0099ff = <any> '#0099ff',
        _00ff33 = <any> '#00ff33',
        _01ffff = <any> '#01ffff',
        _349800 = <any> '#349800',
        _660066 = <any> '#660066',
        _666666 = <any> '#666666',
        _999999 = <any> '#999999',
        _99ffff = <any> '#99ffff',
        _9a0000 = <any> '#9a0000',
        Ccff9a = <any> '#ccff9a',
        E6e6e6 = <any> '#e6e6e6',
        Fe0000 = <any> '#fe0000',
        Ff6600 = <any> '#ff6600',
        Ffff01 = <any> '#ffff01',
        Ffffcd = <any> '#ffffcd',
        Ffffff = <any> '#ffffff'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdMailLabelsOk
 */
export interface GetCharactersCharacterIdMailLabelsOk {
    /**
     * labels array
     * @type {Array<GetCharactersCharacterIdMailLabelsLabel>}
     * @memberof GetCharactersCharacterIdMailLabelsOk
     */
    labels?: Array<GetCharactersCharacterIdMailLabelsLabel>;
    /**
     * total_unread_count integer
     * @type {number}
     * @memberof GetCharactersCharacterIdMailLabelsOk
     */
    totalUnreadCount?: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdMailLists200Ok
 */
export interface GetCharactersCharacterIdMailLists200Ok {
    /**
     * Mailing list ID
     * @type {number}
     * @memberof GetCharactersCharacterIdMailLists200Ok
     */
    mailingListId: number;
    /**
     * name string
     * @type {string}
     * @memberof GetCharactersCharacterIdMailLists200Ok
     */
    name: string;
}

/**
 * Not found
 * @export
 * @interface GetCharactersCharacterIdMailMailIdNotFound
 */
export interface GetCharactersCharacterIdMailMailIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetCharactersCharacterIdMailMailIdNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdMailMailIdOk
 */
export interface GetCharactersCharacterIdMailMailIdOk {
    /**
     * Mail's body
     * @type {string}
     * @memberof GetCharactersCharacterIdMailMailIdOk
     */
    body?: string;
    /**
     * From whom the mail was sent
     * @type {number}
     * @memberof GetCharactersCharacterIdMailMailIdOk
     */
    from?: number;
    /**
     * Labels attached to the mail
     * @type {Array<number>}
     * @memberof GetCharactersCharacterIdMailMailIdOk
     */
    labels?: Array<number>;
    /**
     * Whether the mail is flagged as read
     * @type {boolean}
     * @memberof GetCharactersCharacterIdMailMailIdOk
     */
    read?: boolean;
    /**
     * Recipients of the mail
     * @type {Array<GetCharactersCharacterIdMailMailIdRecipient>}
     * @memberof GetCharactersCharacterIdMailMailIdOk
     */
    recipients?: Array<GetCharactersCharacterIdMailMailIdRecipient>;
    /**
     * Mail subject
     * @type {string}
     * @memberof GetCharactersCharacterIdMailMailIdOk
     */
    subject?: string;
    /**
     * When the mail was sent
     * @type {Date}
     * @memberof GetCharactersCharacterIdMailMailIdOk
     */
    timestamp?: Date;
}

/**
 * recipient object
 * @export
 * @interface GetCharactersCharacterIdMailMailIdRecipient
 */
export interface GetCharactersCharacterIdMailMailIdRecipient {
    /**
     * recipient_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdMailMailIdRecipient
     */
    recipientId: number;
    /**
     * recipient_type string
     * @type {string}
     * @memberof GetCharactersCharacterIdMailMailIdRecipient
     */
    recipientType: GetCharactersCharacterIdMailMailIdRecipient.RecipientTypeEnum;
}

/**
 * @export
 * @namespace GetCharactersCharacterIdMailMailIdRecipient
 */
export namespace GetCharactersCharacterIdMailMailIdRecipient {
    /**
     * @export
     * @enum {string}
     */
    export enum RecipientTypeEnum {
        Alliance = <any> 'alliance',
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        MailingList = <any> 'mailing_list'
    }
}

/**
 * recipient object
 * @export
 * @interface GetCharactersCharacterIdMailRecipient
 */
export interface GetCharactersCharacterIdMailRecipient {
    /**
     * recipient_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdMailRecipient
     */
    recipientId: number;
    /**
     * recipient_type string
     * @type {string}
     * @memberof GetCharactersCharacterIdMailRecipient
     */
    recipientType: GetCharactersCharacterIdMailRecipient.RecipientTypeEnum;
}

/**
 * @export
 * @namespace GetCharactersCharacterIdMailRecipient
 */
export namespace GetCharactersCharacterIdMailRecipient {
    /**
     * @export
     * @enum {string}
     */
    export enum RecipientTypeEnum {
        Alliance = <any> 'alliance',
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        MailingList = <any> 'mailing_list'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdMedals200Ok
 */
export interface GetCharactersCharacterIdMedals200Ok {
    /**
     * corporation_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdMedals200Ok
     */
    corporationId: number;
    /**
     * date string
     * @type {Date}
     * @memberof GetCharactersCharacterIdMedals200Ok
     */
    date: Date;
    /**
     * description string
     * @type {string}
     * @memberof GetCharactersCharacterIdMedals200Ok
     */
    description: string;
    /**
     * graphics array
     * @type {Array<GetCharactersCharacterIdMedalsGraphic>}
     * @memberof GetCharactersCharacterIdMedals200Ok
     */
    graphics: Array<GetCharactersCharacterIdMedalsGraphic>;
    /**
     * issuer_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdMedals200Ok
     */
    issuerId: number;
    /**
     * medal_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdMedals200Ok
     */
    medalId: number;
    /**
     * reason string
     * @type {string}
     * @memberof GetCharactersCharacterIdMedals200Ok
     */
    reason: string;
    /**
     * status string
     * @type {string}
     * @memberof GetCharactersCharacterIdMedals200Ok
     */
    status: GetCharactersCharacterIdMedals200Ok.StatusEnum;
    /**
     * title string
     * @type {string}
     * @memberof GetCharactersCharacterIdMedals200Ok
     */
    title: string;
}

/**
 * @export
 * @namespace GetCharactersCharacterIdMedals200Ok
 */
export namespace GetCharactersCharacterIdMedals200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Public = <any> 'public',
        Private = <any> 'private'
    }
}

/**
 * graphic object
 * @export
 * @interface GetCharactersCharacterIdMedalsGraphic
 */
export interface GetCharactersCharacterIdMedalsGraphic {
    /**
     * color integer
     * @type {number}
     * @memberof GetCharactersCharacterIdMedalsGraphic
     */
    color?: number;
    /**
     * graphic string
     * @type {string}
     * @memberof GetCharactersCharacterIdMedalsGraphic
     */
    graphic: string;
    /**
     * layer integer
     * @type {number}
     * @memberof GetCharactersCharacterIdMedalsGraphic
     */
    layer: number;
    /**
     * part integer
     * @type {number}
     * @memberof GetCharactersCharacterIdMedalsGraphic
     */
    part: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdMining200Ok
 */
export interface GetCharactersCharacterIdMining200Ok {
    /**
     * date string
     * @type {string}
     * @memberof GetCharactersCharacterIdMining200Ok
     */
    date: string;
    /**
     * quantity integer
     * @type {number}
     * @memberof GetCharactersCharacterIdMining200Ok
     */
    quantity: number;
    /**
     * solar_system_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdMining200Ok
     */
    solarSystemId: number;
    /**
     * type_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdMining200Ok
     */
    typeId: number;
}

/**
 * Not found
 * @export
 * @interface GetCharactersCharacterIdNotFound
 */
export interface GetCharactersCharacterIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetCharactersCharacterIdNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdNotifications200Ok
 */
export interface GetCharactersCharacterIdNotifications200Ok {
    /**
     * is_read boolean
     * @type {boolean}
     * @memberof GetCharactersCharacterIdNotifications200Ok
     */
    isRead?: boolean;
    /**
     * notification_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdNotifications200Ok
     */
    notificationId: number;
    /**
     * sender_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdNotifications200Ok
     */
    senderId: number;
    /**
     * sender_type string
     * @type {string}
     * @memberof GetCharactersCharacterIdNotifications200Ok
     */
    senderType: GetCharactersCharacterIdNotifications200Ok.SenderTypeEnum;
    /**
     * text string
     * @type {string}
     * @memberof GetCharactersCharacterIdNotifications200Ok
     */
    text?: string;
    /**
     * timestamp string
     * @type {Date}
     * @memberof GetCharactersCharacterIdNotifications200Ok
     */
    timestamp: Date;
    /**
     * type string
     * @type {string}
     * @memberof GetCharactersCharacterIdNotifications200Ok
     */
    type: GetCharactersCharacterIdNotifications200Ok.TypeEnum;
}

/**
 * @export
 * @namespace GetCharactersCharacterIdNotifications200Ok
 */
export namespace GetCharactersCharacterIdNotifications200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum SenderTypeEnum {
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        Alliance = <any> 'alliance',
        Faction = <any> 'faction',
        Other = <any> 'other'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        AcceptedAlly = <any> 'AcceptedAlly',
        AcceptedSurrender = <any> 'AcceptedSurrender',
        AgentRetiredTrigravian = <any> 'AgentRetiredTrigravian',
        AllAnchoringMsg = <any> 'AllAnchoringMsg',
        AllMaintenanceBillMsg = <any> 'AllMaintenanceBillMsg',
        AllStrucInvulnerableMsg = <any> 'AllStrucInvulnerableMsg',
        AllStructVulnerableMsg = <any> 'AllStructVulnerableMsg',
        AllWarCorpJoinedAllianceMsg = <any> 'AllWarCorpJoinedAllianceMsg',
        AllWarDeclaredMsg = <any> 'AllWarDeclaredMsg',
        AllWarInvalidatedMsg = <any> 'AllWarInvalidatedMsg',
        AllWarRetractedMsg = <any> 'AllWarRetractedMsg',
        AllWarSurrenderMsg = <any> 'AllWarSurrenderMsg',
        AllianceCapitalChanged = <any> 'AllianceCapitalChanged',
        AllianceWarDeclaredV2 = <any> 'AllianceWarDeclaredV2',
        AllyContractCancelled = <any> 'AllyContractCancelled',
        AllyJoinedWarAggressorMsg = <any> 'AllyJoinedWarAggressorMsg',
        AllyJoinedWarAllyMsg = <any> 'AllyJoinedWarAllyMsg',
        AllyJoinedWarDefenderMsg = <any> 'AllyJoinedWarDefenderMsg',
        BattlePunishFriendlyFire = <any> 'BattlePunishFriendlyFire',
        BillOutOfMoneyMsg = <any> 'BillOutOfMoneyMsg',
        BillPaidCorpAllMsg = <any> 'BillPaidCorpAllMsg',
        BountyClaimMsg = <any> 'BountyClaimMsg',
        BountyESSShared = <any> 'BountyESSShared',
        BountyESSTaken = <any> 'BountyESSTaken',
        BountyPlacedAlliance = <any> 'BountyPlacedAlliance',
        BountyPlacedChar = <any> 'BountyPlacedChar',
        BountyPlacedCorp = <any> 'BountyPlacedCorp',
        BountyYourBountyClaimed = <any> 'BountyYourBountyClaimed',
        BuddyConnectContactAdd = <any> 'BuddyConnectContactAdd',
        CharAppAcceptMsg = <any> 'CharAppAcceptMsg',
        CharAppRejectMsg = <any> 'CharAppRejectMsg',
        CharAppWithdrawMsg = <any> 'CharAppWithdrawMsg',
        CharLeftCorpMsg = <any> 'CharLeftCorpMsg',
        CharMedalMsg = <any> 'CharMedalMsg',
        CharTerminationMsg = <any> 'CharTerminationMsg',
        CloneActivationMsg = <any> 'CloneActivationMsg',
        CloneActivationMsg2 = <any> 'CloneActivationMsg2',
        CloneMovedMsg = <any> 'CloneMovedMsg',
        CloneRevokedMsg1 = <any> 'CloneRevokedMsg1',
        CloneRevokedMsg2 = <any> 'CloneRevokedMsg2',
        CombatOperationFinished = <any> 'CombatOperationFinished',
        ContactAdd = <any> 'ContactAdd',
        ContactEdit = <any> 'ContactEdit',
        ContainerPasswordMsg = <any> 'ContainerPasswordMsg',
        ContractRegionChangedToPochven = <any> 'ContractRegionChangedToPochven',
        CorpAllBillMsg = <any> 'CorpAllBillMsg',
        CorpAppAcceptMsg = <any> 'CorpAppAcceptMsg',
        CorpAppInvitedMsg = <any> 'CorpAppInvitedMsg',
        CorpAppNewMsg = <any> 'CorpAppNewMsg',
        CorpAppRejectCustomMsg = <any> 'CorpAppRejectCustomMsg',
        CorpAppRejectMsg = <any> 'CorpAppRejectMsg',
        CorpBecameWarEligible = <any> 'CorpBecameWarEligible',
        CorpDividendMsg = <any> 'CorpDividendMsg',
        CorpFriendlyFireDisableTimerCompleted = <any> 'CorpFriendlyFireDisableTimerCompleted',
        CorpFriendlyFireDisableTimerStarted = <any> 'CorpFriendlyFireDisableTimerStarted',
        CorpFriendlyFireEnableTimerCompleted = <any> 'CorpFriendlyFireEnableTimerCompleted',
        CorpFriendlyFireEnableTimerStarted = <any> 'CorpFriendlyFireEnableTimerStarted',
        CorpKicked = <any> 'CorpKicked',
        CorpLiquidationMsg = <any> 'CorpLiquidationMsg',
        CorpNewCEOMsg = <any> 'CorpNewCEOMsg',
        CorpNewsMsg = <any> 'CorpNewsMsg',
        CorpNoLongerWarEligible = <any> 'CorpNoLongerWarEligible',
        CorpOfficeExpirationMsg = <any> 'CorpOfficeExpirationMsg',
        CorpStructLostMsg = <any> 'CorpStructLostMsg',
        CorpTaxChangeMsg = <any> 'CorpTaxChangeMsg',
        CorpVoteCEORevokedMsg = <any> 'CorpVoteCEORevokedMsg',
        CorpVoteMsg = <any> 'CorpVoteMsg',
        CorpWarDeclaredMsg = <any> 'CorpWarDeclaredMsg',
        CorpWarDeclaredV2 = <any> 'CorpWarDeclaredV2',
        CorpWarFightingLegalMsg = <any> 'CorpWarFightingLegalMsg',
        CorpWarInvalidatedMsg = <any> 'CorpWarInvalidatedMsg',
        CorpWarRetractedMsg = <any> 'CorpWarRetractedMsg',
        CorpWarSurrenderMsg = <any> 'CorpWarSurrenderMsg',
        CustomsMsg = <any> 'CustomsMsg',
        DeclareWar = <any> 'DeclareWar',
        DistrictAttacked = <any> 'DistrictAttacked',
        DustAppAcceptedMsg = <any> 'DustAppAcceptedMsg',
        ESSMainBankLink = <any> 'ESSMainBankLink',
        EntosisCaptureStarted = <any> 'EntosisCaptureStarted',
        ExpertSystemExpired = <any> 'ExpertSystemExpired',
        ExpertSystemExpiryImminent = <any> 'ExpertSystemExpiryImminent',
        FWAllianceKickMsg = <any> 'FWAllianceKickMsg',
        FWAllianceWarningMsg = <any> 'FWAllianceWarningMsg',
        FWCharKickMsg = <any> 'FWCharKickMsg',
        FWCharRankGainMsg = <any> 'FWCharRankGainMsg',
        FWCharRankLossMsg = <any> 'FWCharRankLossMsg',
        FWCharWarningMsg = <any> 'FWCharWarningMsg',
        FWCorpJoinMsg = <any> 'FWCorpJoinMsg',
        FWCorpKickMsg = <any> 'FWCorpKickMsg',
        FWCorpLeaveMsg = <any> 'FWCorpLeaveMsg',
        FWCorpWarningMsg = <any> 'FWCorpWarningMsg',
        FacWarCorpJoinRequestMsg = <any> 'FacWarCorpJoinRequestMsg',
        FacWarCorpJoinWithdrawMsg = <any> 'FacWarCorpJoinWithdrawMsg',
        FacWarCorpLeaveRequestMsg = <any> 'FacWarCorpLeaveRequestMsg',
        FacWarCorpLeaveWithdrawMsg = <any> 'FacWarCorpLeaveWithdrawMsg',
        FacWarLPDisqualifiedEvent = <any> 'FacWarLPDisqualifiedEvent',
        FacWarLPDisqualifiedKill = <any> 'FacWarLPDisqualifiedKill',
        FacWarLPPayoutEvent = <any> 'FacWarLPPayoutEvent',
        FacWarLPPayoutKill = <any> 'FacWarLPPayoutKill',
        GameTimeAdded = <any> 'GameTimeAdded',
        GameTimeReceived = <any> 'GameTimeReceived',
        GameTimeSent = <any> 'GameTimeSent',
        GiftReceived = <any> 'GiftReceived',
        IHubDestroyedByBillFailure = <any> 'IHubDestroyedByBillFailure',
        IncursionCompletedMsg = <any> 'IncursionCompletedMsg',
        IndustryOperationFinished = <any> 'IndustryOperationFinished',
        IndustryTeamAuctionLost = <any> 'IndustryTeamAuctionLost',
        IndustryTeamAuctionWon = <any> 'IndustryTeamAuctionWon',
        InfrastructureHubBillAboutToExpire = <any> 'InfrastructureHubBillAboutToExpire',
        InsuranceExpirationMsg = <any> 'InsuranceExpirationMsg',
        InsuranceFirstShipMsg = <any> 'InsuranceFirstShipMsg',
        InsuranceInvalidatedMsg = <any> 'InsuranceInvalidatedMsg',
        InsuranceIssuedMsg = <any> 'InsuranceIssuedMsg',
        InsurancePayoutMsg = <any> 'InsurancePayoutMsg',
        InvasionCompletedMsg = <any> 'InvasionCompletedMsg',
        InvasionSystemLogin = <any> 'InvasionSystemLogin',
        InvasionSystemStart = <any> 'InvasionSystemStart',
        JumpCloneDeletedMsg1 = <any> 'JumpCloneDeletedMsg1',
        JumpCloneDeletedMsg2 = <any> 'JumpCloneDeletedMsg2',
        KillReportFinalBlow = <any> 'KillReportFinalBlow',
        KillReportVictim = <any> 'KillReportVictim',
        KillRightAvailable = <any> 'KillRightAvailable',
        KillRightAvailableOpen = <any> 'KillRightAvailableOpen',
        KillRightEarned = <any> 'KillRightEarned',
        KillRightUnavailable = <any> 'KillRightUnavailable',
        KillRightUnavailableOpen = <any> 'KillRightUnavailableOpen',
        KillRightUsed = <any> 'KillRightUsed',
        LocateCharMsg = <any> 'LocateCharMsg',
        MadeWarMutual = <any> 'MadeWarMutual',
        MercOfferRetractedMsg = <any> 'MercOfferRetractedMsg',
        MercOfferedNegotiationMsg = <any> 'MercOfferedNegotiationMsg',
        MissionCanceledTriglavian = <any> 'MissionCanceledTriglavian',
        MissionOfferExpirationMsg = <any> 'MissionOfferExpirationMsg',
        MissionTimeoutMsg = <any> 'MissionTimeoutMsg',
        MoonminingAutomaticFracture = <any> 'MoonminingAutomaticFracture',
        MoonminingExtractionCancelled = <any> 'MoonminingExtractionCancelled',
        MoonminingExtractionFinished = <any> 'MoonminingExtractionFinished',
        MoonminingExtractionStarted = <any> 'MoonminingExtractionStarted',
        MoonminingLaserFired = <any> 'MoonminingLaserFired',
        MutualWarExpired = <any> 'MutualWarExpired',
        MutualWarInviteAccepted = <any> 'MutualWarInviteAccepted',
        MutualWarInviteRejected = <any> 'MutualWarInviteRejected',
        MutualWarInviteSent = <any> 'MutualWarInviteSent',
        NPCStandingsGained = <any> 'NPCStandingsGained',
        NPCStandingsLost = <any> 'NPCStandingsLost',
        OfferToAllyRetracted = <any> 'OfferToAllyRetracted',
        OfferedSurrender = <any> 'OfferedSurrender',
        OfferedToAlly = <any> 'OfferedToAlly',
        OfficeLeaseCanceledInsufficientStandings = <any> 'OfficeLeaseCanceledInsufficientStandings',
        OldLscMessages = <any> 'OldLscMessages',
        OperationFinished = <any> 'OperationFinished',
        OrbitalAttacked = <any> 'OrbitalAttacked',
        OrbitalReinforced = <any> 'OrbitalReinforced',
        OwnershipTransferred = <any> 'OwnershipTransferred',
        RaffleCreated = <any> 'RaffleCreated',
        RaffleExpired = <any> 'RaffleExpired',
        RaffleFinished = <any> 'RaffleFinished',
        ReimbursementMsg = <any> 'ReimbursementMsg',
        ResearchMissionAvailableMsg = <any> 'ResearchMissionAvailableMsg',
        RetractsWar = <any> 'RetractsWar',
        SeasonalChallengeCompleted = <any> 'SeasonalChallengeCompleted',
        SovAllClaimAquiredMsg = <any> 'SovAllClaimAquiredMsg',
        SovAllClaimLostMsg = <any> 'SovAllClaimLostMsg',
        SovCommandNodeEventStarted = <any> 'SovCommandNodeEventStarted',
        SovCorpBillLateMsg = <any> 'SovCorpBillLateMsg',
        SovCorpClaimFailMsg = <any> 'SovCorpClaimFailMsg',
        SovDisruptorMsg = <any> 'SovDisruptorMsg',
        SovStationEnteredFreeport = <any> 'SovStationEnteredFreeport',
        SovStructureDestroyed = <any> 'SovStructureDestroyed',
        SovStructureReinforced = <any> 'SovStructureReinforced',
        SovStructureSelfDestructCancel = <any> 'SovStructureSelfDestructCancel',
        SovStructureSelfDestructFinished = <any> 'SovStructureSelfDestructFinished',
        SovStructureSelfDestructRequested = <any> 'SovStructureSelfDestructRequested',
        SovereigntyIHDamageMsg = <any> 'SovereigntyIHDamageMsg',
        SovereigntySBUDamageMsg = <any> 'SovereigntySBUDamageMsg',
        SovereigntyTCUDamageMsg = <any> 'SovereigntyTCUDamageMsg',
        StationAggressionMsg1 = <any> 'StationAggressionMsg1',
        StationAggressionMsg2 = <any> 'StationAggressionMsg2',
        StationConquerMsg = <any> 'StationConquerMsg',
        StationServiceDisabled = <any> 'StationServiceDisabled',
        StationServiceEnabled = <any> 'StationServiceEnabled',
        StationStateChangeMsg = <any> 'StationStateChangeMsg',
        StoryLineMissionAvailableMsg = <any> 'StoryLineMissionAvailableMsg',
        StructureAnchoring = <any> 'StructureAnchoring',
        StructureCourierContractChanged = <any> 'StructureCourierContractChanged',
        StructureDestroyed = <any> 'StructureDestroyed',
        StructureFuelAlert = <any> 'StructureFuelAlert',
        StructureImpendingAbandonmentAssetsAtRisk = <any> 'StructureImpendingAbandonmentAssetsAtRisk',
        StructureItemsDelivered = <any> 'StructureItemsDelivered',
        StructureItemsMovedToSafety = <any> 'StructureItemsMovedToSafety',
        StructureLostArmor = <any> 'StructureLostArmor',
        StructureLostShields = <any> 'StructureLostShields',
        StructureOnline = <any> 'StructureOnline',
        StructureServicesOffline = <any> 'StructureServicesOffline',
        StructureUnanchoring = <any> 'StructureUnanchoring',
        StructureUnderAttack = <any> 'StructureUnderAttack',
        StructureWentHighPower = <any> 'StructureWentHighPower',
        StructureWentLowPower = <any> 'StructureWentLowPower',
        StructuresJobsCancelled = <any> 'StructuresJobsCancelled',
        StructuresJobsPaused = <any> 'StructuresJobsPaused',
        StructuresReinforcementChanged = <any> 'StructuresReinforcementChanged',
        TowerAlertMsg = <any> 'TowerAlertMsg',
        TowerResourceAlertMsg = <any> 'TowerResourceAlertMsg',
        TransactionReversalMsg = <any> 'TransactionReversalMsg',
        TutorialMsg = <any> 'TutorialMsg',
        WarAdopted = <any> 'WarAdopted ',
        WarAllyInherited = <any> 'WarAllyInherited',
        WarAllyOfferDeclinedMsg = <any> 'WarAllyOfferDeclinedMsg',
        WarConcordInvalidates = <any> 'WarConcordInvalidates',
        WarDeclared = <any> 'WarDeclared',
        WarEndedHqSecurityDrop = <any> 'WarEndedHqSecurityDrop',
        WarHQRemovedFromSpace = <any> 'WarHQRemovedFromSpace',
        WarInherited = <any> 'WarInherited',
        WarInvalid = <any> 'WarInvalid',
        WarRetracted = <any> 'WarRetracted',
        WarRetractedByConcord = <any> 'WarRetractedByConcord',
        WarSurrenderDeclinedMsg = <any> 'WarSurrenderDeclinedMsg',
        WarSurrenderOfferMsg = <any> 'WarSurrenderOfferMsg'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdNotificationsContacts200Ok
 */
export interface GetCharactersCharacterIdNotificationsContacts200Ok {
    /**
     * message string
     * @type {string}
     * @memberof GetCharactersCharacterIdNotificationsContacts200Ok
     */
    message: string;
    /**
     * notification_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdNotificationsContacts200Ok
     */
    notificationId: number;
    /**
     * send_date string
     * @type {Date}
     * @memberof GetCharactersCharacterIdNotificationsContacts200Ok
     */
    sendDate: Date;
    /**
     * sender_character_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdNotificationsContacts200Ok
     */
    senderCharacterId: number;
    /**
     * A number representing the standing level the receiver has been added at by the sender. The standing levels are as follows: -10 -> Terrible | -5 -> Bad |  0 -> Neutral |  5 -> Good |  10 -> Excellent
     * @type {number}
     * @memberof GetCharactersCharacterIdNotificationsContacts200Ok
     */
    standingLevel: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdOk
 */
export interface GetCharactersCharacterIdOk {
    /**
     * The character's alliance ID
     * @type {number}
     * @memberof GetCharactersCharacterIdOk
     */
    allianceId?: number;
    /**
     * Creation date of the character
     * @type {Date}
     * @memberof GetCharactersCharacterIdOk
     */
    birthday: Date;
    /**
     * bloodline_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdOk
     */
    bloodlineId: number;
    /**
     * The character's corporation ID
     * @type {number}
     * @memberof GetCharactersCharacterIdOk
     */
    corporationId: number;
    /**
     * description string
     * @type {string}
     * @memberof GetCharactersCharacterIdOk
     */
    description?: string;
    /**
     * ID of the faction the character is fighting for, if the character is enlisted in Factional Warfare
     * @type {number}
     * @memberof GetCharactersCharacterIdOk
     */
    factionId?: number;
    /**
     * gender string
     * @type {string}
     * @memberof GetCharactersCharacterIdOk
     */
    gender: GetCharactersCharacterIdOk.GenderEnum;
    /**
     * name string
     * @type {string}
     * @memberof GetCharactersCharacterIdOk
     */
    name: string;
    /**
     * race_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdOk
     */
    raceId: number;
    /**
     * security_status number
     * @type {number}
     * @memberof GetCharactersCharacterIdOk
     */
    securityStatus?: number;
    /**
     * The individual title of the character
     * @type {string}
     * @memberof GetCharactersCharacterIdOk
     */
    title?: string;
}

/**
 * @export
 * @namespace GetCharactersCharacterIdOk
 */
export namespace GetCharactersCharacterIdOk {
    /**
     * @export
     * @enum {string}
     */
    export enum GenderEnum {
        Female = <any> 'female',
        Male = <any> 'male'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdOnlineOk
 */
export interface GetCharactersCharacterIdOnlineOk {
    /**
     * Timestamp of the last login
     * @type {Date}
     * @memberof GetCharactersCharacterIdOnlineOk
     */
    lastLogin?: Date;
    /**
     * Timestamp of the last logout
     * @type {Date}
     * @memberof GetCharactersCharacterIdOnlineOk
     */
    lastLogout?: Date;
    /**
     * Total number of times the character has logged in
     * @type {number}
     * @memberof GetCharactersCharacterIdOnlineOk
     */
    logins?: number;
    /**
     * If the character is online
     * @type {boolean}
     * @memberof GetCharactersCharacterIdOnlineOk
     */
    online: boolean;
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdOpportunities200Ok
 */
export interface GetCharactersCharacterIdOpportunities200Ok {
    /**
     * completed_at string
     * @type {Date}
     * @memberof GetCharactersCharacterIdOpportunities200Ok
     */
    completedAt: Date;
    /**
     * task_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdOpportunities200Ok
     */
    taskId: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdOrders200Ok
 */
export interface GetCharactersCharacterIdOrders200Ok {
    /**
     * Number of days for which order is valid (starting from the issued date). An order expires at time issued + duration
     * @type {number}
     * @memberof GetCharactersCharacterIdOrders200Ok
     */
    duration: number;
    /**
     * For buy orders, the amount of ISK in escrow
     * @type {number}
     * @memberof GetCharactersCharacterIdOrders200Ok
     */
    escrow?: number;
    /**
     * True if the order is a bid (buy) order
     * @type {boolean}
     * @memberof GetCharactersCharacterIdOrders200Ok
     */
    isBuyOrder?: boolean;
    /**
     * Signifies whether the buy/sell order was placed on behalf of a corporation.
     * @type {boolean}
     * @memberof GetCharactersCharacterIdOrders200Ok
     */
    isCorporation: boolean;
    /**
     * Date and time when this order was issued
     * @type {Date}
     * @memberof GetCharactersCharacterIdOrders200Ok
     */
    issued: Date;
    /**
     * ID of the location where order was placed
     * @type {number}
     * @memberof GetCharactersCharacterIdOrders200Ok
     */
    locationId: number;
    /**
     * For buy orders, the minimum quantity that will be accepted in a matching sell order
     * @type {number}
     * @memberof GetCharactersCharacterIdOrders200Ok
     */
    minVolume?: number;
    /**
     * Unique order ID
     * @type {number}
     * @memberof GetCharactersCharacterIdOrders200Ok
     */
    orderId: number;
    /**
     * Cost per unit for this order
     * @type {number}
     * @memberof GetCharactersCharacterIdOrders200Ok
     */
    price: number;
    /**
     * Valid order range, numbers are ranges in jumps
     * @type {string}
     * @memberof GetCharactersCharacterIdOrders200Ok
     */
    range: GetCharactersCharacterIdOrders200Ok.RangeEnum;
    /**
     * ID of the region where order was placed
     * @type {number}
     * @memberof GetCharactersCharacterIdOrders200Ok
     */
    regionId: number;
    /**
     * The type ID of the item transacted in this order
     * @type {number}
     * @memberof GetCharactersCharacterIdOrders200Ok
     */
    typeId: number;
    /**
     * Quantity of items still required or offered
     * @type {number}
     * @memberof GetCharactersCharacterIdOrders200Ok
     */
    volumeRemain: number;
    /**
     * Quantity of items required or offered at time order was placed
     * @type {number}
     * @memberof GetCharactersCharacterIdOrders200Ok
     */
    volumeTotal: number;
}

/**
 * @export
 * @namespace GetCharactersCharacterIdOrders200Ok
 */
export namespace GetCharactersCharacterIdOrders200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum RangeEnum {
        _1 = <any> '1',
        _10 = <any> '10',
        _2 = <any> '2',
        _20 = <any> '20',
        _3 = <any> '3',
        _30 = <any> '30',
        _4 = <any> '4',
        _40 = <any> '40',
        _5 = <any> '5',
        Region = <any> 'region',
        Solarsystem = <any> 'solarsystem',
        Station = <any> 'station'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdOrdersHistory200Ok
 */
export interface GetCharactersCharacterIdOrdersHistory200Ok {
    /**
     * Number of days the order was valid for (starting from the issued date). An order expires at time issued + duration
     * @type {number}
     * @memberof GetCharactersCharacterIdOrdersHistory200Ok
     */
    duration: number;
    /**
     * For buy orders, the amount of ISK in escrow
     * @type {number}
     * @memberof GetCharactersCharacterIdOrdersHistory200Ok
     */
    escrow?: number;
    /**
     * True if the order is a bid (buy) order
     * @type {boolean}
     * @memberof GetCharactersCharacterIdOrdersHistory200Ok
     */
    isBuyOrder?: boolean;
    /**
     * Signifies whether the buy/sell order was placed on behalf of a corporation.
     * @type {boolean}
     * @memberof GetCharactersCharacterIdOrdersHistory200Ok
     */
    isCorporation: boolean;
    /**
     * Date and time when this order was issued
     * @type {Date}
     * @memberof GetCharactersCharacterIdOrdersHistory200Ok
     */
    issued: Date;
    /**
     * ID of the location where order was placed
     * @type {number}
     * @memberof GetCharactersCharacterIdOrdersHistory200Ok
     */
    locationId: number;
    /**
     * For buy orders, the minimum quantity that will be accepted in a matching sell order
     * @type {number}
     * @memberof GetCharactersCharacterIdOrdersHistory200Ok
     */
    minVolume?: number;
    /**
     * Unique order ID
     * @type {number}
     * @memberof GetCharactersCharacterIdOrdersHistory200Ok
     */
    orderId: number;
    /**
     * Cost per unit for this order
     * @type {number}
     * @memberof GetCharactersCharacterIdOrdersHistory200Ok
     */
    price: number;
    /**
     * Valid order range, numbers are ranges in jumps
     * @type {string}
     * @memberof GetCharactersCharacterIdOrdersHistory200Ok
     */
    range: GetCharactersCharacterIdOrdersHistory200Ok.RangeEnum;
    /**
     * ID of the region where order was placed
     * @type {number}
     * @memberof GetCharactersCharacterIdOrdersHistory200Ok
     */
    regionId: number;
    /**
     * Current order state
     * @type {string}
     * @memberof GetCharactersCharacterIdOrdersHistory200Ok
     */
    state: GetCharactersCharacterIdOrdersHistory200Ok.StateEnum;
    /**
     * The type ID of the item transacted in this order
     * @type {number}
     * @memberof GetCharactersCharacterIdOrdersHistory200Ok
     */
    typeId: number;
    /**
     * Quantity of items still required or offered
     * @type {number}
     * @memberof GetCharactersCharacterIdOrdersHistory200Ok
     */
    volumeRemain: number;
    /**
     * Quantity of items required or offered at time order was placed
     * @type {number}
     * @memberof GetCharactersCharacterIdOrdersHistory200Ok
     */
    volumeTotal: number;
}

/**
 * @export
 * @namespace GetCharactersCharacterIdOrdersHistory200Ok
 */
export namespace GetCharactersCharacterIdOrdersHistory200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum RangeEnum {
        _1 = <any> '1',
        _10 = <any> '10',
        _2 = <any> '2',
        _20 = <any> '20',
        _3 = <any> '3',
        _30 = <any> '30',
        _4 = <any> '4',
        _40 = <any> '40',
        _5 = <any> '5',
        Region = <any> 'region',
        Solarsystem = <any> 'solarsystem',
        Station = <any> 'station'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        Cancelled = <any> 'cancelled',
        Expired = <any> 'expired'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdPlanets200Ok
 */
export interface GetCharactersCharacterIdPlanets200Ok {
    /**
     * last_update string
     * @type {Date}
     * @memberof GetCharactersCharacterIdPlanets200Ok
     */
    lastUpdate: Date;
    /**
     * num_pins integer
     * @type {number}
     * @memberof GetCharactersCharacterIdPlanets200Ok
     */
    numPins: number;
    /**
     * owner_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdPlanets200Ok
     */
    ownerId: number;
    /**
     * planet_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdPlanets200Ok
     */
    planetId: number;
    /**
     * planet_type string
     * @type {string}
     * @memberof GetCharactersCharacterIdPlanets200Ok
     */
    planetType: GetCharactersCharacterIdPlanets200Ok.PlanetTypeEnum;
    /**
     * solar_system_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdPlanets200Ok
     */
    solarSystemId: number;
    /**
     * upgrade_level integer
     * @type {number}
     * @memberof GetCharactersCharacterIdPlanets200Ok
     */
    upgradeLevel: number;
}

/**
 * @export
 * @namespace GetCharactersCharacterIdPlanets200Ok
 */
export namespace GetCharactersCharacterIdPlanets200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum PlanetTypeEnum {
        Temperate = <any> 'temperate',
        Barren = <any> 'barren',
        Oceanic = <any> 'oceanic',
        Ice = <any> 'ice',
        Gas = <any> 'gas',
        Lava = <any> 'lava',
        Storm = <any> 'storm',
        Plasma = <any> 'plasma'
    }
}

/**
 * content object
 * @export
 * @interface GetCharactersCharacterIdPlanetsPlanetIdContent
 */
export interface GetCharactersCharacterIdPlanetsPlanetIdContent {
    /**
     * amount integer
     * @type {number}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdContent
     */
    amount: number;
    /**
     * type_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdContent
     */
    typeId: number;
}

/**
 * extractor_details object
 * @export
 * @interface GetCharactersCharacterIdPlanetsPlanetIdExtractorDetails
 */
export interface GetCharactersCharacterIdPlanetsPlanetIdExtractorDetails {
    /**
     * in seconds
     * @type {number}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdExtractorDetails
     */
    cycleTime?: number;
    /**
     * head_radius number
     * @type {number}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdExtractorDetails
     */
    headRadius?: number;
    /**
     * heads array
     * @type {Array<GetCharactersCharacterIdPlanetsPlanetIdHead>}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdExtractorDetails
     */
    heads: Array<GetCharactersCharacterIdPlanetsPlanetIdHead>;
    /**
     * product_type_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdExtractorDetails
     */
    productTypeId?: number;
    /**
     * qty_per_cycle integer
     * @type {number}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdExtractorDetails
     */
    qtyPerCycle?: number;
}

/**
 * factory_details object
 * @export
 * @interface GetCharactersCharacterIdPlanetsPlanetIdFactoryDetails
 */
export interface GetCharactersCharacterIdPlanetsPlanetIdFactoryDetails {
    /**
     * schematic_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdFactoryDetails
     */
    schematicId: number;
}

/**
 * head object
 * @export
 * @interface GetCharactersCharacterIdPlanetsPlanetIdHead
 */
export interface GetCharactersCharacterIdPlanetsPlanetIdHead {
    /**
     * head_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdHead
     */
    headId: number;
    /**
     * latitude number
     * @type {number}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdHead
     */
    latitude: number;
    /**
     * longitude number
     * @type {number}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdHead
     */
    longitude: number;
}

/**
 * link object
 * @export
 * @interface GetCharactersCharacterIdPlanetsPlanetIdLink
 */
export interface GetCharactersCharacterIdPlanetsPlanetIdLink {
    /**
     * destination_pin_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdLink
     */
    destinationPinId: number;
    /**
     * link_level integer
     * @type {number}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdLink
     */
    linkLevel: number;
    /**
     * source_pin_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdLink
     */
    sourcePinId: number;
}

/**
 * Colony not found
 * @export
 * @interface GetCharactersCharacterIdPlanetsPlanetIdNotFound
 */
export interface GetCharactersCharacterIdPlanetsPlanetIdNotFound {
    /**
     * error message
     * @type {string}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdPlanetsPlanetIdOk
 */
export interface GetCharactersCharacterIdPlanetsPlanetIdOk {
    /**
     * links array
     * @type {Array<GetCharactersCharacterIdPlanetsPlanetIdLink>}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdOk
     */
    links: Array<GetCharactersCharacterIdPlanetsPlanetIdLink>;
    /**
     * pins array
     * @type {Array<GetCharactersCharacterIdPlanetsPlanetIdPin>}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdOk
     */
    pins: Array<GetCharactersCharacterIdPlanetsPlanetIdPin>;
    /**
     * routes array
     * @type {Array<GetCharactersCharacterIdPlanetsPlanetIdRoute>}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdOk
     */
    routes: Array<GetCharactersCharacterIdPlanetsPlanetIdRoute>;
}

/**
 * pin object
 * @export
 * @interface GetCharactersCharacterIdPlanetsPlanetIdPin
 */
export interface GetCharactersCharacterIdPlanetsPlanetIdPin {
    /**
     * contents array
     * @type {Array<GetCharactersCharacterIdPlanetsPlanetIdContent>}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdPin
     */
    contents?: Array<GetCharactersCharacterIdPlanetsPlanetIdContent>;
    /**
     * expiry_time string
     * @type {Date}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdPin
     */
    expiryTime?: Date;
    /**
     * 
     * @type {GetCharactersCharacterIdPlanetsPlanetIdExtractorDetails}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdPin
     */
    extractorDetails?: GetCharactersCharacterIdPlanetsPlanetIdExtractorDetails;
    /**
     * 
     * @type {GetCharactersCharacterIdPlanetsPlanetIdFactoryDetails}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdPin
     */
    factoryDetails?: GetCharactersCharacterIdPlanetsPlanetIdFactoryDetails;
    /**
     * install_time string
     * @type {Date}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdPin
     */
    installTime?: Date;
    /**
     * last_cycle_start string
     * @type {Date}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdPin
     */
    lastCycleStart?: Date;
    /**
     * latitude number
     * @type {number}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdPin
     */
    latitude: number;
    /**
     * longitude number
     * @type {number}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdPin
     */
    longitude: number;
    /**
     * pin_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdPin
     */
    pinId: number;
    /**
     * schematic_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdPin
     */
    schematicId?: number;
    /**
     * type_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdPin
     */
    typeId: number;
}

/**
 * route object
 * @export
 * @interface GetCharactersCharacterIdPlanetsPlanetIdRoute
 */
export interface GetCharactersCharacterIdPlanetsPlanetIdRoute {
    /**
     * content_type_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdRoute
     */
    contentTypeId: number;
    /**
     * destination_pin_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdRoute
     */
    destinationPinId: number;
    /**
     * quantity number
     * @type {number}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdRoute
     */
    quantity: number;
    /**
     * route_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdRoute
     */
    routeId: number;
    /**
     * source_pin_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdRoute
     */
    sourcePinId: number;
    /**
     * list of pin ID waypoints
     * @type {Array<number>}
     * @memberof GetCharactersCharacterIdPlanetsPlanetIdRoute
     */
    waypoints?: Array<number>;
}

/**
 * No image server for this datasource
 * @export
 * @interface GetCharactersCharacterIdPortraitNotFound
 */
export interface GetCharactersCharacterIdPortraitNotFound {
    /**
     * error message
     * @type {string}
     * @memberof GetCharactersCharacterIdPortraitNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdPortraitOk
 */
export interface GetCharactersCharacterIdPortraitOk {
    /**
     * px128x128 string
     * @type {string}
     * @memberof GetCharactersCharacterIdPortraitOk
     */
    px128x128?: string;
    /**
     * px256x256 string
     * @type {string}
     * @memberof GetCharactersCharacterIdPortraitOk
     */
    px256x256?: string;
    /**
     * px512x512 string
     * @type {string}
     * @memberof GetCharactersCharacterIdPortraitOk
     */
    px512x512?: string;
    /**
     * px64x64 string
     * @type {string}
     * @memberof GetCharactersCharacterIdPortraitOk
     */
    px64x64?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdRolesOk
 */
export interface GetCharactersCharacterIdRolesOk {
    /**
     * roles array
     * @type {Array<string>}
     * @memberof GetCharactersCharacterIdRolesOk
     */
    roles?: Array<GetCharactersCharacterIdRolesOk.RolesEnum>;
    /**
     * roles_at_base array
     * @type {Array<string>}
     * @memberof GetCharactersCharacterIdRolesOk
     */
    rolesAtBase?: Array<GetCharactersCharacterIdRolesOk.RolesAtBaseEnum>;
    /**
     * roles_at_hq array
     * @type {Array<string>}
     * @memberof GetCharactersCharacterIdRolesOk
     */
    rolesAtHq?: Array<GetCharactersCharacterIdRolesOk.RolesAtHqEnum>;
    /**
     * roles_at_other array
     * @type {Array<string>}
     * @memberof GetCharactersCharacterIdRolesOk
     */
    rolesAtOther?: Array<GetCharactersCharacterIdRolesOk.RolesAtOtherEnum>;
}

/**
 * @export
 * @namespace GetCharactersCharacterIdRolesOk
 */
export namespace GetCharactersCharacterIdRolesOk {
    /**
     * @export
     * @enum {string}
     */
    export enum RolesEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RolesAtBaseEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RolesAtHqEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RolesAtOtherEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdSearchOk
 */
export interface GetCharactersCharacterIdSearchOk {
    /**
     * agent array
     * @type {Array<number>}
     * @memberof GetCharactersCharacterIdSearchOk
     */
    agent?: Array<number>;
    /**
     * alliance array
     * @type {Array<number>}
     * @memberof GetCharactersCharacterIdSearchOk
     */
    alliance?: Array<number>;
    /**
     * character array
     * @type {Array<number>}
     * @memberof GetCharactersCharacterIdSearchOk
     */
    character?: Array<number>;
    /**
     * constellation array
     * @type {Array<number>}
     * @memberof GetCharactersCharacterIdSearchOk
     */
    constellation?: Array<number>;
    /**
     * corporation array
     * @type {Array<number>}
     * @memberof GetCharactersCharacterIdSearchOk
     */
    corporation?: Array<number>;
    /**
     * faction array
     * @type {Array<number>}
     * @memberof GetCharactersCharacterIdSearchOk
     */
    faction?: Array<number>;
    /**
     * inventory_type array
     * @type {Array<number>}
     * @memberof GetCharactersCharacterIdSearchOk
     */
    inventoryType?: Array<number>;
    /**
     * region array
     * @type {Array<number>}
     * @memberof GetCharactersCharacterIdSearchOk
     */
    region?: Array<number>;
    /**
     * solar_system array
     * @type {Array<number>}
     * @memberof GetCharactersCharacterIdSearchOk
     */
    solarSystem?: Array<number>;
    /**
     * station array
     * @type {Array<number>}
     * @memberof GetCharactersCharacterIdSearchOk
     */
    station?: Array<number>;
    /**
     * structure array
     * @type {Array<number>}
     * @memberof GetCharactersCharacterIdSearchOk
     */
    structure?: Array<number>;
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdShipOk
 */
export interface GetCharactersCharacterIdShipOk {
    /**
     * Item id's are unique to a ship and persist until it is repackaged. This value can be used to track repeated uses of a ship, or detect when a pilot changes into a different instance of the same ship type.
     * @type {number}
     * @memberof GetCharactersCharacterIdShipOk
     */
    shipItemId: number;
    /**
     * ship_name string
     * @type {string}
     * @memberof GetCharactersCharacterIdShipOk
     */
    shipName: string;
    /**
     * ship_type_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdShipOk
     */
    shipTypeId: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdSkillqueue200Ok
 */
export interface GetCharactersCharacterIdSkillqueue200Ok {
    /**
     * Date on which training of the skill will complete. Omitted if the skill queue is paused.
     * @type {Date}
     * @memberof GetCharactersCharacterIdSkillqueue200Ok
     */
    finishDate?: Date;
    /**
     * finished_level integer
     * @type {number}
     * @memberof GetCharactersCharacterIdSkillqueue200Ok
     */
    finishedLevel: number;
    /**
     * level_end_sp integer
     * @type {number}
     * @memberof GetCharactersCharacterIdSkillqueue200Ok
     */
    levelEndSp?: number;
    /**
     * Amount of SP that was in the skill when it started training it's current level. Used to calculate % of current level complete.
     * @type {number}
     * @memberof GetCharactersCharacterIdSkillqueue200Ok
     */
    levelStartSp?: number;
    /**
     * queue_position integer
     * @type {number}
     * @memberof GetCharactersCharacterIdSkillqueue200Ok
     */
    queuePosition: number;
    /**
     * skill_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdSkillqueue200Ok
     */
    skillId: number;
    /**
     * start_date string
     * @type {Date}
     * @memberof GetCharactersCharacterIdSkillqueue200Ok
     */
    startDate?: Date;
    /**
     * training_start_sp integer
     * @type {number}
     * @memberof GetCharactersCharacterIdSkillqueue200Ok
     */
    trainingStartSp?: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdSkillsOk
 */
export interface GetCharactersCharacterIdSkillsOk {
    /**
     * skills array
     * @type {Array<GetCharactersCharacterIdSkillsSkill>}
     * @memberof GetCharactersCharacterIdSkillsOk
     */
    skills: Array<GetCharactersCharacterIdSkillsSkill>;
    /**
     * total_sp integer
     * @type {number}
     * @memberof GetCharactersCharacterIdSkillsOk
     */
    totalSp: number;
    /**
     * Skill points available to be assigned
     * @type {number}
     * @memberof GetCharactersCharacterIdSkillsOk
     */
    unallocatedSp?: number;
}

/**
 * skill object
 * @export
 * @interface GetCharactersCharacterIdSkillsSkill
 */
export interface GetCharactersCharacterIdSkillsSkill {
    /**
     * active_skill_level integer
     * @type {number}
     * @memberof GetCharactersCharacterIdSkillsSkill
     */
    activeSkillLevel: number;
    /**
     * skill_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdSkillsSkill
     */
    skillId: number;
    /**
     * skillpoints_in_skill integer
     * @type {number}
     * @memberof GetCharactersCharacterIdSkillsSkill
     */
    skillpointsInSkill: number;
    /**
     * trained_skill_level integer
     * @type {number}
     * @memberof GetCharactersCharacterIdSkillsSkill
     */
    trainedSkillLevel: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdStandings200Ok
 */
export interface GetCharactersCharacterIdStandings200Ok {
    /**
     * from_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdStandings200Ok
     */
    fromId: number;
    /**
     * from_type string
     * @type {string}
     * @memberof GetCharactersCharacterIdStandings200Ok
     */
    fromType: GetCharactersCharacterIdStandings200Ok.FromTypeEnum;
    /**
     * standing number
     * @type {number}
     * @memberof GetCharactersCharacterIdStandings200Ok
     */
    standing: number;
}

/**
 * @export
 * @namespace GetCharactersCharacterIdStandings200Ok
 */
export namespace GetCharactersCharacterIdStandings200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum FromTypeEnum {
        Agent = <any> 'agent',
        NpcCorp = <any> 'npc_corp',
        Faction = <any> 'faction'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdTitles200Ok
 */
export interface GetCharactersCharacterIdTitles200Ok {
    /**
     * name string
     * @type {string}
     * @memberof GetCharactersCharacterIdTitles200Ok
     */
    name?: string;
    /**
     * title_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdTitles200Ok
     */
    titleId?: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetCharactersCharacterIdWalletJournal200Ok
 */
export interface GetCharactersCharacterIdWalletJournal200Ok {
    /**
     * The amount of ISK given or taken from the wallet as a result of the given transaction. Positive when ISK is deposited into the wallet and negative when ISK is withdrawn
     * @type {number}
     * @memberof GetCharactersCharacterIdWalletJournal200Ok
     */
    amount?: number;
    /**
     * Wallet balance after transaction occurred
     * @type {number}
     * @memberof GetCharactersCharacterIdWalletJournal200Ok
     */
    balance?: number;
    /**
     * An ID that gives extra context to the particular transaction. Because of legacy reasons the context is completely different per ref_type and means different things. It is also possible to not have a context_id
     * @type {number}
     * @memberof GetCharactersCharacterIdWalletJournal200Ok
     */
    contextId?: number;
    /**
     * The type of the given context_id if present
     * @type {string}
     * @memberof GetCharactersCharacterIdWalletJournal200Ok
     */
    contextIdType?: GetCharactersCharacterIdWalletJournal200Ok.ContextIdTypeEnum;
    /**
     * Date and time of transaction
     * @type {Date}
     * @memberof GetCharactersCharacterIdWalletJournal200Ok
     */
    date: Date;
    /**
     * The reason for the transaction, mirrors what is seen in the client
     * @type {string}
     * @memberof GetCharactersCharacterIdWalletJournal200Ok
     */
    description: string;
    /**
     * The id of the first party involved in the transaction. This attribute has no consistency and is different or non existant for particular ref_types. The description attribute will help make sense of what this attribute means. For more info about the given ID it can be dropped into the /universe/names/ ESI route to determine its type and name
     * @type {number}
     * @memberof GetCharactersCharacterIdWalletJournal200Ok
     */
    firstPartyId?: number;
    /**
     * Unique journal reference ID
     * @type {number}
     * @memberof GetCharactersCharacterIdWalletJournal200Ok
     */
    id: number;
    /**
     * The user stated reason for the transaction. Only applies to some ref_types
     * @type {string}
     * @memberof GetCharactersCharacterIdWalletJournal200Ok
     */
    reason?: string;
    /**
     * \"The transaction type for the given. transaction. Different transaction types will populate different attributes.\"
     * @type {string}
     * @memberof GetCharactersCharacterIdWalletJournal200Ok
     */
    refType: GetCharactersCharacterIdWalletJournal200Ok.RefTypeEnum;
    /**
     * The id of the second party involved in the transaction. This attribute has no consistency and is different or non existant for particular ref_types. The description attribute will help make sense of what this attribute means. For more info about the given ID it can be dropped into the /universe/names/ ESI route to determine its type and name
     * @type {number}
     * @memberof GetCharactersCharacterIdWalletJournal200Ok
     */
    secondPartyId?: number;
    /**
     * Tax amount received. Only applies to tax related transactions
     * @type {number}
     * @memberof GetCharactersCharacterIdWalletJournal200Ok
     */
    tax?: number;
    /**
     * The corporation ID receiving any tax paid. Only applies to tax related transactions
     * @type {number}
     * @memberof GetCharactersCharacterIdWalletJournal200Ok
     */
    taxReceiverId?: number;
}

/**
 * @export
 * @namespace GetCharactersCharacterIdWalletJournal200Ok
 */
export namespace GetCharactersCharacterIdWalletJournal200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum ContextIdTypeEnum {
        StructureId = <any> 'structure_id',
        StationId = <any> 'station_id',
        MarketTransactionId = <any> 'market_transaction_id',
        CharacterId = <any> 'character_id',
        CorporationId = <any> 'corporation_id',
        AllianceId = <any> 'alliance_id',
        EveSystem = <any> 'eve_system',
        IndustryJobId = <any> 'industry_job_id',
        ContractId = <any> 'contract_id',
        PlanetId = <any> 'planet_id',
        SystemId = <any> 'system_id',
        TypeId = <any> 'type_id'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RefTypeEnum {
        AccelerationGateFee = <any> 'acceleration_gate_fee',
        AdvertisementListingFee = <any> 'advertisement_listing_fee',
        AgentDonation = <any> 'agent_donation',
        AgentLocationServices = <any> 'agent_location_services',
        AgentMiscellaneous = <any> 'agent_miscellaneous',
        AgentMissionCollateralPaid = <any> 'agent_mission_collateral_paid',
        AgentMissionCollateralRefunded = <any> 'agent_mission_collateral_refunded',
        AgentMissionReward = <any> 'agent_mission_reward',
        AgentMissionRewardCorporationTax = <any> 'agent_mission_reward_corporation_tax',
        AgentMissionTimeBonusReward = <any> 'agent_mission_time_bonus_reward',
        AgentMissionTimeBonusRewardCorporationTax = <any> 'agent_mission_time_bonus_reward_corporation_tax',
        AgentSecurityServices = <any> 'agent_security_services',
        AgentServicesRendered = <any> 'agent_services_rendered',
        AgentsPreward = <any> 'agents_preward',
        AllianceMaintainanceFee = <any> 'alliance_maintainance_fee',
        AllianceRegistrationFee = <any> 'alliance_registration_fee',
        AssetSafetyRecoveryTax = <any> 'asset_safety_recovery_tax',
        Bounty = <any> 'bounty',
        BountyPrize = <any> 'bounty_prize',
        BountyPrizeCorporationTax = <any> 'bounty_prize_corporation_tax',
        BountyPrizes = <any> 'bounty_prizes',
        BountyReimbursement = <any> 'bounty_reimbursement',
        BountySurcharge = <any> 'bounty_surcharge',
        BrokersFee = <any> 'brokers_fee',
        CloneActivation = <any> 'clone_activation',
        CloneTransfer = <any> 'clone_transfer',
        ContrabandFine = <any> 'contraband_fine',
        ContractAuctionBid = <any> 'contract_auction_bid',
        ContractAuctionBidCorp = <any> 'contract_auction_bid_corp',
        ContractAuctionBidRefund = <any> 'contract_auction_bid_refund',
        ContractAuctionSold = <any> 'contract_auction_sold',
        ContractBrokersFee = <any> 'contract_brokers_fee',
        ContractBrokersFeeCorp = <any> 'contract_brokers_fee_corp',
        ContractCollateral = <any> 'contract_collateral',
        ContractCollateralDepositedCorp = <any> 'contract_collateral_deposited_corp',
        ContractCollateralPayout = <any> 'contract_collateral_payout',
        ContractCollateralRefund = <any> 'contract_collateral_refund',
        ContractDeposit = <any> 'contract_deposit',
        ContractDepositCorp = <any> 'contract_deposit_corp',
        ContractDepositRefund = <any> 'contract_deposit_refund',
        ContractDepositSalesTax = <any> 'contract_deposit_sales_tax',
        ContractPrice = <any> 'contract_price',
        ContractPricePaymentCorp = <any> 'contract_price_payment_corp',
        ContractReversal = <any> 'contract_reversal',
        ContractReward = <any> 'contract_reward',
        ContractRewardDeposited = <any> 'contract_reward_deposited',
        ContractRewardDepositedCorp = <any> 'contract_reward_deposited_corp',
        ContractRewardRefund = <any> 'contract_reward_refund',
        ContractSalesTax = <any> 'contract_sales_tax',
        Copying = <any> 'copying',
        CorporateRewardPayout = <any> 'corporate_reward_payout',
        CorporateRewardTax = <any> 'corporate_reward_tax',
        CorporationAccountWithdrawal = <any> 'corporation_account_withdrawal',
        CorporationBulkPayment = <any> 'corporation_bulk_payment',
        CorporationDividendPayment = <any> 'corporation_dividend_payment',
        CorporationLiquidation = <any> 'corporation_liquidation',
        CorporationLogoChangeCost = <any> 'corporation_logo_change_cost',
        CorporationPayment = <any> 'corporation_payment',
        CorporationRegistrationFee = <any> 'corporation_registration_fee',
        CourierMissionEscrow = <any> 'courier_mission_escrow',
        Cspa = <any> 'cspa',
        Cspaofflinerefund = <any> 'cspaofflinerefund',
        DailyChallengeReward = <any> 'daily_challenge_reward',
        DatacoreFee = <any> 'datacore_fee',
        DnaModificationFee = <any> 'dna_modification_fee',
        DockingFee = <any> 'docking_fee',
        DuelWagerEscrow = <any> 'duel_wager_escrow',
        DuelWagerPayment = <any> 'duel_wager_payment',
        DuelWagerRefund = <any> 'duel_wager_refund',
        EssEscrowTransfer = <any> 'ess_escrow_transfer',
        ExternalTradeDelivery = <any> 'external_trade_delivery',
        ExternalTradeFreeze = <any> 'external_trade_freeze',
        ExternalTradeThaw = <any> 'external_trade_thaw',
        FactorySlotRentalFee = <any> 'factory_slot_rental_fee',
        FluxPayout = <any> 'flux_payout',
        FluxTax = <any> 'flux_tax',
        FluxTicketRepayment = <any> 'flux_ticket_repayment',
        FluxTicketSale = <any> 'flux_ticket_sale',
        GmCashTransfer = <any> 'gm_cash_transfer',
        IndustryJobTax = <any> 'industry_job_tax',
        InfrastructureHubMaintenance = <any> 'infrastructure_hub_maintenance',
        Inheritance = <any> 'inheritance',
        Insurance = <any> 'insurance',
        ItemTraderPayment = <any> 'item_trader_payment',
        JumpCloneActivationFee = <any> 'jump_clone_activation_fee',
        JumpCloneInstallationFee = <any> 'jump_clone_installation_fee',
        KillRightFee = <any> 'kill_right_fee',
        LpStore = <any> 'lp_store',
        Manufacturing = <any> 'manufacturing',
        MarketEscrow = <any> 'market_escrow',
        MarketFinePaid = <any> 'market_fine_paid',
        MarketProviderTax = <any> 'market_provider_tax',
        MarketTransaction = <any> 'market_transaction',
        MedalCreation = <any> 'medal_creation',
        MedalIssued = <any> 'medal_issued',
        MilestoneRewardPayment = <any> 'milestone_reward_payment',
        MissionCompletion = <any> 'mission_completion',
        MissionCost = <any> 'mission_cost',
        MissionExpiration = <any> 'mission_expiration',
        MissionReward = <any> 'mission_reward',
        OfficeRentalFee = <any> 'office_rental_fee',
        OperationBonus = <any> 'operation_bonus',
        OpportunityReward = <any> 'opportunity_reward',
        PlanetaryConstruction = <any> 'planetary_construction',
        PlanetaryExportTax = <any> 'planetary_export_tax',
        PlanetaryImportTax = <any> 'planetary_import_tax',
        PlayerDonation = <any> 'player_donation',
        PlayerTrading = <any> 'player_trading',
        ProjectDiscoveryReward = <any> 'project_discovery_reward',
        ProjectDiscoveryTax = <any> 'project_discovery_tax',
        Reaction = <any> 'reaction',
        RedeemedIskToken = <any> 'redeemed_isk_token',
        ReleaseOfImpoundedProperty = <any> 'release_of_impounded_property',
        RepairBill = <any> 'repair_bill',
        ReprocessingTax = <any> 'reprocessing_tax',
        ResearchingMaterialProductivity = <any> 'researching_material_productivity',
        ResearchingTechnology = <any> 'researching_technology',
        ResearchingTimeProductivity = <any> 'researching_time_productivity',
        ResourceWarsReward = <any> 'resource_wars_reward',
        ReverseEngineering = <any> 'reverse_engineering',
        SeasonChallengeReward = <any> 'season_challenge_reward',
        SecurityProcessingFee = <any> 'security_processing_fee',
        Shares = <any> 'shares',
        SkillPurchase = <any> 'skill_purchase',
        SovereignityBill = <any> 'sovereignity_bill',
        StorePurchase = <any> 'store_purchase',
        StorePurchaseRefund = <any> 'store_purchase_refund',
        StructureGateJump = <any> 'structure_gate_jump',
        TransactionTax = <any> 'transaction_tax',
        UpkeepAdjustmentFee = <any> 'upkeep_adjustment_fee',
        WarAllyContract = <any> 'war_ally_contract',
        WarFee = <any> 'war_fee',
        WarFeeSurrender = <any> 'war_fee_surrender'
    }
}

/**
 * wallet transaction
 * @export
 * @interface GetCharactersCharacterIdWalletTransactions200Ok
 */
export interface GetCharactersCharacterIdWalletTransactions200Ok {
    /**
     * client_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdWalletTransactions200Ok
     */
    clientId: number;
    /**
     * Date and time of transaction
     * @type {Date}
     * @memberof GetCharactersCharacterIdWalletTransactions200Ok
     */
    date: Date;
    /**
     * is_buy boolean
     * @type {boolean}
     * @memberof GetCharactersCharacterIdWalletTransactions200Ok
     */
    isBuy: boolean;
    /**
     * is_personal boolean
     * @type {boolean}
     * @memberof GetCharactersCharacterIdWalletTransactions200Ok
     */
    isPersonal: boolean;
    /**
     * journal_ref_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdWalletTransactions200Ok
     */
    journalRefId: number;
    /**
     * location_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdWalletTransactions200Ok
     */
    locationId: number;
    /**
     * quantity integer
     * @type {number}
     * @memberof GetCharactersCharacterIdWalletTransactions200Ok
     */
    quantity: number;
    /**
     * Unique transaction ID
     * @type {number}
     * @memberof GetCharactersCharacterIdWalletTransactions200Ok
     */
    transactionId: number;
    /**
     * type_id integer
     * @type {number}
     * @memberof GetCharactersCharacterIdWalletTransactions200Ok
     */
    typeId: number;
    /**
     * Amount paid per unit
     * @type {number}
     * @memberof GetCharactersCharacterIdWalletTransactions200Ok
     */
    unitPrice: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetContractsPublicBidsContractId200Ok
 */
export interface GetContractsPublicBidsContractId200Ok {
    /**
     * The amount bid, in ISK
     * @type {number}
     * @memberof GetContractsPublicBidsContractId200Ok
     */
    amount: number;
    /**
     * Unique ID for the bid
     * @type {number}
     * @memberof GetContractsPublicBidsContractId200Ok
     */
    bidId: number;
    /**
     * Datetime when the bid was placed
     * @type {Date}
     * @memberof GetContractsPublicBidsContractId200Ok
     */
    dateBid: Date;
}

/**
 * Forbidden
 * @export
 * @interface GetContractsPublicBidsContractIdForbidden
 */
export interface GetContractsPublicBidsContractIdForbidden {
    /**
     * Forbidden message
     * @type {string}
     * @memberof GetContractsPublicBidsContractIdForbidden
     */
    error?: string;
}

/**
 * Not found
 * @export
 * @interface GetContractsPublicBidsContractIdNotFound
 */
export interface GetContractsPublicBidsContractIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetContractsPublicBidsContractIdNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetContractsPublicItemsContractId200Ok
 */
export interface GetContractsPublicItemsContractId200Ok {
    /**
     * is_blueprint_copy boolean
     * @type {boolean}
     * @memberof GetContractsPublicItemsContractId200Ok
     */
    isBlueprintCopy?: boolean;
    /**
     * true if the contract issuer has submitted this item with the contract, false if the isser is asking for this item in the contract
     * @type {boolean}
     * @memberof GetContractsPublicItemsContractId200Ok
     */
    isIncluded: boolean;
    /**
     * Unique ID for the item being sold. Not present if item is being requested by contract rather than sold with contract
     * @type {number}
     * @memberof GetContractsPublicItemsContractId200Ok
     */
    itemId?: number;
    /**
     * Material Efficiency Level of the blueprint
     * @type {number}
     * @memberof GetContractsPublicItemsContractId200Ok
     */
    materialEfficiency?: number;
    /**
     * Number of items in the stack
     * @type {number}
     * @memberof GetContractsPublicItemsContractId200Ok
     */
    quantity: number;
    /**
     * Unique ID for the item, used by the contract system
     * @type {number}
     * @memberof GetContractsPublicItemsContractId200Ok
     */
    recordId: number;
    /**
     * Number of runs remaining if the blueprint is a copy, -1 if it is an original
     * @type {number}
     * @memberof GetContractsPublicItemsContractId200Ok
     */
    runs?: number;
    /**
     * Time Efficiency Level of the blueprint
     * @type {number}
     * @memberof GetContractsPublicItemsContractId200Ok
     */
    timeEfficiency?: number;
    /**
     * Type ID for item
     * @type {number}
     * @memberof GetContractsPublicItemsContractId200Ok
     */
    typeId: number;
}

/**
 * Forbidden
 * @export
 * @interface GetContractsPublicItemsContractIdForbidden
 */
export interface GetContractsPublicItemsContractIdForbidden {
    /**
     * Forbidden message
     * @type {string}
     * @memberof GetContractsPublicItemsContractIdForbidden
     */
    error?: string;
}

/**
 * Not found
 * @export
 * @interface GetContractsPublicItemsContractIdNotFound
 */
export interface GetContractsPublicItemsContractIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetContractsPublicItemsContractIdNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetContractsPublicRegionId200Ok
 */
export interface GetContractsPublicRegionId200Ok {
    /**
     * Buyout price (for Auctions only)
     * @type {number}
     * @memberof GetContractsPublicRegionId200Ok
     */
    buyout?: number;
    /**
     * Collateral price (for Couriers only)
     * @type {number}
     * @memberof GetContractsPublicRegionId200Ok
     */
    collateral?: number;
    /**
     * contract_id integer
     * @type {number}
     * @memberof GetContractsPublicRegionId200Ok
     */
    contractId: number;
    /**
     * Expiration date of the contract
     * @type {Date}
     * @memberof GetContractsPublicRegionId200Ok
     */
    dateExpired: Date;
    /**
     * Сreation date of the contract
     * @type {Date}
     * @memberof GetContractsPublicRegionId200Ok
     */
    dateIssued: Date;
    /**
     * Number of days to perform the contract
     * @type {number}
     * @memberof GetContractsPublicRegionId200Ok
     */
    daysToComplete?: number;
    /**
     * End location ID (for Couriers contract)
     * @type {number}
     * @memberof GetContractsPublicRegionId200Ok
     */
    endLocationId?: number;
    /**
     * true if the contract was issued on behalf of the issuer's corporation
     * @type {boolean}
     * @memberof GetContractsPublicRegionId200Ok
     */
    forCorporation?: boolean;
    /**
     * Character's corporation ID for the issuer
     * @type {number}
     * @memberof GetContractsPublicRegionId200Ok
     */
    issuerCorporationId: number;
    /**
     * Character ID for the issuer
     * @type {number}
     * @memberof GetContractsPublicRegionId200Ok
     */
    issuerId: number;
    /**
     * Price of contract (for ItemsExchange and Auctions)
     * @type {number}
     * @memberof GetContractsPublicRegionId200Ok
     */
    price?: number;
    /**
     * Remuneration for contract (for Couriers only)
     * @type {number}
     * @memberof GetContractsPublicRegionId200Ok
     */
    reward?: number;
    /**
     * Start location ID (for Couriers contract)
     * @type {number}
     * @memberof GetContractsPublicRegionId200Ok
     */
    startLocationId?: number;
    /**
     * Title of the contract
     * @type {string}
     * @memberof GetContractsPublicRegionId200Ok
     */
    title?: string;
    /**
     * Type of the contract
     * @type {string}
     * @memberof GetContractsPublicRegionId200Ok
     */
    type: GetContractsPublicRegionId200Ok.TypeEnum;
    /**
     * Volume of items in the contract
     * @type {number}
     * @memberof GetContractsPublicRegionId200Ok
     */
    volume?: number;
}

/**
 * @export
 * @namespace GetContractsPublicRegionId200Ok
 */
export namespace GetContractsPublicRegionId200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Unknown = <any> 'unknown',
        ItemExchange = <any> 'item_exchange',
        Auction = <any> 'auction',
        Courier = <any> 'courier',
        Loan = <any> 'loan'
    }
}

/**
 * Not found
 * @export
 * @interface GetContractsPublicRegionIdNotFound
 */
export interface GetContractsPublicRegionIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetContractsPublicRegionIdNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationCorporationIdMiningExtractions200Ok
 */
export interface GetCorporationCorporationIdMiningExtractions200Ok {
    /**
     * The time at which the chunk being extracted will arrive and can be fractured by the moon mining drill. 
     * @type {Date}
     * @memberof GetCorporationCorporationIdMiningExtractions200Ok
     */
    chunkArrivalTime: Date;
    /**
     * The time at which the current extraction was initiated. 
     * @type {Date}
     * @memberof GetCorporationCorporationIdMiningExtractions200Ok
     */
    extractionStartTime: Date;
    /**
     * moon_id integer
     * @type {number}
     * @memberof GetCorporationCorporationIdMiningExtractions200Ok
     */
    moonId: number;
    /**
     * The time at which the chunk being extracted will naturally fracture if it is not first fractured by the moon mining drill. 
     * @type {Date}
     * @memberof GetCorporationCorporationIdMiningExtractions200Ok
     */
    naturalDecayTime: Date;
    /**
     * structure_id integer
     * @type {number}
     * @memberof GetCorporationCorporationIdMiningExtractions200Ok
     */
    structureId: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationCorporationIdMiningObservers200Ok
 */
export interface GetCorporationCorporationIdMiningObservers200Ok {
    /**
     * last_updated string
     * @type {string}
     * @memberof GetCorporationCorporationIdMiningObservers200Ok
     */
    lastUpdated: string;
    /**
     * The entity that was observing the asteroid field when it was mined. 
     * @type {number}
     * @memberof GetCorporationCorporationIdMiningObservers200Ok
     */
    observerId: number;
    /**
     * The category of the observing entity
     * @type {string}
     * @memberof GetCorporationCorporationIdMiningObservers200Ok
     */
    observerType: GetCorporationCorporationIdMiningObservers200Ok.ObserverTypeEnum;
}

/**
 * @export
 * @namespace GetCorporationCorporationIdMiningObservers200Ok
 */
export namespace GetCorporationCorporationIdMiningObservers200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum ObserverTypeEnum {
        Structure = <any> 'structure'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationCorporationIdMiningObserversObserverId200Ok
 */
export interface GetCorporationCorporationIdMiningObserversObserverId200Ok {
    /**
     * The character that did the mining 
     * @type {number}
     * @memberof GetCorporationCorporationIdMiningObserversObserverId200Ok
     */
    characterId: number;
    /**
     * last_updated string
     * @type {string}
     * @memberof GetCorporationCorporationIdMiningObserversObserverId200Ok
     */
    lastUpdated: string;
    /**
     * quantity integer
     * @type {number}
     * @memberof GetCorporationCorporationIdMiningObserversObserverId200Ok
     */
    quantity: number;
    /**
     * The corporation id of the character at the time data was recorded. 
     * @type {number}
     * @memberof GetCorporationCorporationIdMiningObserversObserverId200Ok
     */
    recordedCorporationId: number;
    /**
     * type_id integer
     * @type {number}
     * @memberof GetCorporationCorporationIdMiningObserversObserverId200Ok
     */
    typeId: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdAlliancehistory200Ok
 */
export interface GetCorporationsCorporationIdAlliancehistory200Ok {
    /**
     * alliance_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdAlliancehistory200Ok
     */
    allianceId?: number;
    /**
     * True if the alliance has been closed
     * @type {boolean}
     * @memberof GetCorporationsCorporationIdAlliancehistory200Ok
     */
    isDeleted?: boolean;
    /**
     * An incrementing ID that can be used to canonically establish order of records in cases where dates may be ambiguous
     * @type {number}
     * @memberof GetCorporationsCorporationIdAlliancehistory200Ok
     */
    recordId: number;
    /**
     * start_date string
     * @type {Date}
     * @memberof GetCorporationsCorporationIdAlliancehistory200Ok
     */
    startDate: Date;
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdAssets200Ok
 */
export interface GetCorporationsCorporationIdAssets200Ok {
    /**
     * is_blueprint_copy boolean
     * @type {boolean}
     * @memberof GetCorporationsCorporationIdAssets200Ok
     */
    isBlueprintCopy?: boolean;
    /**
     * is_singleton boolean
     * @type {boolean}
     * @memberof GetCorporationsCorporationIdAssets200Ok
     */
    isSingleton: boolean;
    /**
     * item_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdAssets200Ok
     */
    itemId: number;
    /**
     * location_flag string
     * @type {string}
     * @memberof GetCorporationsCorporationIdAssets200Ok
     */
    locationFlag: GetCorporationsCorporationIdAssets200Ok.LocationFlagEnum;
    /**
     * location_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdAssets200Ok
     */
    locationId: number;
    /**
     * location_type string
     * @type {string}
     * @memberof GetCorporationsCorporationIdAssets200Ok
     */
    locationType: GetCorporationsCorporationIdAssets200Ok.LocationTypeEnum;
    /**
     * quantity integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdAssets200Ok
     */
    quantity: number;
    /**
     * type_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdAssets200Ok
     */
    typeId: number;
}

/**
 * @export
 * @namespace GetCorporationsCorporationIdAssets200Ok
 */
export namespace GetCorporationsCorporationIdAssets200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum LocationFlagEnum {
        AssetSafety = <any> 'AssetSafety',
        AutoFit = <any> 'AutoFit',
        Bonus = <any> 'Bonus',
        Booster = <any> 'Booster',
        BoosterBay = <any> 'BoosterBay',
        Capsule = <any> 'Capsule',
        Cargo = <any> 'Cargo',
        CorpDeliveries = <any> 'CorpDeliveries',
        CorpSAG1 = <any> 'CorpSAG1',
        CorpSAG2 = <any> 'CorpSAG2',
        CorpSAG3 = <any> 'CorpSAG3',
        CorpSAG4 = <any> 'CorpSAG4',
        CorpSAG5 = <any> 'CorpSAG5',
        CorpSAG6 = <any> 'CorpSAG6',
        CorpSAG7 = <any> 'CorpSAG7',
        CrateLoot = <any> 'CrateLoot',
        Deliveries = <any> 'Deliveries',
        DroneBay = <any> 'DroneBay',
        DustBattle = <any> 'DustBattle',
        DustDatabank = <any> 'DustDatabank',
        FighterBay = <any> 'FighterBay',
        FighterTube0 = <any> 'FighterTube0',
        FighterTube1 = <any> 'FighterTube1',
        FighterTube2 = <any> 'FighterTube2',
        FighterTube3 = <any> 'FighterTube3',
        FighterTube4 = <any> 'FighterTube4',
        FleetHangar = <any> 'FleetHangar',
        FrigateEscapeBay = <any> 'FrigateEscapeBay',
        Hangar = <any> 'Hangar',
        HangarAll = <any> 'HangarAll',
        HiSlot0 = <any> 'HiSlot0',
        HiSlot1 = <any> 'HiSlot1',
        HiSlot2 = <any> 'HiSlot2',
        HiSlot3 = <any> 'HiSlot3',
        HiSlot4 = <any> 'HiSlot4',
        HiSlot5 = <any> 'HiSlot5',
        HiSlot6 = <any> 'HiSlot6',
        HiSlot7 = <any> 'HiSlot7',
        HiddenModifiers = <any> 'HiddenModifiers',
        Implant = <any> 'Implant',
        Impounded = <any> 'Impounded',
        JunkyardReprocessed = <any> 'JunkyardReprocessed',
        JunkyardTrashed = <any> 'JunkyardTrashed',
        LoSlot0 = <any> 'LoSlot0',
        LoSlot1 = <any> 'LoSlot1',
        LoSlot2 = <any> 'LoSlot2',
        LoSlot3 = <any> 'LoSlot3',
        LoSlot4 = <any> 'LoSlot4',
        LoSlot5 = <any> 'LoSlot5',
        LoSlot6 = <any> 'LoSlot6',
        LoSlot7 = <any> 'LoSlot7',
        Locked = <any> 'Locked',
        MedSlot0 = <any> 'MedSlot0',
        MedSlot1 = <any> 'MedSlot1',
        MedSlot2 = <any> 'MedSlot2',
        MedSlot3 = <any> 'MedSlot3',
        MedSlot4 = <any> 'MedSlot4',
        MedSlot5 = <any> 'MedSlot5',
        MedSlot6 = <any> 'MedSlot6',
        MedSlot7 = <any> 'MedSlot7',
        OfficeFolder = <any> 'OfficeFolder',
        Pilot = <any> 'Pilot',
        PlanetSurface = <any> 'PlanetSurface',
        QuafeBay = <any> 'QuafeBay',
        QuantumCoreRoom = <any> 'QuantumCoreRoom',
        Reward = <any> 'Reward',
        RigSlot0 = <any> 'RigSlot0',
        RigSlot1 = <any> 'RigSlot1',
        RigSlot2 = <any> 'RigSlot2',
        RigSlot3 = <any> 'RigSlot3',
        RigSlot4 = <any> 'RigSlot4',
        RigSlot5 = <any> 'RigSlot5',
        RigSlot6 = <any> 'RigSlot6',
        RigSlot7 = <any> 'RigSlot7',
        SecondaryStorage = <any> 'SecondaryStorage',
        ServiceSlot0 = <any> 'ServiceSlot0',
        ServiceSlot1 = <any> 'ServiceSlot1',
        ServiceSlot2 = <any> 'ServiceSlot2',
        ServiceSlot3 = <any> 'ServiceSlot3',
        ServiceSlot4 = <any> 'ServiceSlot4',
        ServiceSlot5 = <any> 'ServiceSlot5',
        ServiceSlot6 = <any> 'ServiceSlot6',
        ServiceSlot7 = <any> 'ServiceSlot7',
        ShipHangar = <any> 'ShipHangar',
        ShipOffline = <any> 'ShipOffline',
        Skill = <any> 'Skill',
        SkillInTraining = <any> 'SkillInTraining',
        SpecializedAmmoHold = <any> 'SpecializedAmmoHold',
        SpecializedAsteroidHold = <any> 'SpecializedAsteroidHold',
        SpecializedCommandCenterHold = <any> 'SpecializedCommandCenterHold',
        SpecializedFuelBay = <any> 'SpecializedFuelBay',
        SpecializedGasHold = <any> 'SpecializedGasHold',
        SpecializedIceHold = <any> 'SpecializedIceHold',
        SpecializedIndustrialShipHold = <any> 'SpecializedIndustrialShipHold',
        SpecializedLargeShipHold = <any> 'SpecializedLargeShipHold',
        SpecializedMaterialBay = <any> 'SpecializedMaterialBay',
        SpecializedMediumShipHold = <any> 'SpecializedMediumShipHold',
        SpecializedMineralHold = <any> 'SpecializedMineralHold',
        SpecializedOreHold = <any> 'SpecializedOreHold',
        SpecializedPlanetaryCommoditiesHold = <any> 'SpecializedPlanetaryCommoditiesHold',
        SpecializedSalvageHold = <any> 'SpecializedSalvageHold',
        SpecializedShipHold = <any> 'SpecializedShipHold',
        SpecializedSmallShipHold = <any> 'SpecializedSmallShipHold',
        StructureActive = <any> 'StructureActive',
        StructureFuel = <any> 'StructureFuel',
        StructureInactive = <any> 'StructureInactive',
        StructureOffline = <any> 'StructureOffline',
        SubSystemBay = <any> 'SubSystemBay',
        SubSystemSlot0 = <any> 'SubSystemSlot0',
        SubSystemSlot1 = <any> 'SubSystemSlot1',
        SubSystemSlot2 = <any> 'SubSystemSlot2',
        SubSystemSlot3 = <any> 'SubSystemSlot3',
        SubSystemSlot4 = <any> 'SubSystemSlot4',
        SubSystemSlot5 = <any> 'SubSystemSlot5',
        SubSystemSlot6 = <any> 'SubSystemSlot6',
        SubSystemSlot7 = <any> 'SubSystemSlot7',
        Unlocked = <any> 'Unlocked',
        Wallet = <any> 'Wallet',
        Wardrobe = <any> 'Wardrobe'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum LocationTypeEnum {
        Station = <any> 'station',
        SolarSystem = <any> 'solar_system',
        Item = <any> 'item',
        Other = <any> 'other'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdBlueprints200Ok
 */
export interface GetCorporationsCorporationIdBlueprints200Ok {
    /**
     * Unique ID for this item.
     * @type {number}
     * @memberof GetCorporationsCorporationIdBlueprints200Ok
     */
    itemId: number;
    /**
     * Type of the location_id
     * @type {string}
     * @memberof GetCorporationsCorporationIdBlueprints200Ok
     */
    locationFlag: GetCorporationsCorporationIdBlueprints200Ok.LocationFlagEnum;
    /**
     * References a station, a ship or an item_id if this blueprint is located within a container.
     * @type {number}
     * @memberof GetCorporationsCorporationIdBlueprints200Ok
     */
    locationId: number;
    /**
     * Material Efficiency Level of the blueprint.
     * @type {number}
     * @memberof GetCorporationsCorporationIdBlueprints200Ok
     */
    materialEfficiency: number;
    /**
     * A range of numbers with a minimum of -2 and no maximum value where -1 is an original and -2 is a copy. It can be a positive integer if it is a stack of blueprint originals fresh from the market (e.g. no activities performed on them yet).
     * @type {number}
     * @memberof GetCorporationsCorporationIdBlueprints200Ok
     */
    quantity: number;
    /**
     * Number of runs remaining if the blueprint is a copy, -1 if it is an original.
     * @type {number}
     * @memberof GetCorporationsCorporationIdBlueprints200Ok
     */
    runs: number;
    /**
     * Time Efficiency Level of the blueprint.
     * @type {number}
     * @memberof GetCorporationsCorporationIdBlueprints200Ok
     */
    timeEfficiency: number;
    /**
     * type_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdBlueprints200Ok
     */
    typeId: number;
}

/**
 * @export
 * @namespace GetCorporationsCorporationIdBlueprints200Ok
 */
export namespace GetCorporationsCorporationIdBlueprints200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum LocationFlagEnum {
        AssetSafety = <any> 'AssetSafety',
        AutoFit = <any> 'AutoFit',
        Bonus = <any> 'Bonus',
        Booster = <any> 'Booster',
        BoosterBay = <any> 'BoosterBay',
        Capsule = <any> 'Capsule',
        Cargo = <any> 'Cargo',
        CorpDeliveries = <any> 'CorpDeliveries',
        CorpSAG1 = <any> 'CorpSAG1',
        CorpSAG2 = <any> 'CorpSAG2',
        CorpSAG3 = <any> 'CorpSAG3',
        CorpSAG4 = <any> 'CorpSAG4',
        CorpSAG5 = <any> 'CorpSAG5',
        CorpSAG6 = <any> 'CorpSAG6',
        CorpSAG7 = <any> 'CorpSAG7',
        CrateLoot = <any> 'CrateLoot',
        Deliveries = <any> 'Deliveries',
        DroneBay = <any> 'DroneBay',
        DustBattle = <any> 'DustBattle',
        DustDatabank = <any> 'DustDatabank',
        FighterBay = <any> 'FighterBay',
        FighterTube0 = <any> 'FighterTube0',
        FighterTube1 = <any> 'FighterTube1',
        FighterTube2 = <any> 'FighterTube2',
        FighterTube3 = <any> 'FighterTube3',
        FighterTube4 = <any> 'FighterTube4',
        FleetHangar = <any> 'FleetHangar',
        FrigateEscapeBay = <any> 'FrigateEscapeBay',
        Hangar = <any> 'Hangar',
        HangarAll = <any> 'HangarAll',
        HiSlot0 = <any> 'HiSlot0',
        HiSlot1 = <any> 'HiSlot1',
        HiSlot2 = <any> 'HiSlot2',
        HiSlot3 = <any> 'HiSlot3',
        HiSlot4 = <any> 'HiSlot4',
        HiSlot5 = <any> 'HiSlot5',
        HiSlot6 = <any> 'HiSlot6',
        HiSlot7 = <any> 'HiSlot7',
        HiddenModifiers = <any> 'HiddenModifiers',
        Implant = <any> 'Implant',
        Impounded = <any> 'Impounded',
        JunkyardReprocessed = <any> 'JunkyardReprocessed',
        JunkyardTrashed = <any> 'JunkyardTrashed',
        LoSlot0 = <any> 'LoSlot0',
        LoSlot1 = <any> 'LoSlot1',
        LoSlot2 = <any> 'LoSlot2',
        LoSlot3 = <any> 'LoSlot3',
        LoSlot4 = <any> 'LoSlot4',
        LoSlot5 = <any> 'LoSlot5',
        LoSlot6 = <any> 'LoSlot6',
        LoSlot7 = <any> 'LoSlot7',
        Locked = <any> 'Locked',
        MedSlot0 = <any> 'MedSlot0',
        MedSlot1 = <any> 'MedSlot1',
        MedSlot2 = <any> 'MedSlot2',
        MedSlot3 = <any> 'MedSlot3',
        MedSlot4 = <any> 'MedSlot4',
        MedSlot5 = <any> 'MedSlot5',
        MedSlot6 = <any> 'MedSlot6',
        MedSlot7 = <any> 'MedSlot7',
        OfficeFolder = <any> 'OfficeFolder',
        Pilot = <any> 'Pilot',
        PlanetSurface = <any> 'PlanetSurface',
        QuafeBay = <any> 'QuafeBay',
        QuantumCoreRoom = <any> 'QuantumCoreRoom',
        Reward = <any> 'Reward',
        RigSlot0 = <any> 'RigSlot0',
        RigSlot1 = <any> 'RigSlot1',
        RigSlot2 = <any> 'RigSlot2',
        RigSlot3 = <any> 'RigSlot3',
        RigSlot4 = <any> 'RigSlot4',
        RigSlot5 = <any> 'RigSlot5',
        RigSlot6 = <any> 'RigSlot6',
        RigSlot7 = <any> 'RigSlot7',
        SecondaryStorage = <any> 'SecondaryStorage',
        ServiceSlot0 = <any> 'ServiceSlot0',
        ServiceSlot1 = <any> 'ServiceSlot1',
        ServiceSlot2 = <any> 'ServiceSlot2',
        ServiceSlot3 = <any> 'ServiceSlot3',
        ServiceSlot4 = <any> 'ServiceSlot4',
        ServiceSlot5 = <any> 'ServiceSlot5',
        ServiceSlot6 = <any> 'ServiceSlot6',
        ServiceSlot7 = <any> 'ServiceSlot7',
        ShipHangar = <any> 'ShipHangar',
        ShipOffline = <any> 'ShipOffline',
        Skill = <any> 'Skill',
        SkillInTraining = <any> 'SkillInTraining',
        SpecializedAmmoHold = <any> 'SpecializedAmmoHold',
        SpecializedCommandCenterHold = <any> 'SpecializedCommandCenterHold',
        SpecializedFuelBay = <any> 'SpecializedFuelBay',
        SpecializedGasHold = <any> 'SpecializedGasHold',
        SpecializedIndustrialShipHold = <any> 'SpecializedIndustrialShipHold',
        SpecializedLargeShipHold = <any> 'SpecializedLargeShipHold',
        SpecializedMaterialBay = <any> 'SpecializedMaterialBay',
        SpecializedMediumShipHold = <any> 'SpecializedMediumShipHold',
        SpecializedMineralHold = <any> 'SpecializedMineralHold',
        SpecializedOreHold = <any> 'SpecializedOreHold',
        SpecializedPlanetaryCommoditiesHold = <any> 'SpecializedPlanetaryCommoditiesHold',
        SpecializedSalvageHold = <any> 'SpecializedSalvageHold',
        SpecializedShipHold = <any> 'SpecializedShipHold',
        SpecializedSmallShipHold = <any> 'SpecializedSmallShipHold',
        StructureActive = <any> 'StructureActive',
        StructureFuel = <any> 'StructureFuel',
        StructureInactive = <any> 'StructureInactive',
        StructureOffline = <any> 'StructureOffline',
        SubSystemBay = <any> 'SubSystemBay',
        SubSystemSlot0 = <any> 'SubSystemSlot0',
        SubSystemSlot1 = <any> 'SubSystemSlot1',
        SubSystemSlot2 = <any> 'SubSystemSlot2',
        SubSystemSlot3 = <any> 'SubSystemSlot3',
        SubSystemSlot4 = <any> 'SubSystemSlot4',
        SubSystemSlot5 = <any> 'SubSystemSlot5',
        SubSystemSlot6 = <any> 'SubSystemSlot6',
        SubSystemSlot7 = <any> 'SubSystemSlot7',
        Unlocked = <any> 'Unlocked',
        Wallet = <any> 'Wallet',
        Wardrobe = <any> 'Wardrobe'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdBookmarks200Ok
 */
export interface GetCorporationsCorporationIdBookmarks200Ok {
    /**
     * bookmark_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdBookmarks200Ok
     */
    bookmarkId: number;
    /**
     * 
     * @type {GetCorporationsCorporationIdBookmarksCoordinates}
     * @memberof GetCorporationsCorporationIdBookmarks200Ok
     */
    coordinates?: GetCorporationsCorporationIdBookmarksCoordinates;
    /**
     * created string
     * @type {Date}
     * @memberof GetCorporationsCorporationIdBookmarks200Ok
     */
    created: Date;
    /**
     * creator_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdBookmarks200Ok
     */
    creatorId: number;
    /**
     * folder_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdBookmarks200Ok
     */
    folderId?: number;
    /**
     * 
     * @type {GetCorporationsCorporationIdBookmarksItem}
     * @memberof GetCorporationsCorporationIdBookmarks200Ok
     */
    item?: GetCorporationsCorporationIdBookmarksItem;
    /**
     * label string
     * @type {string}
     * @memberof GetCorporationsCorporationIdBookmarks200Ok
     */
    label: string;
    /**
     * location_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdBookmarks200Ok
     */
    locationId: number;
    /**
     * notes string
     * @type {string}
     * @memberof GetCorporationsCorporationIdBookmarks200Ok
     */
    notes: string;
}

/**
 * Optional object that is returned if a bookmark was made on a planet or a random location in space.
 * @export
 * @interface GetCorporationsCorporationIdBookmarksCoordinates
 */
export interface GetCorporationsCorporationIdBookmarksCoordinates {
    /**
     * x number
     * @type {number}
     * @memberof GetCorporationsCorporationIdBookmarksCoordinates
     */
    x: number;
    /**
     * y number
     * @type {number}
     * @memberof GetCorporationsCorporationIdBookmarksCoordinates
     */
    y: number;
    /**
     * z number
     * @type {number}
     * @memberof GetCorporationsCorporationIdBookmarksCoordinates
     */
    z: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdBookmarksFolders200Ok
 */
export interface GetCorporationsCorporationIdBookmarksFolders200Ok {
    /**
     * creator_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdBookmarksFolders200Ok
     */
    creatorId?: number;
    /**
     * folder_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdBookmarksFolders200Ok
     */
    folderId: number;
    /**
     * name string
     * @type {string}
     * @memberof GetCorporationsCorporationIdBookmarksFolders200Ok
     */
    name: string;
}

/**
 * Optional object that is returned if a bookmark was made on a particular item.
 * @export
 * @interface GetCorporationsCorporationIdBookmarksItem
 */
export interface GetCorporationsCorporationIdBookmarksItem {
    /**
     * item_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdBookmarksItem
     */
    itemId: number;
    /**
     * type_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdBookmarksItem
     */
    typeId: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdContacts200Ok
 */
export interface GetCorporationsCorporationIdContacts200Ok {
    /**
     * contact_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdContacts200Ok
     */
    contactId: number;
    /**
     * contact_type string
     * @type {string}
     * @memberof GetCorporationsCorporationIdContacts200Ok
     */
    contactType: GetCorporationsCorporationIdContacts200Ok.ContactTypeEnum;
    /**
     * Whether this contact is being watched
     * @type {boolean}
     * @memberof GetCorporationsCorporationIdContacts200Ok
     */
    isWatched?: boolean;
    /**
     * label_ids array
     * @type {Array<number>}
     * @memberof GetCorporationsCorporationIdContacts200Ok
     */
    labelIds?: Array<number>;
    /**
     * Standing of the contact
     * @type {number}
     * @memberof GetCorporationsCorporationIdContacts200Ok
     */
    standing: number;
}

/**
 * @export
 * @namespace GetCorporationsCorporationIdContacts200Ok
 */
export namespace GetCorporationsCorporationIdContacts200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum ContactTypeEnum {
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        Alliance = <any> 'alliance',
        Faction = <any> 'faction'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdContactsLabels200Ok
 */
export interface GetCorporationsCorporationIdContactsLabels200Ok {
    /**
     * label_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdContactsLabels200Ok
     */
    labelId: number;
    /**
     * label_name string
     * @type {string}
     * @memberof GetCorporationsCorporationIdContactsLabels200Ok
     */
    labelName: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdContainersLogs200Ok
 */
export interface GetCorporationsCorporationIdContainersLogs200Ok {
    /**
     * action string
     * @type {string}
     * @memberof GetCorporationsCorporationIdContainersLogs200Ok
     */
    action: GetCorporationsCorporationIdContainersLogs200Ok.ActionEnum;
    /**
     * ID of the character who performed the action.
     * @type {number}
     * @memberof GetCorporationsCorporationIdContainersLogs200Ok
     */
    characterId: number;
    /**
     * ID of the container
     * @type {number}
     * @memberof GetCorporationsCorporationIdContainersLogs200Ok
     */
    containerId: number;
    /**
     * Type ID of the container
     * @type {number}
     * @memberof GetCorporationsCorporationIdContainersLogs200Ok
     */
    containerTypeId: number;
    /**
     * location_flag string
     * @type {string}
     * @memberof GetCorporationsCorporationIdContainersLogs200Ok
     */
    locationFlag: GetCorporationsCorporationIdContainersLogs200Ok.LocationFlagEnum;
    /**
     * location_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdContainersLogs200Ok
     */
    locationId: number;
    /**
     * Timestamp when this log was created
     * @type {Date}
     * @memberof GetCorporationsCorporationIdContainersLogs200Ok
     */
    loggedAt: Date;
    /**
     * new_config_bitmask integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdContainersLogs200Ok
     */
    newConfigBitmask?: number;
    /**
     * old_config_bitmask integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdContainersLogs200Ok
     */
    oldConfigBitmask?: number;
    /**
     * Type of password set if action is of type SetPassword or EnterPassword
     * @type {string}
     * @memberof GetCorporationsCorporationIdContainersLogs200Ok
     */
    passwordType?: GetCorporationsCorporationIdContainersLogs200Ok.PasswordTypeEnum;
    /**
     * Quantity of the item being acted upon
     * @type {number}
     * @memberof GetCorporationsCorporationIdContainersLogs200Ok
     */
    quantity?: number;
    /**
     * Type ID of the item being acted upon
     * @type {number}
     * @memberof GetCorporationsCorporationIdContainersLogs200Ok
     */
    typeId?: number;
}

/**
 * @export
 * @namespace GetCorporationsCorporationIdContainersLogs200Ok
 */
export namespace GetCorporationsCorporationIdContainersLogs200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum ActionEnum {
        Add = <any> 'add',
        Assemble = <any> 'assemble',
        Configure = <any> 'configure',
        EnterPassword = <any> 'enter_password',
        Lock = <any> 'lock',
        Move = <any> 'move',
        Repackage = <any> 'repackage',
        SetName = <any> 'set_name',
        SetPassword = <any> 'set_password',
        Unlock = <any> 'unlock'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum LocationFlagEnum {
        AssetSafety = <any> 'AssetSafety',
        AutoFit = <any> 'AutoFit',
        Bonus = <any> 'Bonus',
        Booster = <any> 'Booster',
        BoosterBay = <any> 'BoosterBay',
        Capsule = <any> 'Capsule',
        Cargo = <any> 'Cargo',
        CorpDeliveries = <any> 'CorpDeliveries',
        CorpSAG1 = <any> 'CorpSAG1',
        CorpSAG2 = <any> 'CorpSAG2',
        CorpSAG3 = <any> 'CorpSAG3',
        CorpSAG4 = <any> 'CorpSAG4',
        CorpSAG5 = <any> 'CorpSAG5',
        CorpSAG6 = <any> 'CorpSAG6',
        CorpSAG7 = <any> 'CorpSAG7',
        CrateLoot = <any> 'CrateLoot',
        Deliveries = <any> 'Deliveries',
        DroneBay = <any> 'DroneBay',
        DustBattle = <any> 'DustBattle',
        DustDatabank = <any> 'DustDatabank',
        FighterBay = <any> 'FighterBay',
        FighterTube0 = <any> 'FighterTube0',
        FighterTube1 = <any> 'FighterTube1',
        FighterTube2 = <any> 'FighterTube2',
        FighterTube3 = <any> 'FighterTube3',
        FighterTube4 = <any> 'FighterTube4',
        FleetHangar = <any> 'FleetHangar',
        FrigateEscapeBay = <any> 'FrigateEscapeBay',
        Hangar = <any> 'Hangar',
        HangarAll = <any> 'HangarAll',
        HiSlot0 = <any> 'HiSlot0',
        HiSlot1 = <any> 'HiSlot1',
        HiSlot2 = <any> 'HiSlot2',
        HiSlot3 = <any> 'HiSlot3',
        HiSlot4 = <any> 'HiSlot4',
        HiSlot5 = <any> 'HiSlot5',
        HiSlot6 = <any> 'HiSlot6',
        HiSlot7 = <any> 'HiSlot7',
        HiddenModifiers = <any> 'HiddenModifiers',
        Implant = <any> 'Implant',
        Impounded = <any> 'Impounded',
        JunkyardReprocessed = <any> 'JunkyardReprocessed',
        JunkyardTrashed = <any> 'JunkyardTrashed',
        LoSlot0 = <any> 'LoSlot0',
        LoSlot1 = <any> 'LoSlot1',
        LoSlot2 = <any> 'LoSlot2',
        LoSlot3 = <any> 'LoSlot3',
        LoSlot4 = <any> 'LoSlot4',
        LoSlot5 = <any> 'LoSlot5',
        LoSlot6 = <any> 'LoSlot6',
        LoSlot7 = <any> 'LoSlot7',
        Locked = <any> 'Locked',
        MedSlot0 = <any> 'MedSlot0',
        MedSlot1 = <any> 'MedSlot1',
        MedSlot2 = <any> 'MedSlot2',
        MedSlot3 = <any> 'MedSlot3',
        MedSlot4 = <any> 'MedSlot4',
        MedSlot5 = <any> 'MedSlot5',
        MedSlot6 = <any> 'MedSlot6',
        MedSlot7 = <any> 'MedSlot7',
        OfficeFolder = <any> 'OfficeFolder',
        Pilot = <any> 'Pilot',
        PlanetSurface = <any> 'PlanetSurface',
        QuafeBay = <any> 'QuafeBay',
        QuantumCoreRoom = <any> 'QuantumCoreRoom',
        Reward = <any> 'Reward',
        RigSlot0 = <any> 'RigSlot0',
        RigSlot1 = <any> 'RigSlot1',
        RigSlot2 = <any> 'RigSlot2',
        RigSlot3 = <any> 'RigSlot3',
        RigSlot4 = <any> 'RigSlot4',
        RigSlot5 = <any> 'RigSlot5',
        RigSlot6 = <any> 'RigSlot6',
        RigSlot7 = <any> 'RigSlot7',
        SecondaryStorage = <any> 'SecondaryStorage',
        ServiceSlot0 = <any> 'ServiceSlot0',
        ServiceSlot1 = <any> 'ServiceSlot1',
        ServiceSlot2 = <any> 'ServiceSlot2',
        ServiceSlot3 = <any> 'ServiceSlot3',
        ServiceSlot4 = <any> 'ServiceSlot4',
        ServiceSlot5 = <any> 'ServiceSlot5',
        ServiceSlot6 = <any> 'ServiceSlot6',
        ServiceSlot7 = <any> 'ServiceSlot7',
        ShipHangar = <any> 'ShipHangar',
        ShipOffline = <any> 'ShipOffline',
        Skill = <any> 'Skill',
        SkillInTraining = <any> 'SkillInTraining',
        SpecializedAmmoHold = <any> 'SpecializedAmmoHold',
        SpecializedCommandCenterHold = <any> 'SpecializedCommandCenterHold',
        SpecializedFuelBay = <any> 'SpecializedFuelBay',
        SpecializedGasHold = <any> 'SpecializedGasHold',
        SpecializedIndustrialShipHold = <any> 'SpecializedIndustrialShipHold',
        SpecializedLargeShipHold = <any> 'SpecializedLargeShipHold',
        SpecializedMaterialBay = <any> 'SpecializedMaterialBay',
        SpecializedMediumShipHold = <any> 'SpecializedMediumShipHold',
        SpecializedMineralHold = <any> 'SpecializedMineralHold',
        SpecializedOreHold = <any> 'SpecializedOreHold',
        SpecializedPlanetaryCommoditiesHold = <any> 'SpecializedPlanetaryCommoditiesHold',
        SpecializedSalvageHold = <any> 'SpecializedSalvageHold',
        SpecializedShipHold = <any> 'SpecializedShipHold',
        SpecializedSmallShipHold = <any> 'SpecializedSmallShipHold',
        StructureActive = <any> 'StructureActive',
        StructureFuel = <any> 'StructureFuel',
        StructureInactive = <any> 'StructureInactive',
        StructureOffline = <any> 'StructureOffline',
        SubSystemBay = <any> 'SubSystemBay',
        SubSystemSlot0 = <any> 'SubSystemSlot0',
        SubSystemSlot1 = <any> 'SubSystemSlot1',
        SubSystemSlot2 = <any> 'SubSystemSlot2',
        SubSystemSlot3 = <any> 'SubSystemSlot3',
        SubSystemSlot4 = <any> 'SubSystemSlot4',
        SubSystemSlot5 = <any> 'SubSystemSlot5',
        SubSystemSlot6 = <any> 'SubSystemSlot6',
        SubSystemSlot7 = <any> 'SubSystemSlot7',
        Unlocked = <any> 'Unlocked',
        Wallet = <any> 'Wallet',
        Wardrobe = <any> 'Wardrobe'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PasswordTypeEnum {
        Config = <any> 'config',
        General = <any> 'general'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdContracts200Ok
 */
export interface GetCorporationsCorporationIdContracts200Ok {
    /**
     * Who will accept the contract
     * @type {number}
     * @memberof GetCorporationsCorporationIdContracts200Ok
     */
    acceptorId: number;
    /**
     * ID to whom the contract is assigned, can be corporation or character ID
     * @type {number}
     * @memberof GetCorporationsCorporationIdContracts200Ok
     */
    assigneeId: number;
    /**
     * To whom the contract is available
     * @type {string}
     * @memberof GetCorporationsCorporationIdContracts200Ok
     */
    availability: GetCorporationsCorporationIdContracts200Ok.AvailabilityEnum;
    /**
     * Buyout price (for Auctions only)
     * @type {number}
     * @memberof GetCorporationsCorporationIdContracts200Ok
     */
    buyout?: number;
    /**
     * Collateral price (for Couriers only)
     * @type {number}
     * @memberof GetCorporationsCorporationIdContracts200Ok
     */
    collateral?: number;
    /**
     * contract_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdContracts200Ok
     */
    contractId: number;
    /**
     * Date of confirmation of contract
     * @type {Date}
     * @memberof GetCorporationsCorporationIdContracts200Ok
     */
    dateAccepted?: Date;
    /**
     * Date of completed of contract
     * @type {Date}
     * @memberof GetCorporationsCorporationIdContracts200Ok
     */
    dateCompleted?: Date;
    /**
     * Expiration date of the contract
     * @type {Date}
     * @memberof GetCorporationsCorporationIdContracts200Ok
     */
    dateExpired: Date;
    /**
     * Сreation date of the contract
     * @type {Date}
     * @memberof GetCorporationsCorporationIdContracts200Ok
     */
    dateIssued: Date;
    /**
     * Number of days to perform the contract
     * @type {number}
     * @memberof GetCorporationsCorporationIdContracts200Ok
     */
    daysToComplete?: number;
    /**
     * End location ID (for Couriers contract)
     * @type {number}
     * @memberof GetCorporationsCorporationIdContracts200Ok
     */
    endLocationId?: number;
    /**
     * true if the contract was issued on behalf of the issuer's corporation
     * @type {boolean}
     * @memberof GetCorporationsCorporationIdContracts200Ok
     */
    forCorporation: boolean;
    /**
     * Character's corporation ID for the issuer
     * @type {number}
     * @memberof GetCorporationsCorporationIdContracts200Ok
     */
    issuerCorporationId: number;
    /**
     * Character ID for the issuer
     * @type {number}
     * @memberof GetCorporationsCorporationIdContracts200Ok
     */
    issuerId: number;
    /**
     * Price of contract (for ItemsExchange and Auctions)
     * @type {number}
     * @memberof GetCorporationsCorporationIdContracts200Ok
     */
    price?: number;
    /**
     * Remuneration for contract (for Couriers only)
     * @type {number}
     * @memberof GetCorporationsCorporationIdContracts200Ok
     */
    reward?: number;
    /**
     * Start location ID (for Couriers contract)
     * @type {number}
     * @memberof GetCorporationsCorporationIdContracts200Ok
     */
    startLocationId?: number;
    /**
     * Status of the the contract
     * @type {string}
     * @memberof GetCorporationsCorporationIdContracts200Ok
     */
    status: GetCorporationsCorporationIdContracts200Ok.StatusEnum;
    /**
     * Title of the contract
     * @type {string}
     * @memberof GetCorporationsCorporationIdContracts200Ok
     */
    title?: string;
    /**
     * Type of the contract
     * @type {string}
     * @memberof GetCorporationsCorporationIdContracts200Ok
     */
    type: GetCorporationsCorporationIdContracts200Ok.TypeEnum;
    /**
     * Volume of items in the contract
     * @type {number}
     * @memberof GetCorporationsCorporationIdContracts200Ok
     */
    volume?: number;
}

/**
 * @export
 * @namespace GetCorporationsCorporationIdContracts200Ok
 */
export namespace GetCorporationsCorporationIdContracts200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum AvailabilityEnum {
        Public = <any> 'public',
        Personal = <any> 'personal',
        Corporation = <any> 'corporation',
        Alliance = <any> 'alliance'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Outstanding = <any> 'outstanding',
        InProgress = <any> 'in_progress',
        FinishedIssuer = <any> 'finished_issuer',
        FinishedContractor = <any> 'finished_contractor',
        Finished = <any> 'finished',
        Cancelled = <any> 'cancelled',
        Rejected = <any> 'rejected',
        Failed = <any> 'failed',
        Deleted = <any> 'deleted',
        Reversed = <any> 'reversed'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Unknown = <any> 'unknown',
        ItemExchange = <any> 'item_exchange',
        Auction = <any> 'auction',
        Courier = <any> 'courier',
        Loan = <any> 'loan'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdContractsContractIdBids200Ok
 */
export interface GetCorporationsCorporationIdContractsContractIdBids200Ok {
    /**
     * The amount bid, in ISK
     * @type {number}
     * @memberof GetCorporationsCorporationIdContractsContractIdBids200Ok
     */
    amount: number;
    /**
     * Unique ID for the bid
     * @type {number}
     * @memberof GetCorporationsCorporationIdContractsContractIdBids200Ok
     */
    bidId: number;
    /**
     * Character ID of the bidder
     * @type {number}
     * @memberof GetCorporationsCorporationIdContractsContractIdBids200Ok
     */
    bidderId: number;
    /**
     * Datetime when the bid was placed
     * @type {Date}
     * @memberof GetCorporationsCorporationIdContractsContractIdBids200Ok
     */
    dateBid: Date;
}

/**
 * Not found
 * @export
 * @interface GetCorporationsCorporationIdContractsContractIdBidsNotFound
 */
export interface GetCorporationsCorporationIdContractsContractIdBidsNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetCorporationsCorporationIdContractsContractIdBidsNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdContractsContractIdItems200Ok
 */
export interface GetCorporationsCorporationIdContractsContractIdItems200Ok {
    /**
     * true if the contract issuer has submitted this item with the contract, false if the isser is asking for this item in the contract
     * @type {boolean}
     * @memberof GetCorporationsCorporationIdContractsContractIdItems200Ok
     */
    isIncluded: boolean;
    /**
     * is_singleton boolean
     * @type {boolean}
     * @memberof GetCorporationsCorporationIdContractsContractIdItems200Ok
     */
    isSingleton: boolean;
    /**
     * Number of items in the stack
     * @type {number}
     * @memberof GetCorporationsCorporationIdContractsContractIdItems200Ok
     */
    quantity: number;
    /**
     * -1 indicates that the item is a singleton (non-stackable). If the item happens to be a Blueprint, -1 is an Original and -2 is a Blueprint Copy
     * @type {number}
     * @memberof GetCorporationsCorporationIdContractsContractIdItems200Ok
     */
    rawQuantity?: number;
    /**
     * Unique ID for the item
     * @type {number}
     * @memberof GetCorporationsCorporationIdContractsContractIdItems200Ok
     */
    recordId: number;
    /**
     * Type ID for item
     * @type {number}
     * @memberof GetCorporationsCorporationIdContractsContractIdItems200Ok
     */
    typeId: number;
}

/**
 * Error 520
 * @export
 * @interface GetCorporationsCorporationIdContractsContractIdItemsError520
 */
export interface GetCorporationsCorporationIdContractsContractIdItemsError520 {
    /**
     * Error 520 message
     * @type {string}
     * @memberof GetCorporationsCorporationIdContractsContractIdItemsError520
     */
    error?: string;
}

/**
 * Not found
 * @export
 * @interface GetCorporationsCorporationIdContractsContractIdItemsNotFound
 */
export interface GetCorporationsCorporationIdContractsContractIdItemsNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetCorporationsCorporationIdContractsContractIdItemsNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdCustomsOffices200Ok
 */
export interface GetCorporationsCorporationIdCustomsOffices200Ok {
    /**
     * Only present if alliance access is allowed
     * @type {number}
     * @memberof GetCorporationsCorporationIdCustomsOffices200Ok
     */
    allianceTaxRate?: number;
    /**
     * standing_level and any standing related tax rate only present when this is true
     * @type {boolean}
     * @memberof GetCorporationsCorporationIdCustomsOffices200Ok
     */
    allowAccessWithStandings: boolean;
    /**
     * allow_alliance_access boolean
     * @type {boolean}
     * @memberof GetCorporationsCorporationIdCustomsOffices200Ok
     */
    allowAllianceAccess: boolean;
    /**
     * bad_standing_tax_rate number
     * @type {number}
     * @memberof GetCorporationsCorporationIdCustomsOffices200Ok
     */
    badStandingTaxRate?: number;
    /**
     * corporation_tax_rate number
     * @type {number}
     * @memberof GetCorporationsCorporationIdCustomsOffices200Ok
     */
    corporationTaxRate?: number;
    /**
     * Tax rate for entities with excellent level of standing, only present if this level is allowed, same for all other standing related tax rates
     * @type {number}
     * @memberof GetCorporationsCorporationIdCustomsOffices200Ok
     */
    excellentStandingTaxRate?: number;
    /**
     * good_standing_tax_rate number
     * @type {number}
     * @memberof GetCorporationsCorporationIdCustomsOffices200Ok
     */
    goodStandingTaxRate?: number;
    /**
     * neutral_standing_tax_rate number
     * @type {number}
     * @memberof GetCorporationsCorporationIdCustomsOffices200Ok
     */
    neutralStandingTaxRate?: number;
    /**
     * unique ID of this customs office
     * @type {number}
     * @memberof GetCorporationsCorporationIdCustomsOffices200Ok
     */
    officeId: number;
    /**
     * reinforce_exit_end integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdCustomsOffices200Ok
     */
    reinforceExitEnd: number;
    /**
     * Together with reinforce_exit_end, marks a 2-hour period where this customs office could exit reinforcement mode during the day after initial attack
     * @type {number}
     * @memberof GetCorporationsCorporationIdCustomsOffices200Ok
     */
    reinforceExitStart: number;
    /**
     * Access is allowed only for entities with this level of standing or better
     * @type {string}
     * @memberof GetCorporationsCorporationIdCustomsOffices200Ok
     */
    standingLevel?: GetCorporationsCorporationIdCustomsOffices200Ok.StandingLevelEnum;
    /**
     * ID of the solar system this customs office is located in
     * @type {number}
     * @memberof GetCorporationsCorporationIdCustomsOffices200Ok
     */
    systemId: number;
    /**
     * terrible_standing_tax_rate number
     * @type {number}
     * @memberof GetCorporationsCorporationIdCustomsOffices200Ok
     */
    terribleStandingTaxRate?: number;
}

/**
 * @export
 * @namespace GetCorporationsCorporationIdCustomsOffices200Ok
 */
export namespace GetCorporationsCorporationIdCustomsOffices200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum StandingLevelEnum {
        Bad = <any> 'bad',
        Excellent = <any> 'excellent',
        Good = <any> 'good',
        Neutral = <any> 'neutral',
        Terrible = <any> 'terrible'
    }
}

/**
 * hangar object
 * @export
 * @interface GetCorporationsCorporationIdDivisionsHangarHangar
 */
export interface GetCorporationsCorporationIdDivisionsHangarHangar {
    /**
     * division integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdDivisionsHangarHangar
     */
    division?: number;
    /**
     * name string
     * @type {string}
     * @memberof GetCorporationsCorporationIdDivisionsHangarHangar
     */
    name?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdDivisionsOk
 */
export interface GetCorporationsCorporationIdDivisionsOk {
    /**
     * hangar array
     * @type {Array<GetCorporationsCorporationIdDivisionsHangarHangar>}
     * @memberof GetCorporationsCorporationIdDivisionsOk
     */
    hangar?: Array<GetCorporationsCorporationIdDivisionsHangarHangar>;
    /**
     * wallet array
     * @type {Array<GetCorporationsCorporationIdDivisionsWalletWallet>}
     * @memberof GetCorporationsCorporationIdDivisionsOk
     */
    wallet?: Array<GetCorporationsCorporationIdDivisionsWalletWallet>;
}

/**
 * wallet object
 * @export
 * @interface GetCorporationsCorporationIdDivisionsWalletWallet
 */
export interface GetCorporationsCorporationIdDivisionsWalletWallet {
    /**
     * division integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdDivisionsWalletWallet
     */
    division?: number;
    /**
     * name string
     * @type {string}
     * @memberof GetCorporationsCorporationIdDivisionsWalletWallet
     */
    name?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdFacilities200Ok
 */
export interface GetCorporationsCorporationIdFacilities200Ok {
    /**
     * facility_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdFacilities200Ok
     */
    facilityId: number;
    /**
     * system_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdFacilities200Ok
     */
    systemId: number;
    /**
     * type_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdFacilities200Ok
     */
    typeId: number;
}

/**
 * Summary of kills done by the given corporation against enemy factions
 * @export
 * @interface GetCorporationsCorporationIdFwStatsKills
 */
export interface GetCorporationsCorporationIdFwStatsKills {
    /**
     * Last week's total number of kills by members of the given corporation against enemy factions
     * @type {number}
     * @memberof GetCorporationsCorporationIdFwStatsKills
     */
    lastWeek: number;
    /**
     * Total number of kills by members of the given corporation against enemy factions since the corporation enlisted
     * @type {number}
     * @memberof GetCorporationsCorporationIdFwStatsKills
     */
    total: number;
    /**
     * Yesterday's total number of kills by members of the given corporation against enemy factions
     * @type {number}
     * @memberof GetCorporationsCorporationIdFwStatsKills
     */
    yesterday: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdFwStatsOk
 */
export interface GetCorporationsCorporationIdFwStatsOk {
    /**
     * The enlistment date of the given corporation into faction warfare. Will not be included if corporation is not enlisted in faction warfare
     * @type {Date}
     * @memberof GetCorporationsCorporationIdFwStatsOk
     */
    enlistedOn?: Date;
    /**
     * The faction the given corporation is enlisted to fight for. Will not be included if corporation is not enlisted in faction warfare
     * @type {number}
     * @memberof GetCorporationsCorporationIdFwStatsOk
     */
    factionId?: number;
    /**
     * 
     * @type {GetCorporationsCorporationIdFwStatsKills}
     * @memberof GetCorporationsCorporationIdFwStatsOk
     */
    kills: GetCorporationsCorporationIdFwStatsKills;
    /**
     * How many pilots the enlisted corporation has. Will not be included if corporation is not enlisted in faction warfare
     * @type {number}
     * @memberof GetCorporationsCorporationIdFwStatsOk
     */
    pilots?: number;
    /**
     * 
     * @type {GetCorporationsCorporationIdFwStatsVictoryPoints}
     * @memberof GetCorporationsCorporationIdFwStatsOk
     */
    victoryPoints: GetCorporationsCorporationIdFwStatsVictoryPoints;
}

/**
 * Summary of victory points gained by the given corporation for the enlisted faction
 * @export
 * @interface GetCorporationsCorporationIdFwStatsVictoryPoints
 */
export interface GetCorporationsCorporationIdFwStatsVictoryPoints {
    /**
     * Last week's victory points gained by members of the given corporation
     * @type {number}
     * @memberof GetCorporationsCorporationIdFwStatsVictoryPoints
     */
    lastWeek: number;
    /**
     * Total victory points gained since the given corporation enlisted
     * @type {number}
     * @memberof GetCorporationsCorporationIdFwStatsVictoryPoints
     */
    total: number;
    /**
     * Yesterday's victory points gained by members of the given corporation
     * @type {number}
     * @memberof GetCorporationsCorporationIdFwStatsVictoryPoints
     */
    yesterday: number;
}

/**
 * No image server for this datasource
 * @export
 * @interface GetCorporationsCorporationIdIconsNotFound
 */
export interface GetCorporationsCorporationIdIconsNotFound {
    /**
     * error message
     * @type {string}
     * @memberof GetCorporationsCorporationIdIconsNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdIconsOk
 */
export interface GetCorporationsCorporationIdIconsOk {
    /**
     * px128x128 string
     * @type {string}
     * @memberof GetCorporationsCorporationIdIconsOk
     */
    px128x128?: string;
    /**
     * px256x256 string
     * @type {string}
     * @memberof GetCorporationsCorporationIdIconsOk
     */
    px256x256?: string;
    /**
     * px64x64 string
     * @type {string}
     * @memberof GetCorporationsCorporationIdIconsOk
     */
    px64x64?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdIndustryJobs200Ok
 */
export interface GetCorporationsCorporationIdIndustryJobs200Ok {
    /**
     * Job activity ID
     * @type {number}
     * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
     */
    activityId: number;
    /**
     * blueprint_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
     */
    blueprintId: number;
    /**
     * Location ID of the location from which the blueprint was installed. Normally a station ID, but can also be an asset (e.g. container) or corporation facility
     * @type {number}
     * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
     */
    blueprintLocationId: number;
    /**
     * blueprint_type_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
     */
    blueprintTypeId: number;
    /**
     * ID of the character which completed this job
     * @type {number}
     * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
     */
    completedCharacterId?: number;
    /**
     * Date and time when this job was completed
     * @type {Date}
     * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
     */
    completedDate?: Date;
    /**
     * The sume of job installation fee and industry facility tax
     * @type {number}
     * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
     */
    cost?: number;
    /**
     * Job duration in seconds
     * @type {number}
     * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
     */
    duration: number;
    /**
     * Date and time when this job finished
     * @type {Date}
     * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
     */
    endDate: Date;
    /**
     * ID of the facility where this job is running
     * @type {number}
     * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
     */
    facilityId: number;
    /**
     * ID of the character which installed this job
     * @type {number}
     * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
     */
    installerId: number;
    /**
     * Unique job ID
     * @type {number}
     * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
     */
    jobId: number;
    /**
     * Number of runs blueprint is licensed for
     * @type {number}
     * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
     */
    licensedRuns?: number;
    /**
     * ID of the location for the industry facility
     * @type {number}
     * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
     */
    locationId: number;
    /**
     * Location ID of the location to which the output of the job will be delivered. Normally a station ID, but can also be a corporation facility
     * @type {number}
     * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
     */
    outputLocationId: number;
    /**
     * Date and time when this job was paused (i.e. time when the facility where this job was installed went offline)
     * @type {Date}
     * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
     */
    pauseDate?: Date;
    /**
     * Chance of success for invention
     * @type {number}
     * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
     */
    probability?: number;
    /**
     * Type ID of product (manufactured, copied or invented)
     * @type {number}
     * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
     */
    productTypeId?: number;
    /**
     * Number of runs for a manufacturing job, or number of copies to make for a blueprint copy
     * @type {number}
     * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
     */
    runs: number;
    /**
     * Date and time when this job started
     * @type {Date}
     * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
     */
    startDate: Date;
    /**
     * status string
     * @type {string}
     * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
     */
    status: GetCorporationsCorporationIdIndustryJobs200Ok.StatusEnum;
    /**
     * Number of successful runs for this job. Equal to runs unless this is an invention job
     * @type {number}
     * @memberof GetCorporationsCorporationIdIndustryJobs200Ok
     */
    successfulRuns?: number;
}

/**
 * @export
 * @namespace GetCorporationsCorporationIdIndustryJobs200Ok
 */
export namespace GetCorporationsCorporationIdIndustryJobs200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Active = <any> 'active',
        Cancelled = <any> 'cancelled',
        Delivered = <any> 'delivered',
        Paused = <any> 'paused',
        Ready = <any> 'ready',
        Reverted = <any> 'reverted'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdKillmailsRecent200Ok
 */
export interface GetCorporationsCorporationIdKillmailsRecent200Ok {
    /**
     * A hash of this killmail
     * @type {string}
     * @memberof GetCorporationsCorporationIdKillmailsRecent200Ok
     */
    killmailHash: string;
    /**
     * ID of this killmail
     * @type {number}
     * @memberof GetCorporationsCorporationIdKillmailsRecent200Ok
     */
    killmailId: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdMedals200Ok
 */
export interface GetCorporationsCorporationIdMedals200Ok {
    /**
     * created_at string
     * @type {Date}
     * @memberof GetCorporationsCorporationIdMedals200Ok
     */
    createdAt: Date;
    /**
     * ID of the character who created this medal
     * @type {number}
     * @memberof GetCorporationsCorporationIdMedals200Ok
     */
    creatorId: number;
    /**
     * description string
     * @type {string}
     * @memberof GetCorporationsCorporationIdMedals200Ok
     */
    description: string;
    /**
     * medal_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdMedals200Ok
     */
    medalId: number;
    /**
     * title string
     * @type {string}
     * @memberof GetCorporationsCorporationIdMedals200Ok
     */
    title: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdMedalsIssued200Ok
 */
export interface GetCorporationsCorporationIdMedalsIssued200Ok {
    /**
     * ID of the character who was rewarded this medal
     * @type {number}
     * @memberof GetCorporationsCorporationIdMedalsIssued200Ok
     */
    characterId: number;
    /**
     * issued_at string
     * @type {Date}
     * @memberof GetCorporationsCorporationIdMedalsIssued200Ok
     */
    issuedAt: Date;
    /**
     * ID of the character who issued the medal
     * @type {number}
     * @memberof GetCorporationsCorporationIdMedalsIssued200Ok
     */
    issuerId: number;
    /**
     * medal_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdMedalsIssued200Ok
     */
    medalId: number;
    /**
     * reason string
     * @type {string}
     * @memberof GetCorporationsCorporationIdMedalsIssued200Ok
     */
    reason: string;
    /**
     * status string
     * @type {string}
     * @memberof GetCorporationsCorporationIdMedalsIssued200Ok
     */
    status: GetCorporationsCorporationIdMedalsIssued200Ok.StatusEnum;
}

/**
 * @export
 * @namespace GetCorporationsCorporationIdMedalsIssued200Ok
 */
export namespace GetCorporationsCorporationIdMedalsIssued200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Private = <any> 'private',
        Public = <any> 'public'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdMembersTitles200Ok
 */
export interface GetCorporationsCorporationIdMembersTitles200Ok {
    /**
     * character_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdMembersTitles200Ok
     */
    characterId: number;
    /**
     * A list of title_id
     * @type {Array<number>}
     * @memberof GetCorporationsCorporationIdMembersTitles200Ok
     */
    titles: Array<number>;
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdMembertracking200Ok
 */
export interface GetCorporationsCorporationIdMembertracking200Ok {
    /**
     * base_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdMembertracking200Ok
     */
    baseId?: number;
    /**
     * character_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdMembertracking200Ok
     */
    characterId: number;
    /**
     * location_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdMembertracking200Ok
     */
    locationId?: number;
    /**
     * logoff_date string
     * @type {Date}
     * @memberof GetCorporationsCorporationIdMembertracking200Ok
     */
    logoffDate?: Date;
    /**
     * logon_date string
     * @type {Date}
     * @memberof GetCorporationsCorporationIdMembertracking200Ok
     */
    logonDate?: Date;
    /**
     * ship_type_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdMembertracking200Ok
     */
    shipTypeId?: number;
    /**
     * start_date string
     * @type {Date}
     * @memberof GetCorporationsCorporationIdMembertracking200Ok
     */
    startDate?: Date;
}

/**
 * Not found
 * @export
 * @interface GetCorporationsCorporationIdNotFound
 */
export interface GetCorporationsCorporationIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetCorporationsCorporationIdNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdOk
 */
export interface GetCorporationsCorporationIdOk {
    /**
     * ID of the alliance that corporation is a member of, if any
     * @type {number}
     * @memberof GetCorporationsCorporationIdOk
     */
    allianceId?: number;
    /**
     * ceo_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdOk
     */
    ceoId: number;
    /**
     * creator_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdOk
     */
    creatorId: number;
    /**
     * date_founded string
     * @type {Date}
     * @memberof GetCorporationsCorporationIdOk
     */
    dateFounded?: Date;
    /**
     * description string
     * @type {string}
     * @memberof GetCorporationsCorporationIdOk
     */
    description?: string;
    /**
     * faction_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdOk
     */
    factionId?: number;
    /**
     * home_station_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdOk
     */
    homeStationId?: number;
    /**
     * member_count integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdOk
     */
    memberCount: number;
    /**
     * the full name of the corporation
     * @type {string}
     * @memberof GetCorporationsCorporationIdOk
     */
    name: string;
    /**
     * shares integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdOk
     */
    shares?: number;
    /**
     * tax_rate number
     * @type {number}
     * @memberof GetCorporationsCorporationIdOk
     */
    taxRate: number;
    /**
     * the short name of the corporation
     * @type {string}
     * @memberof GetCorporationsCorporationIdOk
     */
    ticker: string;
    /**
     * url string
     * @type {string}
     * @memberof GetCorporationsCorporationIdOk
     */
    url?: string;
    /**
     * war_eligible boolean
     * @type {boolean}
     * @memberof GetCorporationsCorporationIdOk
     */
    warEligible?: boolean;
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdOrders200Ok
 */
export interface GetCorporationsCorporationIdOrders200Ok {
    /**
     * Number of days for which order is valid (starting from the issued date). An order expires at time issued + duration
     * @type {number}
     * @memberof GetCorporationsCorporationIdOrders200Ok
     */
    duration: number;
    /**
     * For buy orders, the amount of ISK in escrow
     * @type {number}
     * @memberof GetCorporationsCorporationIdOrders200Ok
     */
    escrow?: number;
    /**
     * True if the order is a bid (buy) order
     * @type {boolean}
     * @memberof GetCorporationsCorporationIdOrders200Ok
     */
    isBuyOrder?: boolean;
    /**
     * Date and time when this order was issued
     * @type {Date}
     * @memberof GetCorporationsCorporationIdOrders200Ok
     */
    issued: Date;
    /**
     * The character who issued this order
     * @type {number}
     * @memberof GetCorporationsCorporationIdOrders200Ok
     */
    issuedBy: number;
    /**
     * ID of the location where order was placed
     * @type {number}
     * @memberof GetCorporationsCorporationIdOrders200Ok
     */
    locationId: number;
    /**
     * For buy orders, the minimum quantity that will be accepted in a matching sell order
     * @type {number}
     * @memberof GetCorporationsCorporationIdOrders200Ok
     */
    minVolume?: number;
    /**
     * Unique order ID
     * @type {number}
     * @memberof GetCorporationsCorporationIdOrders200Ok
     */
    orderId: number;
    /**
     * Cost per unit for this order
     * @type {number}
     * @memberof GetCorporationsCorporationIdOrders200Ok
     */
    price: number;
    /**
     * Valid order range, numbers are ranges in jumps
     * @type {string}
     * @memberof GetCorporationsCorporationIdOrders200Ok
     */
    range: GetCorporationsCorporationIdOrders200Ok.RangeEnum;
    /**
     * ID of the region where order was placed
     * @type {number}
     * @memberof GetCorporationsCorporationIdOrders200Ok
     */
    regionId: number;
    /**
     * The type ID of the item transacted in this order
     * @type {number}
     * @memberof GetCorporationsCorporationIdOrders200Ok
     */
    typeId: number;
    /**
     * Quantity of items still required or offered
     * @type {number}
     * @memberof GetCorporationsCorporationIdOrders200Ok
     */
    volumeRemain: number;
    /**
     * Quantity of items required or offered at time order was placed
     * @type {number}
     * @memberof GetCorporationsCorporationIdOrders200Ok
     */
    volumeTotal: number;
    /**
     * The corporation wallet division used for this order.
     * @type {number}
     * @memberof GetCorporationsCorporationIdOrders200Ok
     */
    walletDivision: number;
}

/**
 * @export
 * @namespace GetCorporationsCorporationIdOrders200Ok
 */
export namespace GetCorporationsCorporationIdOrders200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum RangeEnum {
        _1 = <any> '1',
        _10 = <any> '10',
        _2 = <any> '2',
        _20 = <any> '20',
        _3 = <any> '3',
        _30 = <any> '30',
        _4 = <any> '4',
        _40 = <any> '40',
        _5 = <any> '5',
        Region = <any> 'region',
        Solarsystem = <any> 'solarsystem',
        Station = <any> 'station'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdOrdersHistory200Ok
 */
export interface GetCorporationsCorporationIdOrdersHistory200Ok {
    /**
     * Number of days the order was valid for (starting from the issued date). An order expires at time issued + duration
     * @type {number}
     * @memberof GetCorporationsCorporationIdOrdersHistory200Ok
     */
    duration: number;
    /**
     * For buy orders, the amount of ISK in escrow
     * @type {number}
     * @memberof GetCorporationsCorporationIdOrdersHistory200Ok
     */
    escrow?: number;
    /**
     * True if the order is a bid (buy) order
     * @type {boolean}
     * @memberof GetCorporationsCorporationIdOrdersHistory200Ok
     */
    isBuyOrder?: boolean;
    /**
     * Date and time when this order was issued
     * @type {Date}
     * @memberof GetCorporationsCorporationIdOrdersHistory200Ok
     */
    issued: Date;
    /**
     * The character who issued this order
     * @type {number}
     * @memberof GetCorporationsCorporationIdOrdersHistory200Ok
     */
    issuedBy?: number;
    /**
     * ID of the location where order was placed
     * @type {number}
     * @memberof GetCorporationsCorporationIdOrdersHistory200Ok
     */
    locationId: number;
    /**
     * For buy orders, the minimum quantity that will be accepted in a matching sell order
     * @type {number}
     * @memberof GetCorporationsCorporationIdOrdersHistory200Ok
     */
    minVolume?: number;
    /**
     * Unique order ID
     * @type {number}
     * @memberof GetCorporationsCorporationIdOrdersHistory200Ok
     */
    orderId: number;
    /**
     * Cost per unit for this order
     * @type {number}
     * @memberof GetCorporationsCorporationIdOrdersHistory200Ok
     */
    price: number;
    /**
     * Valid order range, numbers are ranges in jumps
     * @type {string}
     * @memberof GetCorporationsCorporationIdOrdersHistory200Ok
     */
    range: GetCorporationsCorporationIdOrdersHistory200Ok.RangeEnum;
    /**
     * ID of the region where order was placed
     * @type {number}
     * @memberof GetCorporationsCorporationIdOrdersHistory200Ok
     */
    regionId: number;
    /**
     * Current order state
     * @type {string}
     * @memberof GetCorporationsCorporationIdOrdersHistory200Ok
     */
    state: GetCorporationsCorporationIdOrdersHistory200Ok.StateEnum;
    /**
     * The type ID of the item transacted in this order
     * @type {number}
     * @memberof GetCorporationsCorporationIdOrdersHistory200Ok
     */
    typeId: number;
    /**
     * Quantity of items still required or offered
     * @type {number}
     * @memberof GetCorporationsCorporationIdOrdersHistory200Ok
     */
    volumeRemain: number;
    /**
     * Quantity of items required or offered at time order was placed
     * @type {number}
     * @memberof GetCorporationsCorporationIdOrdersHistory200Ok
     */
    volumeTotal: number;
    /**
     * The corporation wallet division used for this order
     * @type {number}
     * @memberof GetCorporationsCorporationIdOrdersHistory200Ok
     */
    walletDivision: number;
}

/**
 * @export
 * @namespace GetCorporationsCorporationIdOrdersHistory200Ok
 */
export namespace GetCorporationsCorporationIdOrdersHistory200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum RangeEnum {
        _1 = <any> '1',
        _10 = <any> '10',
        _2 = <any> '2',
        _20 = <any> '20',
        _3 = <any> '3',
        _30 = <any> '30',
        _4 = <any> '4',
        _40 = <any> '40',
        _5 = <any> '5',
        Region = <any> 'region',
        Solarsystem = <any> 'solarsystem',
        Station = <any> 'station'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        Cancelled = <any> 'cancelled',
        Expired = <any> 'expired'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdRoles200Ok
 */
export interface GetCorporationsCorporationIdRoles200Ok {
    /**
     * character_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdRoles200Ok
     */
    characterId: number;
    /**
     * grantable_roles array
     * @type {Array<string>}
     * @memberof GetCorporationsCorporationIdRoles200Ok
     */
    grantableRoles?: Array<GetCorporationsCorporationIdRoles200Ok.GrantableRolesEnum>;
    /**
     * grantable_roles_at_base array
     * @type {Array<string>}
     * @memberof GetCorporationsCorporationIdRoles200Ok
     */
    grantableRolesAtBase?: Array<GetCorporationsCorporationIdRoles200Ok.GrantableRolesAtBaseEnum>;
    /**
     * grantable_roles_at_hq array
     * @type {Array<string>}
     * @memberof GetCorporationsCorporationIdRoles200Ok
     */
    grantableRolesAtHq?: Array<GetCorporationsCorporationIdRoles200Ok.GrantableRolesAtHqEnum>;
    /**
     * grantable_roles_at_other array
     * @type {Array<string>}
     * @memberof GetCorporationsCorporationIdRoles200Ok
     */
    grantableRolesAtOther?: Array<GetCorporationsCorporationIdRoles200Ok.GrantableRolesAtOtherEnum>;
    /**
     * roles array
     * @type {Array<string>}
     * @memberof GetCorporationsCorporationIdRoles200Ok
     */
    roles?: Array<GetCorporationsCorporationIdRoles200Ok.RolesEnum>;
    /**
     * roles_at_base array
     * @type {Array<string>}
     * @memberof GetCorporationsCorporationIdRoles200Ok
     */
    rolesAtBase?: Array<GetCorporationsCorporationIdRoles200Ok.RolesAtBaseEnum>;
    /**
     * roles_at_hq array
     * @type {Array<string>}
     * @memberof GetCorporationsCorporationIdRoles200Ok
     */
    rolesAtHq?: Array<GetCorporationsCorporationIdRoles200Ok.RolesAtHqEnum>;
    /**
     * roles_at_other array
     * @type {Array<string>}
     * @memberof GetCorporationsCorporationIdRoles200Ok
     */
    rolesAtOther?: Array<GetCorporationsCorporationIdRoles200Ok.RolesAtOtherEnum>;
}

/**
 * @export
 * @namespace GetCorporationsCorporationIdRoles200Ok
 */
export namespace GetCorporationsCorporationIdRoles200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum GrantableRolesEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum GrantableRolesAtBaseEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum GrantableRolesAtHqEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum GrantableRolesAtOtherEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RolesEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RolesAtBaseEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RolesAtHqEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RolesAtOtherEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdRolesHistory200Ok
 */
export interface GetCorporationsCorporationIdRolesHistory200Ok {
    /**
     * changed_at string
     * @type {Date}
     * @memberof GetCorporationsCorporationIdRolesHistory200Ok
     */
    changedAt: Date;
    /**
     * The character whose roles are changed
     * @type {number}
     * @memberof GetCorporationsCorporationIdRolesHistory200Ok
     */
    characterId: number;
    /**
     * ID of the character who issued this change
     * @type {number}
     * @memberof GetCorporationsCorporationIdRolesHistory200Ok
     */
    issuerId: number;
    /**
     * new_roles array
     * @type {Array<string>}
     * @memberof GetCorporationsCorporationIdRolesHistory200Ok
     */
    newRoles: Array<GetCorporationsCorporationIdRolesHistory200Ok.NewRolesEnum>;
    /**
     * old_roles array
     * @type {Array<string>}
     * @memberof GetCorporationsCorporationIdRolesHistory200Ok
     */
    oldRoles: Array<GetCorporationsCorporationIdRolesHistory200Ok.OldRolesEnum>;
    /**
     * role_type string
     * @type {string}
     * @memberof GetCorporationsCorporationIdRolesHistory200Ok
     */
    roleType: GetCorporationsCorporationIdRolesHistory200Ok.RoleTypeEnum;
}

/**
 * @export
 * @namespace GetCorporationsCorporationIdRolesHistory200Ok
 */
export namespace GetCorporationsCorporationIdRolesHistory200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum NewRolesEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum OldRolesEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RoleTypeEnum {
        GrantableRoles = <any> 'grantable_roles',
        GrantableRolesAtBase = <any> 'grantable_roles_at_base',
        GrantableRolesAtHq = <any> 'grantable_roles_at_hq',
        GrantableRolesAtOther = <any> 'grantable_roles_at_other',
        Roles = <any> 'roles',
        RolesAtBase = <any> 'roles_at_base',
        RolesAtHq = <any> 'roles_at_hq',
        RolesAtOther = <any> 'roles_at_other'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdShareholders200Ok
 */
export interface GetCorporationsCorporationIdShareholders200Ok {
    /**
     * share_count integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdShareholders200Ok
     */
    shareCount: number;
    /**
     * shareholder_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdShareholders200Ok
     */
    shareholderId: number;
    /**
     * shareholder_type string
     * @type {string}
     * @memberof GetCorporationsCorporationIdShareholders200Ok
     */
    shareholderType: GetCorporationsCorporationIdShareholders200Ok.ShareholderTypeEnum;
}

/**
 * @export
 * @namespace GetCorporationsCorporationIdShareholders200Ok
 */
export namespace GetCorporationsCorporationIdShareholders200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum ShareholderTypeEnum {
        Character = <any> 'character',
        Corporation = <any> 'corporation'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdStandings200Ok
 */
export interface GetCorporationsCorporationIdStandings200Ok {
    /**
     * from_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdStandings200Ok
     */
    fromId: number;
    /**
     * from_type string
     * @type {string}
     * @memberof GetCorporationsCorporationIdStandings200Ok
     */
    fromType: GetCorporationsCorporationIdStandings200Ok.FromTypeEnum;
    /**
     * standing number
     * @type {number}
     * @memberof GetCorporationsCorporationIdStandings200Ok
     */
    standing: number;
}

/**
 * @export
 * @namespace GetCorporationsCorporationIdStandings200Ok
 */
export namespace GetCorporationsCorporationIdStandings200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum FromTypeEnum {
        Agent = <any> 'agent',
        NpcCorp = <any> 'npc_corp',
        Faction = <any> 'faction'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdStarbases200Ok
 */
export interface GetCorporationsCorporationIdStarbases200Ok {
    /**
     * The moon this starbase (POS) is anchored on, unanchored POSes do not have this information
     * @type {number}
     * @memberof GetCorporationsCorporationIdStarbases200Ok
     */
    moonId?: number;
    /**
     * When the POS onlined, for starbases (POSes) in online state
     * @type {Date}
     * @memberof GetCorporationsCorporationIdStarbases200Ok
     */
    onlinedSince?: Date;
    /**
     * When the POS will be out of reinforcement, for starbases (POSes) in reinforced state
     * @type {Date}
     * @memberof GetCorporationsCorporationIdStarbases200Ok
     */
    reinforcedUntil?: Date;
    /**
     * Unique ID for this starbase (POS)
     * @type {number}
     * @memberof GetCorporationsCorporationIdStarbases200Ok
     */
    starbaseId: number;
    /**
     * state string
     * @type {string}
     * @memberof GetCorporationsCorporationIdStarbases200Ok
     */
    state?: GetCorporationsCorporationIdStarbases200Ok.StateEnum;
    /**
     * The solar system this starbase (POS) is in, unanchored POSes have this information
     * @type {number}
     * @memberof GetCorporationsCorporationIdStarbases200Ok
     */
    systemId: number;
    /**
     * Starbase (POS) type
     * @type {number}
     * @memberof GetCorporationsCorporationIdStarbases200Ok
     */
    typeId: number;
    /**
     * When the POS started unanchoring, for starbases (POSes) in unanchoring state
     * @type {Date}
     * @memberof GetCorporationsCorporationIdStarbases200Ok
     */
    unanchorAt?: Date;
}

/**
 * @export
 * @namespace GetCorporationsCorporationIdStarbases200Ok
 */
export namespace GetCorporationsCorporationIdStarbases200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        Offline = <any> 'offline',
        Online = <any> 'online',
        Onlining = <any> 'onlining',
        Reinforced = <any> 'reinforced',
        Unanchoring = <any> 'unanchoring'
    }
}

/**
 * fuel object
 * @export
 * @interface GetCorporationsCorporationIdStarbasesStarbaseIdFuel
 */
export interface GetCorporationsCorporationIdStarbasesStarbaseIdFuel {
    /**
     * quantity integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdStarbasesStarbaseIdFuel
     */
    quantity: number;
    /**
     * type_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdStarbasesStarbaseIdFuel
     */
    typeId: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdStarbasesStarbaseIdOk
 */
export interface GetCorporationsCorporationIdStarbasesStarbaseIdOk {
    /**
     * allow_alliance_members boolean
     * @type {boolean}
     * @memberof GetCorporationsCorporationIdStarbasesStarbaseIdOk
     */
    allowAllianceMembers: boolean;
    /**
     * allow_corporation_members boolean
     * @type {boolean}
     * @memberof GetCorporationsCorporationIdStarbasesStarbaseIdOk
     */
    allowCorporationMembers: boolean;
    /**
     * Who can anchor starbase (POS) and its structures
     * @type {string}
     * @memberof GetCorporationsCorporationIdStarbasesStarbaseIdOk
     */
    anchor: GetCorporationsCorporationIdStarbasesStarbaseIdOk.AnchorEnum;
    /**
     * attack_if_at_war boolean
     * @type {boolean}
     * @memberof GetCorporationsCorporationIdStarbasesStarbaseIdOk
     */
    attackIfAtWar: boolean;
    /**
     * attack_if_other_security_status_dropping boolean
     * @type {boolean}
     * @memberof GetCorporationsCorporationIdStarbasesStarbaseIdOk
     */
    attackIfOtherSecurityStatusDropping: boolean;
    /**
     * Starbase (POS) will attack if target's security standing is lower than this value
     * @type {number}
     * @memberof GetCorporationsCorporationIdStarbasesStarbaseIdOk
     */
    attackSecurityStatusThreshold?: number;
    /**
     * Starbase (POS) will attack if target's standing is lower than this value
     * @type {number}
     * @memberof GetCorporationsCorporationIdStarbasesStarbaseIdOk
     */
    attackStandingThreshold?: number;
    /**
     * Who can take fuel blocks out of the starbase (POS)'s fuel bay
     * @type {string}
     * @memberof GetCorporationsCorporationIdStarbasesStarbaseIdOk
     */
    fuelBayTake: GetCorporationsCorporationIdStarbasesStarbaseIdOk.FuelBayTakeEnum;
    /**
     * Who can view the starbase (POS)'s fule bay. Characters either need to have required role or belong to the starbase (POS) owner's corporation or alliance, as described by the enum, all other access settings follows the same scheme
     * @type {string}
     * @memberof GetCorporationsCorporationIdStarbasesStarbaseIdOk
     */
    fuelBayView: GetCorporationsCorporationIdStarbasesStarbaseIdOk.FuelBayViewEnum;
    /**
     * Fuel blocks and other things that will be consumed when operating a starbase (POS)
     * @type {Array<GetCorporationsCorporationIdStarbasesStarbaseIdFuel>}
     * @memberof GetCorporationsCorporationIdStarbasesStarbaseIdOk
     */
    fuels?: Array<GetCorporationsCorporationIdStarbasesStarbaseIdFuel>;
    /**
     * Who can offline starbase (POS) and its structures
     * @type {string}
     * @memberof GetCorporationsCorporationIdStarbasesStarbaseIdOk
     */
    offline: GetCorporationsCorporationIdStarbasesStarbaseIdOk.OfflineEnum;
    /**
     * Who can online starbase (POS) and its structures
     * @type {string}
     * @memberof GetCorporationsCorporationIdStarbasesStarbaseIdOk
     */
    online: GetCorporationsCorporationIdStarbasesStarbaseIdOk.OnlineEnum;
    /**
     * Who can unanchor starbase (POS) and its structures
     * @type {string}
     * @memberof GetCorporationsCorporationIdStarbasesStarbaseIdOk
     */
    unanchor: GetCorporationsCorporationIdStarbasesStarbaseIdOk.UnanchorEnum;
    /**
     * True if the starbase (POS) is using alliance standings, otherwise using corporation's
     * @type {boolean}
     * @memberof GetCorporationsCorporationIdStarbasesStarbaseIdOk
     */
    useAllianceStandings: boolean;
}

/**
 * @export
 * @namespace GetCorporationsCorporationIdStarbasesStarbaseIdOk
 */
export namespace GetCorporationsCorporationIdStarbasesStarbaseIdOk {
    /**
     * @export
     * @enum {string}
     */
    export enum AnchorEnum {
        AllianceMember = <any> 'alliance_member',
        ConfigStarbaseEquipmentRole = <any> 'config_starbase_equipment_role',
        CorporationMember = <any> 'corporation_member',
        StarbaseFuelTechnicianRole = <any> 'starbase_fuel_technician_role'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum FuelBayTakeEnum {
        AllianceMember = <any> 'alliance_member',
        ConfigStarbaseEquipmentRole = <any> 'config_starbase_equipment_role',
        CorporationMember = <any> 'corporation_member',
        StarbaseFuelTechnicianRole = <any> 'starbase_fuel_technician_role'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum FuelBayViewEnum {
        AllianceMember = <any> 'alliance_member',
        ConfigStarbaseEquipmentRole = <any> 'config_starbase_equipment_role',
        CorporationMember = <any> 'corporation_member',
        StarbaseFuelTechnicianRole = <any> 'starbase_fuel_technician_role'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum OfflineEnum {
        AllianceMember = <any> 'alliance_member',
        ConfigStarbaseEquipmentRole = <any> 'config_starbase_equipment_role',
        CorporationMember = <any> 'corporation_member',
        StarbaseFuelTechnicianRole = <any> 'starbase_fuel_technician_role'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum OnlineEnum {
        AllianceMember = <any> 'alliance_member',
        ConfigStarbaseEquipmentRole = <any> 'config_starbase_equipment_role',
        CorporationMember = <any> 'corporation_member',
        StarbaseFuelTechnicianRole = <any> 'starbase_fuel_technician_role'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum UnanchorEnum {
        AllianceMember = <any> 'alliance_member',
        ConfigStarbaseEquipmentRole = <any> 'config_starbase_equipment_role',
        CorporationMember = <any> 'corporation_member',
        StarbaseFuelTechnicianRole = <any> 'starbase_fuel_technician_role'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdStructures200Ok
 */
export interface GetCorporationsCorporationIdStructures200Ok {
    /**
     * ID of the corporation that owns the structure
     * @type {number}
     * @memberof GetCorporationsCorporationIdStructures200Ok
     */
    corporationId: number;
    /**
     * Date on which the structure will run out of fuel
     * @type {Date}
     * @memberof GetCorporationsCorporationIdStructures200Ok
     */
    fuelExpires?: Date;
    /**
     * The structure name
     * @type {string}
     * @memberof GetCorporationsCorporationIdStructures200Ok
     */
    name?: string;
    /**
     * The date and time when the structure's newly requested reinforcement times (e.g. next_reinforce_hour and next_reinforce_day) will take effect
     * @type {Date}
     * @memberof GetCorporationsCorporationIdStructures200Ok
     */
    nextReinforceApply?: Date;
    /**
     * The requested change to reinforce_hour that will take effect at the time shown by next_reinforce_apply
     * @type {number}
     * @memberof GetCorporationsCorporationIdStructures200Ok
     */
    nextReinforceHour?: number;
    /**
     * The id of the ACL profile for this citadel
     * @type {number}
     * @memberof GetCorporationsCorporationIdStructures200Ok
     */
    profileId: number;
    /**
     * The hour of day that determines the four hour window when the structure will randomly exit its reinforcement periods and become vulnerable to attack against its armor and/or hull. The structure will become vulnerable at a random time that is +/- 2 hours centered on the value of this property
     * @type {number}
     * @memberof GetCorporationsCorporationIdStructures200Ok
     */
    reinforceHour?: number;
    /**
     * Contains a list of service upgrades, and their state
     * @type {Array<GetCorporationsCorporationIdStructuresService>}
     * @memberof GetCorporationsCorporationIdStructures200Ok
     */
    services?: Array<GetCorporationsCorporationIdStructuresService>;
    /**
     * state string
     * @type {string}
     * @memberof GetCorporationsCorporationIdStructures200Ok
     */
    state: GetCorporationsCorporationIdStructures200Ok.StateEnum;
    /**
     * Date at which the structure will move to it's next state
     * @type {Date}
     * @memberof GetCorporationsCorporationIdStructures200Ok
     */
    stateTimerEnd?: Date;
    /**
     * Date at which the structure entered it's current state
     * @type {Date}
     * @memberof GetCorporationsCorporationIdStructures200Ok
     */
    stateTimerStart?: Date;
    /**
     * The Item ID of the structure
     * @type {number}
     * @memberof GetCorporationsCorporationIdStructures200Ok
     */
    structureId: number;
    /**
     * The solar system the structure is in
     * @type {number}
     * @memberof GetCorporationsCorporationIdStructures200Ok
     */
    systemId: number;
    /**
     * The type id of the structure
     * @type {number}
     * @memberof GetCorporationsCorporationIdStructures200Ok
     */
    typeId: number;
    /**
     * Date at which the structure will unanchor
     * @type {Date}
     * @memberof GetCorporationsCorporationIdStructures200Ok
     */
    unanchorsAt?: Date;
}

/**
 * @export
 * @namespace GetCorporationsCorporationIdStructures200Ok
 */
export namespace GetCorporationsCorporationIdStructures200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        AnchorVulnerable = <any> 'anchor_vulnerable',
        Anchoring = <any> 'anchoring',
        ArmorReinforce = <any> 'armor_reinforce',
        ArmorVulnerable = <any> 'armor_vulnerable',
        DeployVulnerable = <any> 'deploy_vulnerable',
        FittingInvulnerable = <any> 'fitting_invulnerable',
        HullReinforce = <any> 'hull_reinforce',
        HullVulnerable = <any> 'hull_vulnerable',
        OnlineDeprecated = <any> 'online_deprecated',
        OnliningVulnerable = <any> 'onlining_vulnerable',
        ShieldVulnerable = <any> 'shield_vulnerable',
        Unanchored = <any> 'unanchored',
        Unknown = <any> 'unknown'
    }
}

/**
 * service object
 * @export
 * @interface GetCorporationsCorporationIdStructuresService
 */
export interface GetCorporationsCorporationIdStructuresService {
    /**
     * name string
     * @type {string}
     * @memberof GetCorporationsCorporationIdStructuresService
     */
    name: string;
    /**
     * state string
     * @type {string}
     * @memberof GetCorporationsCorporationIdStructuresService
     */
    state: GetCorporationsCorporationIdStructuresService.StateEnum;
}

/**
 * @export
 * @namespace GetCorporationsCorporationIdStructuresService
 */
export namespace GetCorporationsCorporationIdStructuresService {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        Online = <any> 'online',
        Offline = <any> 'offline',
        Cleanup = <any> 'cleanup'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdTitles200Ok
 */
export interface GetCorporationsCorporationIdTitles200Ok {
    /**
     * grantable_roles array
     * @type {Array<string>}
     * @memberof GetCorporationsCorporationIdTitles200Ok
     */
    grantableRoles?: Array<GetCorporationsCorporationIdTitles200Ok.GrantableRolesEnum>;
    /**
     * grantable_roles_at_base array
     * @type {Array<string>}
     * @memberof GetCorporationsCorporationIdTitles200Ok
     */
    grantableRolesAtBase?: Array<GetCorporationsCorporationIdTitles200Ok.GrantableRolesAtBaseEnum>;
    /**
     * grantable_roles_at_hq array
     * @type {Array<string>}
     * @memberof GetCorporationsCorporationIdTitles200Ok
     */
    grantableRolesAtHq?: Array<GetCorporationsCorporationIdTitles200Ok.GrantableRolesAtHqEnum>;
    /**
     * grantable_roles_at_other array
     * @type {Array<string>}
     * @memberof GetCorporationsCorporationIdTitles200Ok
     */
    grantableRolesAtOther?: Array<GetCorporationsCorporationIdTitles200Ok.GrantableRolesAtOtherEnum>;
    /**
     * name string
     * @type {string}
     * @memberof GetCorporationsCorporationIdTitles200Ok
     */
    name?: string;
    /**
     * roles array
     * @type {Array<string>}
     * @memberof GetCorporationsCorporationIdTitles200Ok
     */
    roles?: Array<GetCorporationsCorporationIdTitles200Ok.RolesEnum>;
    /**
     * roles_at_base array
     * @type {Array<string>}
     * @memberof GetCorporationsCorporationIdTitles200Ok
     */
    rolesAtBase?: Array<GetCorporationsCorporationIdTitles200Ok.RolesAtBaseEnum>;
    /**
     * roles_at_hq array
     * @type {Array<string>}
     * @memberof GetCorporationsCorporationIdTitles200Ok
     */
    rolesAtHq?: Array<GetCorporationsCorporationIdTitles200Ok.RolesAtHqEnum>;
    /**
     * roles_at_other array
     * @type {Array<string>}
     * @memberof GetCorporationsCorporationIdTitles200Ok
     */
    rolesAtOther?: Array<GetCorporationsCorporationIdTitles200Ok.RolesAtOtherEnum>;
    /**
     * title_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdTitles200Ok
     */
    titleId?: number;
}

/**
 * @export
 * @namespace GetCorporationsCorporationIdTitles200Ok
 */
export namespace GetCorporationsCorporationIdTitles200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum GrantableRolesEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum GrantableRolesAtBaseEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum GrantableRolesAtHqEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum GrantableRolesAtOtherEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RolesEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RolesAtBaseEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RolesAtHqEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RolesAtOtherEnum {
        AccountTake1 = <any> 'Account_Take_1',
        AccountTake2 = <any> 'Account_Take_2',
        AccountTake3 = <any> 'Account_Take_3',
        AccountTake4 = <any> 'Account_Take_4',
        AccountTake5 = <any> 'Account_Take_5',
        AccountTake6 = <any> 'Account_Take_6',
        AccountTake7 = <any> 'Account_Take_7',
        Accountant = <any> 'Accountant',
        Auditor = <any> 'Auditor',
        CommunicationsOfficer = <any> 'Communications_Officer',
        ConfigEquipment = <any> 'Config_Equipment',
        ConfigStarbaseEquipment = <any> 'Config_Starbase_Equipment',
        ContainerTake1 = <any> 'Container_Take_1',
        ContainerTake2 = <any> 'Container_Take_2',
        ContainerTake3 = <any> 'Container_Take_3',
        ContainerTake4 = <any> 'Container_Take_4',
        ContainerTake5 = <any> 'Container_Take_5',
        ContainerTake6 = <any> 'Container_Take_6',
        ContainerTake7 = <any> 'Container_Take_7',
        ContractManager = <any> 'Contract_Manager',
        Diplomat = <any> 'Diplomat',
        Director = <any> 'Director',
        FactoryManager = <any> 'Factory_Manager',
        FittingManager = <any> 'Fitting_Manager',
        HangarQuery1 = <any> 'Hangar_Query_1',
        HangarQuery2 = <any> 'Hangar_Query_2',
        HangarQuery3 = <any> 'Hangar_Query_3',
        HangarQuery4 = <any> 'Hangar_Query_4',
        HangarQuery5 = <any> 'Hangar_Query_5',
        HangarQuery6 = <any> 'Hangar_Query_6',
        HangarQuery7 = <any> 'Hangar_Query_7',
        HangarTake1 = <any> 'Hangar_Take_1',
        HangarTake2 = <any> 'Hangar_Take_2',
        HangarTake3 = <any> 'Hangar_Take_3',
        HangarTake4 = <any> 'Hangar_Take_4',
        HangarTake5 = <any> 'Hangar_Take_5',
        HangarTake6 = <any> 'Hangar_Take_6',
        HangarTake7 = <any> 'Hangar_Take_7',
        JuniorAccountant = <any> 'Junior_Accountant',
        PersonnelManager = <any> 'Personnel_Manager',
        RentFactoryFacility = <any> 'Rent_Factory_Facility',
        RentOffice = <any> 'Rent_Office',
        RentResearchFacility = <any> 'Rent_Research_Facility',
        SecurityOfficer = <any> 'Security_Officer',
        StarbaseDefenseOperator = <any> 'Starbase_Defense_Operator',
        StarbaseFuelTechnician = <any> 'Starbase_Fuel_Technician',
        StationManager = <any> 'Station_Manager',
        Trader = <any> 'Trader'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdWallets200Ok
 */
export interface GetCorporationsCorporationIdWallets200Ok {
    /**
     * balance number
     * @type {number}
     * @memberof GetCorporationsCorporationIdWallets200Ok
     */
    balance: number;
    /**
     * division integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdWallets200Ok
     */
    division: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetCorporationsCorporationIdWalletsDivisionJournal200Ok
 */
export interface GetCorporationsCorporationIdWalletsDivisionJournal200Ok {
    /**
     * The amount of ISK given or taken from the wallet as a result of the given transaction. Positive when ISK is deposited into the wallet and negative when ISK is withdrawn
     * @type {number}
     * @memberof GetCorporationsCorporationIdWalletsDivisionJournal200Ok
     */
    amount?: number;
    /**
     * Wallet balance after transaction occurred
     * @type {number}
     * @memberof GetCorporationsCorporationIdWalletsDivisionJournal200Ok
     */
    balance?: number;
    /**
     * An ID that gives extra context to the particular transaction. Because of legacy reasons the context is completely different per ref_type and means different things. It is also possible to not have a context_id
     * @type {number}
     * @memberof GetCorporationsCorporationIdWalletsDivisionJournal200Ok
     */
    contextId?: number;
    /**
     * The type of the given context_id if present
     * @type {string}
     * @memberof GetCorporationsCorporationIdWalletsDivisionJournal200Ok
     */
    contextIdType?: GetCorporationsCorporationIdWalletsDivisionJournal200Ok.ContextIdTypeEnum;
    /**
     * Date and time of transaction
     * @type {Date}
     * @memberof GetCorporationsCorporationIdWalletsDivisionJournal200Ok
     */
    date: Date;
    /**
     * The reason for the transaction, mirrors what is seen in the client
     * @type {string}
     * @memberof GetCorporationsCorporationIdWalletsDivisionJournal200Ok
     */
    description: string;
    /**
     * The id of the first party involved in the transaction. This attribute has no consistency and is different or non existant for particular ref_types. The description attribute will help make sense of what this attribute means. For more info about the given ID it can be dropped into the /universe/names/ ESI route to determine its type and name
     * @type {number}
     * @memberof GetCorporationsCorporationIdWalletsDivisionJournal200Ok
     */
    firstPartyId?: number;
    /**
     * Unique journal reference ID
     * @type {number}
     * @memberof GetCorporationsCorporationIdWalletsDivisionJournal200Ok
     */
    id: number;
    /**
     * The user stated reason for the transaction. Only applies to some ref_types
     * @type {string}
     * @memberof GetCorporationsCorporationIdWalletsDivisionJournal200Ok
     */
    reason?: string;
    /**
     * \"The transaction type for the given. transaction. Different transaction types will populate different attributes. Note: If you have an existing XML API application that is using ref_types, you will need to know which string ESI ref_type maps to which integer. You can look at the following file to see string->int mappings: https://github.com/ccpgames/eve-glue/blob/master/eve_glue/wallet_journal_ref.py\"
     * @type {string}
     * @memberof GetCorporationsCorporationIdWalletsDivisionJournal200Ok
     */
    refType: GetCorporationsCorporationIdWalletsDivisionJournal200Ok.RefTypeEnum;
    /**
     * The id of the second party involved in the transaction. This attribute has no consistency and is different or non existant for particular ref_types. The description attribute will help make sense of what this attribute means. For more info about the given ID it can be dropped into the /universe/names/ ESI route to determine its type and name
     * @type {number}
     * @memberof GetCorporationsCorporationIdWalletsDivisionJournal200Ok
     */
    secondPartyId?: number;
    /**
     * Tax amount received. Only applies to tax related transactions
     * @type {number}
     * @memberof GetCorporationsCorporationIdWalletsDivisionJournal200Ok
     */
    tax?: number;
    /**
     * The corporation ID receiving any tax paid. Only applies to tax related transactions
     * @type {number}
     * @memberof GetCorporationsCorporationIdWalletsDivisionJournal200Ok
     */
    taxReceiverId?: number;
}

/**
 * @export
 * @namespace GetCorporationsCorporationIdWalletsDivisionJournal200Ok
 */
export namespace GetCorporationsCorporationIdWalletsDivisionJournal200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum ContextIdTypeEnum {
        StructureId = <any> 'structure_id',
        StationId = <any> 'station_id',
        MarketTransactionId = <any> 'market_transaction_id',
        CharacterId = <any> 'character_id',
        CorporationId = <any> 'corporation_id',
        AllianceId = <any> 'alliance_id',
        EveSystem = <any> 'eve_system',
        IndustryJobId = <any> 'industry_job_id',
        ContractId = <any> 'contract_id',
        PlanetId = <any> 'planet_id',
        SystemId = <any> 'system_id',
        TypeId = <any> 'type_id'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RefTypeEnum {
        AccelerationGateFee = <any> 'acceleration_gate_fee',
        AdvertisementListingFee = <any> 'advertisement_listing_fee',
        AgentDonation = <any> 'agent_donation',
        AgentLocationServices = <any> 'agent_location_services',
        AgentMiscellaneous = <any> 'agent_miscellaneous',
        AgentMissionCollateralPaid = <any> 'agent_mission_collateral_paid',
        AgentMissionCollateralRefunded = <any> 'agent_mission_collateral_refunded',
        AgentMissionReward = <any> 'agent_mission_reward',
        AgentMissionRewardCorporationTax = <any> 'agent_mission_reward_corporation_tax',
        AgentMissionTimeBonusReward = <any> 'agent_mission_time_bonus_reward',
        AgentMissionTimeBonusRewardCorporationTax = <any> 'agent_mission_time_bonus_reward_corporation_tax',
        AgentSecurityServices = <any> 'agent_security_services',
        AgentServicesRendered = <any> 'agent_services_rendered',
        AgentsPreward = <any> 'agents_preward',
        AllianceMaintainanceFee = <any> 'alliance_maintainance_fee',
        AllianceRegistrationFee = <any> 'alliance_registration_fee',
        AssetSafetyRecoveryTax = <any> 'asset_safety_recovery_tax',
        Bounty = <any> 'bounty',
        BountyPrize = <any> 'bounty_prize',
        BountyPrizeCorporationTax = <any> 'bounty_prize_corporation_tax',
        BountyPrizes = <any> 'bounty_prizes',
        BountyReimbursement = <any> 'bounty_reimbursement',
        BountySurcharge = <any> 'bounty_surcharge',
        BrokersFee = <any> 'brokers_fee',
        CloneActivation = <any> 'clone_activation',
        CloneTransfer = <any> 'clone_transfer',
        ContrabandFine = <any> 'contraband_fine',
        ContractAuctionBid = <any> 'contract_auction_bid',
        ContractAuctionBidCorp = <any> 'contract_auction_bid_corp',
        ContractAuctionBidRefund = <any> 'contract_auction_bid_refund',
        ContractAuctionSold = <any> 'contract_auction_sold',
        ContractBrokersFee = <any> 'contract_brokers_fee',
        ContractBrokersFeeCorp = <any> 'contract_brokers_fee_corp',
        ContractCollateral = <any> 'contract_collateral',
        ContractCollateralDepositedCorp = <any> 'contract_collateral_deposited_corp',
        ContractCollateralPayout = <any> 'contract_collateral_payout',
        ContractCollateralRefund = <any> 'contract_collateral_refund',
        ContractDeposit = <any> 'contract_deposit',
        ContractDepositCorp = <any> 'contract_deposit_corp',
        ContractDepositRefund = <any> 'contract_deposit_refund',
        ContractDepositSalesTax = <any> 'contract_deposit_sales_tax',
        ContractPrice = <any> 'contract_price',
        ContractPricePaymentCorp = <any> 'contract_price_payment_corp',
        ContractReversal = <any> 'contract_reversal',
        ContractReward = <any> 'contract_reward',
        ContractRewardDeposited = <any> 'contract_reward_deposited',
        ContractRewardDepositedCorp = <any> 'contract_reward_deposited_corp',
        ContractRewardRefund = <any> 'contract_reward_refund',
        ContractSalesTax = <any> 'contract_sales_tax',
        Copying = <any> 'copying',
        CorporateRewardPayout = <any> 'corporate_reward_payout',
        CorporateRewardTax = <any> 'corporate_reward_tax',
        CorporationAccountWithdrawal = <any> 'corporation_account_withdrawal',
        CorporationBulkPayment = <any> 'corporation_bulk_payment',
        CorporationDividendPayment = <any> 'corporation_dividend_payment',
        CorporationLiquidation = <any> 'corporation_liquidation',
        CorporationLogoChangeCost = <any> 'corporation_logo_change_cost',
        CorporationPayment = <any> 'corporation_payment',
        CorporationRegistrationFee = <any> 'corporation_registration_fee',
        CourierMissionEscrow = <any> 'courier_mission_escrow',
        Cspa = <any> 'cspa',
        Cspaofflinerefund = <any> 'cspaofflinerefund',
        DailyChallengeReward = <any> 'daily_challenge_reward',
        DatacoreFee = <any> 'datacore_fee',
        DnaModificationFee = <any> 'dna_modification_fee',
        DockingFee = <any> 'docking_fee',
        DuelWagerEscrow = <any> 'duel_wager_escrow',
        DuelWagerPayment = <any> 'duel_wager_payment',
        DuelWagerRefund = <any> 'duel_wager_refund',
        EssEscrowTransfer = <any> 'ess_escrow_transfer',
        ExternalTradeDelivery = <any> 'external_trade_delivery',
        ExternalTradeFreeze = <any> 'external_trade_freeze',
        ExternalTradeThaw = <any> 'external_trade_thaw',
        FactorySlotRentalFee = <any> 'factory_slot_rental_fee',
        FluxPayout = <any> 'flux_payout',
        FluxTax = <any> 'flux_tax',
        FluxTicketRepayment = <any> 'flux_ticket_repayment',
        FluxTicketSale = <any> 'flux_ticket_sale',
        GmCashTransfer = <any> 'gm_cash_transfer',
        IndustryJobTax = <any> 'industry_job_tax',
        InfrastructureHubMaintenance = <any> 'infrastructure_hub_maintenance',
        Inheritance = <any> 'inheritance',
        Insurance = <any> 'insurance',
        ItemTraderPayment = <any> 'item_trader_payment',
        JumpCloneActivationFee = <any> 'jump_clone_activation_fee',
        JumpCloneInstallationFee = <any> 'jump_clone_installation_fee',
        KillRightFee = <any> 'kill_right_fee',
        LpStore = <any> 'lp_store',
        Manufacturing = <any> 'manufacturing',
        MarketEscrow = <any> 'market_escrow',
        MarketFinePaid = <any> 'market_fine_paid',
        MarketProviderTax = <any> 'market_provider_tax',
        MarketTransaction = <any> 'market_transaction',
        MedalCreation = <any> 'medal_creation',
        MedalIssued = <any> 'medal_issued',
        MilestoneRewardPayment = <any> 'milestone_reward_payment',
        MissionCompletion = <any> 'mission_completion',
        MissionCost = <any> 'mission_cost',
        MissionExpiration = <any> 'mission_expiration',
        MissionReward = <any> 'mission_reward',
        OfficeRentalFee = <any> 'office_rental_fee',
        OperationBonus = <any> 'operation_bonus',
        OpportunityReward = <any> 'opportunity_reward',
        PlanetaryConstruction = <any> 'planetary_construction',
        PlanetaryExportTax = <any> 'planetary_export_tax',
        PlanetaryImportTax = <any> 'planetary_import_tax',
        PlayerDonation = <any> 'player_donation',
        PlayerTrading = <any> 'player_trading',
        ProjectDiscoveryReward = <any> 'project_discovery_reward',
        ProjectDiscoveryTax = <any> 'project_discovery_tax',
        Reaction = <any> 'reaction',
        RedeemedIskToken = <any> 'redeemed_isk_token',
        ReleaseOfImpoundedProperty = <any> 'release_of_impounded_property',
        RepairBill = <any> 'repair_bill',
        ReprocessingTax = <any> 'reprocessing_tax',
        ResearchingMaterialProductivity = <any> 'researching_material_productivity',
        ResearchingTechnology = <any> 'researching_technology',
        ResearchingTimeProductivity = <any> 'researching_time_productivity',
        ResourceWarsReward = <any> 'resource_wars_reward',
        ReverseEngineering = <any> 'reverse_engineering',
        SeasonChallengeReward = <any> 'season_challenge_reward',
        SecurityProcessingFee = <any> 'security_processing_fee',
        Shares = <any> 'shares',
        SkillPurchase = <any> 'skill_purchase',
        SovereignityBill = <any> 'sovereignity_bill',
        StorePurchase = <any> 'store_purchase',
        StorePurchaseRefund = <any> 'store_purchase_refund',
        StructureGateJump = <any> 'structure_gate_jump',
        TransactionTax = <any> 'transaction_tax',
        UpkeepAdjustmentFee = <any> 'upkeep_adjustment_fee',
        WarAllyContract = <any> 'war_ally_contract',
        WarFee = <any> 'war_fee',
        WarFeeSurrender = <any> 'war_fee_surrender'
    }
}

/**
 * wallet transaction
 * @export
 * @interface GetCorporationsCorporationIdWalletsDivisionTransactions200Ok
 */
export interface GetCorporationsCorporationIdWalletsDivisionTransactions200Ok {
    /**
     * client_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdWalletsDivisionTransactions200Ok
     */
    clientId: number;
    /**
     * Date and time of transaction
     * @type {Date}
     * @memberof GetCorporationsCorporationIdWalletsDivisionTransactions200Ok
     */
    date: Date;
    /**
     * is_buy boolean
     * @type {boolean}
     * @memberof GetCorporationsCorporationIdWalletsDivisionTransactions200Ok
     */
    isBuy: boolean;
    /**
     * -1 if there is no corresponding wallet journal entry
     * @type {number}
     * @memberof GetCorporationsCorporationIdWalletsDivisionTransactions200Ok
     */
    journalRefId: number;
    /**
     * location_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdWalletsDivisionTransactions200Ok
     */
    locationId: number;
    /**
     * quantity integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdWalletsDivisionTransactions200Ok
     */
    quantity: number;
    /**
     * Unique transaction ID
     * @type {number}
     * @memberof GetCorporationsCorporationIdWalletsDivisionTransactions200Ok
     */
    transactionId: number;
    /**
     * type_id integer
     * @type {number}
     * @memberof GetCorporationsCorporationIdWalletsDivisionTransactions200Ok
     */
    typeId: number;
    /**
     * Amount paid per unit
     * @type {number}
     * @memberof GetCorporationsCorporationIdWalletsDivisionTransactions200Ok
     */
    unitPrice: number;
}

/**
 * Not found
 * @export
 * @interface GetDogmaAttributesAttributeIdNotFound
 */
export interface GetDogmaAttributesAttributeIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetDogmaAttributesAttributeIdNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetDogmaAttributesAttributeIdOk
 */
export interface GetDogmaAttributesAttributeIdOk {
    /**
     * attribute_id integer
     * @type {number}
     * @memberof GetDogmaAttributesAttributeIdOk
     */
    attributeId: number;
    /**
     * default_value number
     * @type {number}
     * @memberof GetDogmaAttributesAttributeIdOk
     */
    defaultValue?: number;
    /**
     * description string
     * @type {string}
     * @memberof GetDogmaAttributesAttributeIdOk
     */
    description?: string;
    /**
     * display_name string
     * @type {string}
     * @memberof GetDogmaAttributesAttributeIdOk
     */
    displayName?: string;
    /**
     * high_is_good boolean
     * @type {boolean}
     * @memberof GetDogmaAttributesAttributeIdOk
     */
    highIsGood?: boolean;
    /**
     * icon_id integer
     * @type {number}
     * @memberof GetDogmaAttributesAttributeIdOk
     */
    iconId?: number;
    /**
     * name string
     * @type {string}
     * @memberof GetDogmaAttributesAttributeIdOk
     */
    name?: string;
    /**
     * published boolean
     * @type {boolean}
     * @memberof GetDogmaAttributesAttributeIdOk
     */
    published?: boolean;
    /**
     * stackable boolean
     * @type {boolean}
     * @memberof GetDogmaAttributesAttributeIdOk
     */
    stackable?: boolean;
    /**
     * unit_id integer
     * @type {number}
     * @memberof GetDogmaAttributesAttributeIdOk
     */
    unitId?: number;
}

/**
 * dogma_attribute object
 * @export
 * @interface GetDogmaDynamicItemsTypeIdItemIdDogmaAttribute
 */
export interface GetDogmaDynamicItemsTypeIdItemIdDogmaAttribute {
    /**
     * attribute_id integer
     * @type {number}
     * @memberof GetDogmaDynamicItemsTypeIdItemIdDogmaAttribute
     */
    attributeId: number;
    /**
     * value number
     * @type {number}
     * @memberof GetDogmaDynamicItemsTypeIdItemIdDogmaAttribute
     */
    value: number;
}

/**
 * dogma_effect object
 * @export
 * @interface GetDogmaDynamicItemsTypeIdItemIdDogmaEffect
 */
export interface GetDogmaDynamicItemsTypeIdItemIdDogmaEffect {
    /**
     * effect_id integer
     * @type {number}
     * @memberof GetDogmaDynamicItemsTypeIdItemIdDogmaEffect
     */
    effectId: number;
    /**
     * is_default boolean
     * @type {boolean}
     * @memberof GetDogmaDynamicItemsTypeIdItemIdDogmaEffect
     */
    isDefault: boolean;
}

/**
 * Not found
 * @export
 * @interface GetDogmaDynamicItemsTypeIdItemIdNotFound
 */
export interface GetDogmaDynamicItemsTypeIdItemIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetDogmaDynamicItemsTypeIdItemIdNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetDogmaDynamicItemsTypeIdItemIdOk
 */
export interface GetDogmaDynamicItemsTypeIdItemIdOk {
    /**
     * The ID of the character who created the item
     * @type {number}
     * @memberof GetDogmaDynamicItemsTypeIdItemIdOk
     */
    createdBy: number;
    /**
     * dogma_attributes array
     * @type {Array<GetDogmaDynamicItemsTypeIdItemIdDogmaAttribute>}
     * @memberof GetDogmaDynamicItemsTypeIdItemIdOk
     */
    dogmaAttributes: Array<GetDogmaDynamicItemsTypeIdItemIdDogmaAttribute>;
    /**
     * dogma_effects array
     * @type {Array<GetDogmaDynamicItemsTypeIdItemIdDogmaEffect>}
     * @memberof GetDogmaDynamicItemsTypeIdItemIdOk
     */
    dogmaEffects: Array<GetDogmaDynamicItemsTypeIdItemIdDogmaEffect>;
    /**
     * The type ID of the mutator used to generate the dynamic item.
     * @type {number}
     * @memberof GetDogmaDynamicItemsTypeIdItemIdOk
     */
    mutatorTypeId: number;
    /**
     * The type ID of the source item the mutator was applied to create the dynamic item.
     * @type {number}
     * @memberof GetDogmaDynamicItemsTypeIdItemIdOk
     */
    sourceTypeId: number;
}

/**
 * modifier object
 * @export
 * @interface GetDogmaEffectsEffectIdModifier
 */
export interface GetDogmaEffectsEffectIdModifier {
    /**
     * domain string
     * @type {string}
     * @memberof GetDogmaEffectsEffectIdModifier
     */
    domain?: string;
    /**
     * effect_id integer
     * @type {number}
     * @memberof GetDogmaEffectsEffectIdModifier
     */
    effectId?: number;
    /**
     * func string
     * @type {string}
     * @memberof GetDogmaEffectsEffectIdModifier
     */
    func: string;
    /**
     * modified_attribute_id integer
     * @type {number}
     * @memberof GetDogmaEffectsEffectIdModifier
     */
    modifiedAttributeId?: number;
    /**
     * modifying_attribute_id integer
     * @type {number}
     * @memberof GetDogmaEffectsEffectIdModifier
     */
    modifyingAttributeId?: number;
    /**
     * operator integer
     * @type {number}
     * @memberof GetDogmaEffectsEffectIdModifier
     */
    operator?: number;
}

/**
 * Not found
 * @export
 * @interface GetDogmaEffectsEffectIdNotFound
 */
export interface GetDogmaEffectsEffectIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetDogmaEffectsEffectIdNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetDogmaEffectsEffectIdOk
 */
export interface GetDogmaEffectsEffectIdOk {
    /**
     * description string
     * @type {string}
     * @memberof GetDogmaEffectsEffectIdOk
     */
    description?: string;
    /**
     * disallow_auto_repeat boolean
     * @type {boolean}
     * @memberof GetDogmaEffectsEffectIdOk
     */
    disallowAutoRepeat?: boolean;
    /**
     * discharge_attribute_id integer
     * @type {number}
     * @memberof GetDogmaEffectsEffectIdOk
     */
    dischargeAttributeId?: number;
    /**
     * display_name string
     * @type {string}
     * @memberof GetDogmaEffectsEffectIdOk
     */
    displayName?: string;
    /**
     * duration_attribute_id integer
     * @type {number}
     * @memberof GetDogmaEffectsEffectIdOk
     */
    durationAttributeId?: number;
    /**
     * effect_category integer
     * @type {number}
     * @memberof GetDogmaEffectsEffectIdOk
     */
    effectCategory?: number;
    /**
     * effect_id integer
     * @type {number}
     * @memberof GetDogmaEffectsEffectIdOk
     */
    effectId: number;
    /**
     * electronic_chance boolean
     * @type {boolean}
     * @memberof GetDogmaEffectsEffectIdOk
     */
    electronicChance?: boolean;
    /**
     * falloff_attribute_id integer
     * @type {number}
     * @memberof GetDogmaEffectsEffectIdOk
     */
    falloffAttributeId?: number;
    /**
     * icon_id integer
     * @type {number}
     * @memberof GetDogmaEffectsEffectIdOk
     */
    iconId?: number;
    /**
     * is_assistance boolean
     * @type {boolean}
     * @memberof GetDogmaEffectsEffectIdOk
     */
    isAssistance?: boolean;
    /**
     * is_offensive boolean
     * @type {boolean}
     * @memberof GetDogmaEffectsEffectIdOk
     */
    isOffensive?: boolean;
    /**
     * is_warp_safe boolean
     * @type {boolean}
     * @memberof GetDogmaEffectsEffectIdOk
     */
    isWarpSafe?: boolean;
    /**
     * modifiers array
     * @type {Array<GetDogmaEffectsEffectIdModifier>}
     * @memberof GetDogmaEffectsEffectIdOk
     */
    modifiers?: Array<GetDogmaEffectsEffectIdModifier>;
    /**
     * name string
     * @type {string}
     * @memberof GetDogmaEffectsEffectIdOk
     */
    name?: string;
    /**
     * post_expression integer
     * @type {number}
     * @memberof GetDogmaEffectsEffectIdOk
     */
    postExpression?: number;
    /**
     * pre_expression integer
     * @type {number}
     * @memberof GetDogmaEffectsEffectIdOk
     */
    preExpression?: number;
    /**
     * published boolean
     * @type {boolean}
     * @memberof GetDogmaEffectsEffectIdOk
     */
    published?: boolean;
    /**
     * range_attribute_id integer
     * @type {number}
     * @memberof GetDogmaEffectsEffectIdOk
     */
    rangeAttributeId?: number;
    /**
     * range_chance boolean
     * @type {boolean}
     * @memberof GetDogmaEffectsEffectIdOk
     */
    rangeChance?: boolean;
    /**
     * tracking_speed_attribute_id integer
     * @type {number}
     * @memberof GetDogmaEffectsEffectIdOk
     */
    trackingSpeedAttributeId?: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetFleetsFleetIdMembers200Ok
 */
export interface GetFleetsFleetIdMembers200Ok {
    /**
     * character_id integer
     * @type {number}
     * @memberof GetFleetsFleetIdMembers200Ok
     */
    characterId: number;
    /**
     * join_time string
     * @type {Date}
     * @memberof GetFleetsFleetIdMembers200Ok
     */
    joinTime: Date;
    /**
     * Member’s role in fleet
     * @type {string}
     * @memberof GetFleetsFleetIdMembers200Ok
     */
    role: GetFleetsFleetIdMembers200Ok.RoleEnum;
    /**
     * Localized role names
     * @type {string}
     * @memberof GetFleetsFleetIdMembers200Ok
     */
    roleName: string;
    /**
     * ship_type_id integer
     * @type {number}
     * @memberof GetFleetsFleetIdMembers200Ok
     */
    shipTypeId: number;
    /**
     * Solar system the member is located in
     * @type {number}
     * @memberof GetFleetsFleetIdMembers200Ok
     */
    solarSystemId: number;
    /**
     * ID of the squad the member is in. If not applicable, will be set to -1
     * @type {number}
     * @memberof GetFleetsFleetIdMembers200Ok
     */
    squadId: number;
    /**
     * Station in which the member is docked in, if applicable
     * @type {number}
     * @memberof GetFleetsFleetIdMembers200Ok
     */
    stationId?: number;
    /**
     * Whether the member take fleet warps
     * @type {boolean}
     * @memberof GetFleetsFleetIdMembers200Ok
     */
    takesFleetWarp: boolean;
    /**
     * ID of the wing the member is in. If not applicable, will be set to -1
     * @type {number}
     * @memberof GetFleetsFleetIdMembers200Ok
     */
    wingId: number;
}

/**
 * @export
 * @namespace GetFleetsFleetIdMembers200Ok
 */
export namespace GetFleetsFleetIdMembers200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum RoleEnum {
        FleetCommander = <any> 'fleet_commander',
        WingCommander = <any> 'wing_commander',
        SquadCommander = <any> 'squad_commander',
        SquadMember = <any> 'squad_member'
    }
}

/**
 * Not found
 * @export
 * @interface GetFleetsFleetIdMembersNotFound
 */
export interface GetFleetsFleetIdMembersNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetFleetsFleetIdMembersNotFound
     */
    error?: string;
}

/**
 * Not found
 * @export
 * @interface GetFleetsFleetIdNotFound
 */
export interface GetFleetsFleetIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetFleetsFleetIdNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetFleetsFleetIdOk
 */
export interface GetFleetsFleetIdOk {
    /**
     * Is free-move enabled
     * @type {boolean}
     * @memberof GetFleetsFleetIdOk
     */
    isFreeMove: boolean;
    /**
     * Does the fleet have an active fleet advertisement
     * @type {boolean}
     * @memberof GetFleetsFleetIdOk
     */
    isRegistered: boolean;
    /**
     * Is EVE Voice enabled
     * @type {boolean}
     * @memberof GetFleetsFleetIdOk
     */
    isVoiceEnabled: boolean;
    /**
     * Fleet MOTD in CCP flavoured HTML
     * @type {string}
     * @memberof GetFleetsFleetIdOk
     */
    motd: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetFleetsFleetIdWings200Ok
 */
export interface GetFleetsFleetIdWings200Ok {
    /**
     * id integer
     * @type {number}
     * @memberof GetFleetsFleetIdWings200Ok
     */
    id: number;
    /**
     * name string
     * @type {string}
     * @memberof GetFleetsFleetIdWings200Ok
     */
    name: string;
    /**
     * squads array
     * @type {Array<GetFleetsFleetIdWingsSquad>}
     * @memberof GetFleetsFleetIdWings200Ok
     */
    squads: Array<GetFleetsFleetIdWingsSquad>;
}

/**
 * Not found
 * @export
 * @interface GetFleetsFleetIdWingsNotFound
 */
export interface GetFleetsFleetIdWingsNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetFleetsFleetIdWingsNotFound
     */
    error?: string;
}

/**
 * squad object
 * @export
 * @interface GetFleetsFleetIdWingsSquad
 */
export interface GetFleetsFleetIdWingsSquad {
    /**
     * id integer
     * @type {number}
     * @memberof GetFleetsFleetIdWingsSquad
     */
    id: number;
    /**
     * name string
     * @type {string}
     * @memberof GetFleetsFleetIdWingsSquad
     */
    name: string;
}

/**
 * active_total object
 * @export
 * @interface GetFwLeaderboardsActiveTotalActiveTotal
 */
export interface GetFwLeaderboardsActiveTotalActiveTotal {
    /**
     * Amount of kills
     * @type {number}
     * @memberof GetFwLeaderboardsActiveTotalActiveTotal
     */
    amount?: number;
    /**
     * faction_id integer
     * @type {number}
     * @memberof GetFwLeaderboardsActiveTotalActiveTotal
     */
    factionId?: number;
}

/**
 * active_total object
 * @export
 * @interface GetFwLeaderboardsActiveTotalActiveTotal1
 */
export interface GetFwLeaderboardsActiveTotalActiveTotal1 {
    /**
     * Amount of victory points
     * @type {number}
     * @memberof GetFwLeaderboardsActiveTotalActiveTotal1
     */
    amount?: number;
    /**
     * faction_id integer
     * @type {number}
     * @memberof GetFwLeaderboardsActiveTotalActiveTotal1
     */
    factionId?: number;
}

/**
 * active_total object
 * @export
 * @interface GetFwLeaderboardsCharactersActiveTotalActiveTotal
 */
export interface GetFwLeaderboardsCharactersActiveTotalActiveTotal {
    /**
     * Amount of kills
     * @type {number}
     * @memberof GetFwLeaderboardsCharactersActiveTotalActiveTotal
     */
    amount?: number;
    /**
     * character_id integer
     * @type {number}
     * @memberof GetFwLeaderboardsCharactersActiveTotalActiveTotal
     */
    characterId?: number;
}

/**
 * active_total object
 * @export
 * @interface GetFwLeaderboardsCharactersActiveTotalActiveTotal1
 */
export interface GetFwLeaderboardsCharactersActiveTotalActiveTotal1 {
    /**
     * Amount of victory points
     * @type {number}
     * @memberof GetFwLeaderboardsCharactersActiveTotalActiveTotal1
     */
    amount?: number;
    /**
     * character_id integer
     * @type {number}
     * @memberof GetFwLeaderboardsCharactersActiveTotalActiveTotal1
     */
    characterId?: number;
}

/**
 * Top 100 rankings of pilots by number of kills from yesterday, last week and in total
 * @export
 * @interface GetFwLeaderboardsCharactersKills
 */
export interface GetFwLeaderboardsCharactersKills {
    /**
     * Top 100 ranking of pilots active in faction warfare by total kills. A pilot is considered \"active\" if they have participated in faction warfare in the past 14 days
     * @type {Array<GetFwLeaderboardsCharactersActiveTotalActiveTotal>}
     * @memberof GetFwLeaderboardsCharactersKills
     */
    activeTotal: Array<GetFwLeaderboardsCharactersActiveTotalActiveTotal>;
    /**
     * Top 100 ranking of pilots by kills in the past week
     * @type {Array<GetFwLeaderboardsCharactersLastWeekLastWeek>}
     * @memberof GetFwLeaderboardsCharactersKills
     */
    lastWeek: Array<GetFwLeaderboardsCharactersLastWeekLastWeek>;
    /**
     * Top 100 ranking of pilots by kills in the past day
     * @type {Array<GetFwLeaderboardsCharactersYesterdayYesterday>}
     * @memberof GetFwLeaderboardsCharactersKills
     */
    yesterday: Array<GetFwLeaderboardsCharactersYesterdayYesterday>;
}

/**
 * last_week object
 * @export
 * @interface GetFwLeaderboardsCharactersLastWeekLastWeek
 */
export interface GetFwLeaderboardsCharactersLastWeekLastWeek {
    /**
     * Amount of kills
     * @type {number}
     * @memberof GetFwLeaderboardsCharactersLastWeekLastWeek
     */
    amount?: number;
    /**
     * character_id integer
     * @type {number}
     * @memberof GetFwLeaderboardsCharactersLastWeekLastWeek
     */
    characterId?: number;
}

/**
 * last_week object
 * @export
 * @interface GetFwLeaderboardsCharactersLastWeekLastWeek1
 */
export interface GetFwLeaderboardsCharactersLastWeekLastWeek1 {
    /**
     * Amount of victory points
     * @type {number}
     * @memberof GetFwLeaderboardsCharactersLastWeekLastWeek1
     */
    amount?: number;
    /**
     * character_id integer
     * @type {number}
     * @memberof GetFwLeaderboardsCharactersLastWeekLastWeek1
     */
    characterId?: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetFwLeaderboardsCharactersOk
 */
export interface GetFwLeaderboardsCharactersOk {
    /**
     * 
     * @type {GetFwLeaderboardsCharactersKills}
     * @memberof GetFwLeaderboardsCharactersOk
     */
    kills: GetFwLeaderboardsCharactersKills;
    /**
     * 
     * @type {GetFwLeaderboardsCharactersVictoryPoints}
     * @memberof GetFwLeaderboardsCharactersOk
     */
    victoryPoints: GetFwLeaderboardsCharactersVictoryPoints;
}

/**
 * Top 100 rankings of pilots by victory points from yesterday, last week and in total
 * @export
 * @interface GetFwLeaderboardsCharactersVictoryPoints
 */
export interface GetFwLeaderboardsCharactersVictoryPoints {
    /**
     * Top 100 ranking of pilots active in faction warfare by total victory points. A pilot is considered \"active\" if they have participated in faction warfare in the past 14 days
     * @type {Array<GetFwLeaderboardsCharactersActiveTotalActiveTotal1>}
     * @memberof GetFwLeaderboardsCharactersVictoryPoints
     */
    activeTotal: Array<GetFwLeaderboardsCharactersActiveTotalActiveTotal1>;
    /**
     * Top 100 ranking of pilots by victory points in the past week
     * @type {Array<GetFwLeaderboardsCharactersLastWeekLastWeek1>}
     * @memberof GetFwLeaderboardsCharactersVictoryPoints
     */
    lastWeek: Array<GetFwLeaderboardsCharactersLastWeekLastWeek1>;
    /**
     * Top 100 ranking of pilots by victory points in the past day
     * @type {Array<GetFwLeaderboardsCharactersYesterdayYesterday1>}
     * @memberof GetFwLeaderboardsCharactersVictoryPoints
     */
    yesterday: Array<GetFwLeaderboardsCharactersYesterdayYesterday1>;
}

/**
 * yesterday object
 * @export
 * @interface GetFwLeaderboardsCharactersYesterdayYesterday
 */
export interface GetFwLeaderboardsCharactersYesterdayYesterday {
    /**
     * Amount of kills
     * @type {number}
     * @memberof GetFwLeaderboardsCharactersYesterdayYesterday
     */
    amount?: number;
    /**
     * character_id integer
     * @type {number}
     * @memberof GetFwLeaderboardsCharactersYesterdayYesterday
     */
    characterId?: number;
}

/**
 * yesterday object
 * @export
 * @interface GetFwLeaderboardsCharactersYesterdayYesterday1
 */
export interface GetFwLeaderboardsCharactersYesterdayYesterday1 {
    /**
     * Amount of victory points
     * @type {number}
     * @memberof GetFwLeaderboardsCharactersYesterdayYesterday1
     */
    amount?: number;
    /**
     * character_id integer
     * @type {number}
     * @memberof GetFwLeaderboardsCharactersYesterdayYesterday1
     */
    characterId?: number;
}

/**
 * active_total object
 * @export
 * @interface GetFwLeaderboardsCorporationsActiveTotalActiveTotal
 */
export interface GetFwLeaderboardsCorporationsActiveTotalActiveTotal {
    /**
     * Amount of kills
     * @type {number}
     * @memberof GetFwLeaderboardsCorporationsActiveTotalActiveTotal
     */
    amount?: number;
    /**
     * corporation_id integer
     * @type {number}
     * @memberof GetFwLeaderboardsCorporationsActiveTotalActiveTotal
     */
    corporationId?: number;
}

/**
 * active_total object
 * @export
 * @interface GetFwLeaderboardsCorporationsActiveTotalActiveTotal1
 */
export interface GetFwLeaderboardsCorporationsActiveTotalActiveTotal1 {
    /**
     * Amount of victory points
     * @type {number}
     * @memberof GetFwLeaderboardsCorporationsActiveTotalActiveTotal1
     */
    amount?: number;
    /**
     * corporation_id integer
     * @type {number}
     * @memberof GetFwLeaderboardsCorporationsActiveTotalActiveTotal1
     */
    corporationId?: number;
}

/**
 * Top 10 rankings of corporations by number of kills from yesterday, last week and in total
 * @export
 * @interface GetFwLeaderboardsCorporationsKills
 */
export interface GetFwLeaderboardsCorporationsKills {
    /**
     * Top 10 ranking of corporations active in faction warfare by total kills. A corporation is considered \"active\" if they have participated in faction warfare in the past 14 days
     * @type {Array<GetFwLeaderboardsCorporationsActiveTotalActiveTotal>}
     * @memberof GetFwLeaderboardsCorporationsKills
     */
    activeTotal: Array<GetFwLeaderboardsCorporationsActiveTotalActiveTotal>;
    /**
     * Top 10 ranking of corporations by kills in the past week
     * @type {Array<GetFwLeaderboardsCorporationsLastWeekLastWeek>}
     * @memberof GetFwLeaderboardsCorporationsKills
     */
    lastWeek: Array<GetFwLeaderboardsCorporationsLastWeekLastWeek>;
    /**
     * Top 10 ranking of corporations by kills in the past day
     * @type {Array<GetFwLeaderboardsCorporationsYesterdayYesterday>}
     * @memberof GetFwLeaderboardsCorporationsKills
     */
    yesterday: Array<GetFwLeaderboardsCorporationsYesterdayYesterday>;
}

/**
 * last_week object
 * @export
 * @interface GetFwLeaderboardsCorporationsLastWeekLastWeek
 */
export interface GetFwLeaderboardsCorporationsLastWeekLastWeek {
    /**
     * Amount of kills
     * @type {number}
     * @memberof GetFwLeaderboardsCorporationsLastWeekLastWeek
     */
    amount?: number;
    /**
     * corporation_id integer
     * @type {number}
     * @memberof GetFwLeaderboardsCorporationsLastWeekLastWeek
     */
    corporationId?: number;
}

/**
 * last_week object
 * @export
 * @interface GetFwLeaderboardsCorporationsLastWeekLastWeek1
 */
export interface GetFwLeaderboardsCorporationsLastWeekLastWeek1 {
    /**
     * Amount of victory points
     * @type {number}
     * @memberof GetFwLeaderboardsCorporationsLastWeekLastWeek1
     */
    amount?: number;
    /**
     * corporation_id integer
     * @type {number}
     * @memberof GetFwLeaderboardsCorporationsLastWeekLastWeek1
     */
    corporationId?: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetFwLeaderboardsCorporationsOk
 */
export interface GetFwLeaderboardsCorporationsOk {
    /**
     * 
     * @type {GetFwLeaderboardsCorporationsKills}
     * @memberof GetFwLeaderboardsCorporationsOk
     */
    kills: GetFwLeaderboardsCorporationsKills;
    /**
     * 
     * @type {GetFwLeaderboardsCorporationsVictoryPoints}
     * @memberof GetFwLeaderboardsCorporationsOk
     */
    victoryPoints: GetFwLeaderboardsCorporationsVictoryPoints;
}

/**
 * Top 10 rankings of corporations by victory points from yesterday, last week and in total
 * @export
 * @interface GetFwLeaderboardsCorporationsVictoryPoints
 */
export interface GetFwLeaderboardsCorporationsVictoryPoints {
    /**
     * Top 10 ranking of corporations active in faction warfare by total victory points. A corporation is considered \"active\" if they have participated in faction warfare in the past 14 days
     * @type {Array<GetFwLeaderboardsCorporationsActiveTotalActiveTotal1>}
     * @memberof GetFwLeaderboardsCorporationsVictoryPoints
     */
    activeTotal: Array<GetFwLeaderboardsCorporationsActiveTotalActiveTotal1>;
    /**
     * Top 10 ranking of corporations by victory points in the past week
     * @type {Array<GetFwLeaderboardsCorporationsLastWeekLastWeek1>}
     * @memberof GetFwLeaderboardsCorporationsVictoryPoints
     */
    lastWeek: Array<GetFwLeaderboardsCorporationsLastWeekLastWeek1>;
    /**
     * Top 10 ranking of corporations by victory points in the past day
     * @type {Array<GetFwLeaderboardsCorporationsYesterdayYesterday1>}
     * @memberof GetFwLeaderboardsCorporationsVictoryPoints
     */
    yesterday: Array<GetFwLeaderboardsCorporationsYesterdayYesterday1>;
}

/**
 * yesterday object
 * @export
 * @interface GetFwLeaderboardsCorporationsYesterdayYesterday
 */
export interface GetFwLeaderboardsCorporationsYesterdayYesterday {
    /**
     * Amount of kills
     * @type {number}
     * @memberof GetFwLeaderboardsCorporationsYesterdayYesterday
     */
    amount?: number;
    /**
     * corporation_id integer
     * @type {number}
     * @memberof GetFwLeaderboardsCorporationsYesterdayYesterday
     */
    corporationId?: number;
}

/**
 * yesterday object
 * @export
 * @interface GetFwLeaderboardsCorporationsYesterdayYesterday1
 */
export interface GetFwLeaderboardsCorporationsYesterdayYesterday1 {
    /**
     * Amount of victory points
     * @type {number}
     * @memberof GetFwLeaderboardsCorporationsYesterdayYesterday1
     */
    amount?: number;
    /**
     * corporation_id integer
     * @type {number}
     * @memberof GetFwLeaderboardsCorporationsYesterdayYesterday1
     */
    corporationId?: number;
}

/**
 * Top 4 rankings of factions by number of kills from yesterday, last week and in total
 * @export
 * @interface GetFwLeaderboardsKills
 */
export interface GetFwLeaderboardsKills {
    /**
     * Top 4 ranking of factions active in faction warfare by total kills. A faction is considered \"active\" if they have participated in faction warfare in the past 14 days
     * @type {Array<GetFwLeaderboardsActiveTotalActiveTotal>}
     * @memberof GetFwLeaderboardsKills
     */
    activeTotal: Array<GetFwLeaderboardsActiveTotalActiveTotal>;
    /**
     * Top 4 ranking of factions by kills in the past week
     * @type {Array<GetFwLeaderboardsLastWeekLastWeek>}
     * @memberof GetFwLeaderboardsKills
     */
    lastWeek: Array<GetFwLeaderboardsLastWeekLastWeek>;
    /**
     * Top 4 ranking of factions by kills in the past day
     * @type {Array<GetFwLeaderboardsYesterdayYesterday>}
     * @memberof GetFwLeaderboardsKills
     */
    yesterday: Array<GetFwLeaderboardsYesterdayYesterday>;
}

/**
 * last_week object
 * @export
 * @interface GetFwLeaderboardsLastWeekLastWeek
 */
export interface GetFwLeaderboardsLastWeekLastWeek {
    /**
     * Amount of kills
     * @type {number}
     * @memberof GetFwLeaderboardsLastWeekLastWeek
     */
    amount?: number;
    /**
     * faction_id integer
     * @type {number}
     * @memberof GetFwLeaderboardsLastWeekLastWeek
     */
    factionId?: number;
}

/**
 * last_week object
 * @export
 * @interface GetFwLeaderboardsLastWeekLastWeek1
 */
export interface GetFwLeaderboardsLastWeekLastWeek1 {
    /**
     * Amount of victory points
     * @type {number}
     * @memberof GetFwLeaderboardsLastWeekLastWeek1
     */
    amount?: number;
    /**
     * faction_id integer
     * @type {number}
     * @memberof GetFwLeaderboardsLastWeekLastWeek1
     */
    factionId?: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetFwLeaderboardsOk
 */
export interface GetFwLeaderboardsOk {
    /**
     * 
     * @type {GetFwLeaderboardsKills}
     * @memberof GetFwLeaderboardsOk
     */
    kills: GetFwLeaderboardsKills;
    /**
     * 
     * @type {GetFwLeaderboardsVictoryPoints}
     * @memberof GetFwLeaderboardsOk
     */
    victoryPoints: GetFwLeaderboardsVictoryPoints;
}

/**
 * Top 4 rankings of factions by victory points from yesterday, last week and in total
 * @export
 * @interface GetFwLeaderboardsVictoryPoints
 */
export interface GetFwLeaderboardsVictoryPoints {
    /**
     * Top 4 ranking of factions active in faction warfare by total victory points. A faction is considered \"active\" if they have participated in faction warfare in the past 14 days
     * @type {Array<GetFwLeaderboardsActiveTotalActiveTotal1>}
     * @memberof GetFwLeaderboardsVictoryPoints
     */
    activeTotal: Array<GetFwLeaderboardsActiveTotalActiveTotal1>;
    /**
     * Top 4 ranking of factions by victory points in the past week
     * @type {Array<GetFwLeaderboardsLastWeekLastWeek1>}
     * @memberof GetFwLeaderboardsVictoryPoints
     */
    lastWeek: Array<GetFwLeaderboardsLastWeekLastWeek1>;
    /**
     * Top 4 ranking of factions by victory points in the past day
     * @type {Array<GetFwLeaderboardsYesterdayYesterday1>}
     * @memberof GetFwLeaderboardsVictoryPoints
     */
    yesterday: Array<GetFwLeaderboardsYesterdayYesterday1>;
}

/**
 * yesterday object
 * @export
 * @interface GetFwLeaderboardsYesterdayYesterday
 */
export interface GetFwLeaderboardsYesterdayYesterday {
    /**
     * Amount of kills
     * @type {number}
     * @memberof GetFwLeaderboardsYesterdayYesterday
     */
    amount?: number;
    /**
     * faction_id integer
     * @type {number}
     * @memberof GetFwLeaderboardsYesterdayYesterday
     */
    factionId?: number;
}

/**
 * yesterday object
 * @export
 * @interface GetFwLeaderboardsYesterdayYesterday1
 */
export interface GetFwLeaderboardsYesterdayYesterday1 {
    /**
     * Amount of victory points
     * @type {number}
     * @memberof GetFwLeaderboardsYesterdayYesterday1
     */
    amount?: number;
    /**
     * faction_id integer
     * @type {number}
     * @memberof GetFwLeaderboardsYesterdayYesterday1
     */
    factionId?: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetFwStats200Ok
 */
export interface GetFwStats200Ok {
    /**
     * faction_id integer
     * @type {number}
     * @memberof GetFwStats200Ok
     */
    factionId: number;
    /**
     * 
     * @type {GetFwStatsKills}
     * @memberof GetFwStats200Ok
     */
    kills: GetFwStatsKills;
    /**
     * How many pilots fight for the given faction
     * @type {number}
     * @memberof GetFwStats200Ok
     */
    pilots: number;
    /**
     * The number of solar systems controlled by the given faction
     * @type {number}
     * @memberof GetFwStats200Ok
     */
    systemsControlled: number;
    /**
     * 
     * @type {GetFwStatsVictoryPoints}
     * @memberof GetFwStats200Ok
     */
    victoryPoints: GetFwStatsVictoryPoints;
}

/**
 * Summary of kills against an enemy faction for the given faction
 * @export
 * @interface GetFwStatsKills
 */
export interface GetFwStatsKills {
    /**
     * Last week's total number of kills against enemy factions
     * @type {number}
     * @memberof GetFwStatsKills
     */
    lastWeek: number;
    /**
     * Total number of kills against enemy factions since faction warfare began
     * @type {number}
     * @memberof GetFwStatsKills
     */
    total: number;
    /**
     * Yesterday's total number of kills against enemy factions
     * @type {number}
     * @memberof GetFwStatsKills
     */
    yesterday: number;
}

/**
 * Summary of victory points gained for the given faction
 * @export
 * @interface GetFwStatsVictoryPoints
 */
export interface GetFwStatsVictoryPoints {
    /**
     * Last week's victory points gained
     * @type {number}
     * @memberof GetFwStatsVictoryPoints
     */
    lastWeek: number;
    /**
     * Total victory points gained since faction warfare began
     * @type {number}
     * @memberof GetFwStatsVictoryPoints
     */
    total: number;
    /**
     * Yesterday's victory points gained
     * @type {number}
     * @memberof GetFwStatsVictoryPoints
     */
    yesterday: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetFwSystems200Ok
 */
export interface GetFwSystems200Ok {
    /**
     * contested string
     * @type {string}
     * @memberof GetFwSystems200Ok
     */
    contested: GetFwSystems200Ok.ContestedEnum;
    /**
     * occupier_faction_id integer
     * @type {number}
     * @memberof GetFwSystems200Ok
     */
    occupierFactionId: number;
    /**
     * owner_faction_id integer
     * @type {number}
     * @memberof GetFwSystems200Ok
     */
    ownerFactionId: number;
    /**
     * solar_system_id integer
     * @type {number}
     * @memberof GetFwSystems200Ok
     */
    solarSystemId: number;
    /**
     * victory_points integer
     * @type {number}
     * @memberof GetFwSystems200Ok
     */
    victoryPoints: number;
    /**
     * victory_points_threshold integer
     * @type {number}
     * @memberof GetFwSystems200Ok
     */
    victoryPointsThreshold: number;
}

/**
 * @export
 * @namespace GetFwSystems200Ok
 */
export namespace GetFwSystems200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum ContestedEnum {
        Captured = <any> 'captured',
        Contested = <any> 'contested',
        Uncontested = <any> 'uncontested',
        Vulnerable = <any> 'vulnerable'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetFwWars200Ok
 */
export interface GetFwWars200Ok {
    /**
     * The faction ID of the enemy faction.
     * @type {number}
     * @memberof GetFwWars200Ok
     */
    againstId: number;
    /**
     * faction_id integer
     * @type {number}
     * @memberof GetFwWars200Ok
     */
    factionId: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetIncursions200Ok
 */
export interface GetIncursions200Ok {
    /**
     * The constellation id in which this incursion takes place
     * @type {number}
     * @memberof GetIncursions200Ok
     */
    constellationId: number;
    /**
     * The attacking faction's id
     * @type {number}
     * @memberof GetIncursions200Ok
     */
    factionId: number;
    /**
     * Whether the final encounter has boss or not
     * @type {boolean}
     * @memberof GetIncursions200Ok
     */
    hasBoss: boolean;
    /**
     * A list of infested solar system ids that are a part of this incursion
     * @type {Array<number>}
     * @memberof GetIncursions200Ok
     */
    infestedSolarSystems: Array<number>;
    /**
     * Influence of this incursion as a float from 0 to 1
     * @type {number}
     * @memberof GetIncursions200Ok
     */
    influence: number;
    /**
     * Staging solar system for this incursion
     * @type {number}
     * @memberof GetIncursions200Ok
     */
    stagingSolarSystemId: number;
    /**
     * The state of this incursion
     * @type {string}
     * @memberof GetIncursions200Ok
     */
    state: GetIncursions200Ok.StateEnum;
    /**
     * The type of this incursion
     * @type {string}
     * @memberof GetIncursions200Ok
     */
    type: string;
}

/**
 * @export
 * @namespace GetIncursions200Ok
 */
export namespace GetIncursions200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        Withdrawing = <any> 'withdrawing',
        Mobilizing = <any> 'mobilizing',
        Established = <any> 'established'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetIndustryFacilities200Ok
 */
export interface GetIndustryFacilities200Ok {
    /**
     * ID of the facility
     * @type {number}
     * @memberof GetIndustryFacilities200Ok
     */
    facilityId: number;
    /**
     * Owner of the facility
     * @type {number}
     * @memberof GetIndustryFacilities200Ok
     */
    ownerId: number;
    /**
     * Region ID where the facility is
     * @type {number}
     * @memberof GetIndustryFacilities200Ok
     */
    regionId: number;
    /**
     * Solar system ID where the facility is
     * @type {number}
     * @memberof GetIndustryFacilities200Ok
     */
    solarSystemId: number;
    /**
     * Tax imposed by the facility
     * @type {number}
     * @memberof GetIndustryFacilities200Ok
     */
    tax?: number;
    /**
     * Type ID of the facility
     * @type {number}
     * @memberof GetIndustryFacilities200Ok
     */
    typeId: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetIndustrySystems200Ok
 */
export interface GetIndustrySystems200Ok {
    /**
     * cost_indices array
     * @type {Array<GetIndustrySystemsCostIndice>}
     * @memberof GetIndustrySystems200Ok
     */
    costIndices: Array<GetIndustrySystemsCostIndice>;
    /**
     * solar_system_id integer
     * @type {number}
     * @memberof GetIndustrySystems200Ok
     */
    solarSystemId: number;
}

/**
 * cost_indice object
 * @export
 * @interface GetIndustrySystemsCostIndice
 */
export interface GetIndustrySystemsCostIndice {
    /**
     * activity string
     * @type {string}
     * @memberof GetIndustrySystemsCostIndice
     */
    activity: GetIndustrySystemsCostIndice.ActivityEnum;
    /**
     * cost_index number
     * @type {number}
     * @memberof GetIndustrySystemsCostIndice
     */
    costIndex: number;
}

/**
 * @export
 * @namespace GetIndustrySystemsCostIndice
 */
export namespace GetIndustrySystemsCostIndice {
    /**
     * @export
     * @enum {string}
     */
    export enum ActivityEnum {
        Copying = <any> 'copying',
        Duplicating = <any> 'duplicating',
        Invention = <any> 'invention',
        Manufacturing = <any> 'manufacturing',
        None = <any> 'none',
        Reaction = <any> 'reaction',
        ResearchingMaterialEfficiency = <any> 'researching_material_efficiency',
        ResearchingTechnology = <any> 'researching_technology',
        ResearchingTimeEfficiency = <any> 'researching_time_efficiency',
        ReverseEngineering = <any> 'reverse_engineering'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetInsurancePrices200Ok
 */
export interface GetInsurancePrices200Ok {
    /**
     * A list of a available insurance levels for this ship type
     * @type {Array<GetInsurancePricesLevel>}
     * @memberof GetInsurancePrices200Ok
     */
    levels: Array<GetInsurancePricesLevel>;
    /**
     * type_id integer
     * @type {number}
     * @memberof GetInsurancePrices200Ok
     */
    typeId: number;
}

/**
 * level object
 * @export
 * @interface GetInsurancePricesLevel
 */
export interface GetInsurancePricesLevel {
    /**
     * cost number
     * @type {number}
     * @memberof GetInsurancePricesLevel
     */
    cost: number;
    /**
     * Localized insurance level
     * @type {string}
     * @memberof GetInsurancePricesLevel
     */
    name: string;
    /**
     * payout number
     * @type {number}
     * @memberof GetInsurancePricesLevel
     */
    payout: number;
}

/**
 * attacker object
 * @export
 * @interface GetKillmailsKillmailIdKillmailHashAttacker
 */
export interface GetKillmailsKillmailIdKillmailHashAttacker {
    /**
     * alliance_id integer
     * @type {number}
     * @memberof GetKillmailsKillmailIdKillmailHashAttacker
     */
    allianceId?: number;
    /**
     * character_id integer
     * @type {number}
     * @memberof GetKillmailsKillmailIdKillmailHashAttacker
     */
    characterId?: number;
    /**
     * corporation_id integer
     * @type {number}
     * @memberof GetKillmailsKillmailIdKillmailHashAttacker
     */
    corporationId?: number;
    /**
     * damage_done integer
     * @type {number}
     * @memberof GetKillmailsKillmailIdKillmailHashAttacker
     */
    damageDone: number;
    /**
     * faction_id integer
     * @type {number}
     * @memberof GetKillmailsKillmailIdKillmailHashAttacker
     */
    factionId?: number;
    /**
     * Was the attacker the one to achieve the final blow 
     * @type {boolean}
     * @memberof GetKillmailsKillmailIdKillmailHashAttacker
     */
    finalBlow: boolean;
    /**
     * Security status for the attacker 
     * @type {number}
     * @memberof GetKillmailsKillmailIdKillmailHashAttacker
     */
    securityStatus: number;
    /**
     * What ship was the attacker flying 
     * @type {number}
     * @memberof GetKillmailsKillmailIdKillmailHashAttacker
     */
    shipTypeId?: number;
    /**
     * What weapon was used by the attacker for the kill 
     * @type {number}
     * @memberof GetKillmailsKillmailIdKillmailHashAttacker
     */
    weaponTypeId?: number;
}

/**
 * item object
 * @export
 * @interface GetKillmailsKillmailIdKillmailHashItem
 */
export interface GetKillmailsKillmailIdKillmailHashItem {
    /**
     * Flag for the location of the item 
     * @type {number}
     * @memberof GetKillmailsKillmailIdKillmailHashItem
     */
    flag: number;
    /**
     * item_type_id integer
     * @type {number}
     * @memberof GetKillmailsKillmailIdKillmailHashItem
     */
    itemTypeId: number;
    /**
     * items array
     * @type {Array<GetKillmailsKillmailIdKillmailHashItemsItem>}
     * @memberof GetKillmailsKillmailIdKillmailHashItem
     */
    items?: Array<GetKillmailsKillmailIdKillmailHashItemsItem>;
    /**
     * How many of the item were destroyed if any 
     * @type {number}
     * @memberof GetKillmailsKillmailIdKillmailHashItem
     */
    quantityDestroyed?: number;
    /**
     * How many of the item were dropped if any 
     * @type {number}
     * @memberof GetKillmailsKillmailIdKillmailHashItem
     */
    quantityDropped?: number;
    /**
     * singleton integer
     * @type {number}
     * @memberof GetKillmailsKillmailIdKillmailHashItem
     */
    singleton: number;
}

/**
 * item object
 * @export
 * @interface GetKillmailsKillmailIdKillmailHashItemsItem
 */
export interface GetKillmailsKillmailIdKillmailHashItemsItem {
    /**
     * flag integer
     * @type {number}
     * @memberof GetKillmailsKillmailIdKillmailHashItemsItem
     */
    flag: number;
    /**
     * item_type_id integer
     * @type {number}
     * @memberof GetKillmailsKillmailIdKillmailHashItemsItem
     */
    itemTypeId: number;
    /**
     * quantity_destroyed integer
     * @type {number}
     * @memberof GetKillmailsKillmailIdKillmailHashItemsItem
     */
    quantityDestroyed?: number;
    /**
     * quantity_dropped integer
     * @type {number}
     * @memberof GetKillmailsKillmailIdKillmailHashItemsItem
     */
    quantityDropped?: number;
    /**
     * singleton integer
     * @type {number}
     * @memberof GetKillmailsKillmailIdKillmailHashItemsItem
     */
    singleton: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetKillmailsKillmailIdKillmailHashOk
 */
export interface GetKillmailsKillmailIdKillmailHashOk {
    /**
     * attackers array
     * @type {Array<GetKillmailsKillmailIdKillmailHashAttacker>}
     * @memberof GetKillmailsKillmailIdKillmailHashOk
     */
    attackers: Array<GetKillmailsKillmailIdKillmailHashAttacker>;
    /**
     * ID of the killmail
     * @type {number}
     * @memberof GetKillmailsKillmailIdKillmailHashOk
     */
    killmailId: number;
    /**
     * Time that the victim was killed and the killmail generated 
     * @type {Date}
     * @memberof GetKillmailsKillmailIdKillmailHashOk
     */
    killmailTime: Date;
    /**
     * Moon if the kill took place at one
     * @type {number}
     * @memberof GetKillmailsKillmailIdKillmailHashOk
     */
    moonId?: number;
    /**
     * Solar system that the kill took place in 
     * @type {number}
     * @memberof GetKillmailsKillmailIdKillmailHashOk
     */
    solarSystemId: number;
    /**
     * 
     * @type {GetKillmailsKillmailIdKillmailHashVictim}
     * @memberof GetKillmailsKillmailIdKillmailHashOk
     */
    victim: GetKillmailsKillmailIdKillmailHashVictim;
    /**
     * War if the killmail is generated in relation to an official war 
     * @type {number}
     * @memberof GetKillmailsKillmailIdKillmailHashOk
     */
    warId?: number;
}

/**
 * Coordinates of the victim in Cartesian space relative to the Sun 
 * @export
 * @interface GetKillmailsKillmailIdKillmailHashPosition
 */
export interface GetKillmailsKillmailIdKillmailHashPosition {
    /**
     * x number
     * @type {number}
     * @memberof GetKillmailsKillmailIdKillmailHashPosition
     */
    x: number;
    /**
     * y number
     * @type {number}
     * @memberof GetKillmailsKillmailIdKillmailHashPosition
     */
    y: number;
    /**
     * z number
     * @type {number}
     * @memberof GetKillmailsKillmailIdKillmailHashPosition
     */
    z: number;
}

/**
 * Unprocessable entity
 * @export
 * @interface GetKillmailsKillmailIdKillmailHashUnprocessableEntity
 */
export interface GetKillmailsKillmailIdKillmailHashUnprocessableEntity {
    /**
     * Unprocessable entity message
     * @type {string}
     * @memberof GetKillmailsKillmailIdKillmailHashUnprocessableEntity
     */
    error?: string;
}

/**
 * victim object
 * @export
 * @interface GetKillmailsKillmailIdKillmailHashVictim
 */
export interface GetKillmailsKillmailIdKillmailHashVictim {
    /**
     * alliance_id integer
     * @type {number}
     * @memberof GetKillmailsKillmailIdKillmailHashVictim
     */
    allianceId?: number;
    /**
     * character_id integer
     * @type {number}
     * @memberof GetKillmailsKillmailIdKillmailHashVictim
     */
    characterId?: number;
    /**
     * corporation_id integer
     * @type {number}
     * @memberof GetKillmailsKillmailIdKillmailHashVictim
     */
    corporationId?: number;
    /**
     * How much total damage was taken by the victim 
     * @type {number}
     * @memberof GetKillmailsKillmailIdKillmailHashVictim
     */
    damageTaken: number;
    /**
     * faction_id integer
     * @type {number}
     * @memberof GetKillmailsKillmailIdKillmailHashVictim
     */
    factionId?: number;
    /**
     * items array
     * @type {Array<GetKillmailsKillmailIdKillmailHashItem>}
     * @memberof GetKillmailsKillmailIdKillmailHashVictim
     */
    items?: Array<GetKillmailsKillmailIdKillmailHashItem>;
    /**
     * 
     * @type {GetKillmailsKillmailIdKillmailHashPosition}
     * @memberof GetKillmailsKillmailIdKillmailHashVictim
     */
    position?: GetKillmailsKillmailIdKillmailHashPosition;
    /**
     * The ship that the victim was piloting and was destroyed 
     * @type {number}
     * @memberof GetKillmailsKillmailIdKillmailHashVictim
     */
    shipTypeId: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetLoyaltyStoresCorporationIdOffers200Ok
 */
export interface GetLoyaltyStoresCorporationIdOffers200Ok {
    /**
     * Analysis kredit cost
     * @type {number}
     * @memberof GetLoyaltyStoresCorporationIdOffers200Ok
     */
    akCost?: number;
    /**
     * isk_cost integer
     * @type {number}
     * @memberof GetLoyaltyStoresCorporationIdOffers200Ok
     */
    iskCost: number;
    /**
     * lp_cost integer
     * @type {number}
     * @memberof GetLoyaltyStoresCorporationIdOffers200Ok
     */
    lpCost: number;
    /**
     * offer_id integer
     * @type {number}
     * @memberof GetLoyaltyStoresCorporationIdOffers200Ok
     */
    offerId: number;
    /**
     * quantity integer
     * @type {number}
     * @memberof GetLoyaltyStoresCorporationIdOffers200Ok
     */
    quantity: number;
    /**
     * required_items array
     * @type {Array<GetLoyaltyStoresCorporationIdOffersRequiredItem>}
     * @memberof GetLoyaltyStoresCorporationIdOffers200Ok
     */
    requiredItems: Array<GetLoyaltyStoresCorporationIdOffersRequiredItem>;
    /**
     * type_id integer
     * @type {number}
     * @memberof GetLoyaltyStoresCorporationIdOffers200Ok
     */
    typeId: number;
}

/**
 * Not found
 * @export
 * @interface GetLoyaltyStoresCorporationIdOffersNotFound
 */
export interface GetLoyaltyStoresCorporationIdOffersNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetLoyaltyStoresCorporationIdOffersNotFound
     */
    error?: string;
}

/**
 * required_item object
 * @export
 * @interface GetLoyaltyStoresCorporationIdOffersRequiredItem
 */
export interface GetLoyaltyStoresCorporationIdOffersRequiredItem {
    /**
     * quantity integer
     * @type {number}
     * @memberof GetLoyaltyStoresCorporationIdOffersRequiredItem
     */
    quantity: number;
    /**
     * type_id integer
     * @type {number}
     * @memberof GetLoyaltyStoresCorporationIdOffersRequiredItem
     */
    typeId: number;
}

/**
 * Not found
 * @export
 * @interface GetMarketsGroupsMarketGroupIdNotFound
 */
export interface GetMarketsGroupsMarketGroupIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetMarketsGroupsMarketGroupIdNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetMarketsGroupsMarketGroupIdOk
 */
export interface GetMarketsGroupsMarketGroupIdOk {
    /**
     * description string
     * @type {string}
     * @memberof GetMarketsGroupsMarketGroupIdOk
     */
    description: string;
    /**
     * market_group_id integer
     * @type {number}
     * @memberof GetMarketsGroupsMarketGroupIdOk
     */
    marketGroupId: number;
    /**
     * name string
     * @type {string}
     * @memberof GetMarketsGroupsMarketGroupIdOk
     */
    name: string;
    /**
     * parent_group_id integer
     * @type {number}
     * @memberof GetMarketsGroupsMarketGroupIdOk
     */
    parentGroupId?: number;
    /**
     * types array
     * @type {Array<number>}
     * @memberof GetMarketsGroupsMarketGroupIdOk
     */
    types: Array<number>;
}

/**
 * 200 ok object
 * @export
 * @interface GetMarketsPrices200Ok
 */
export interface GetMarketsPrices200Ok {
    /**
     * adjusted_price number
     * @type {number}
     * @memberof GetMarketsPrices200Ok
     */
    adjustedPrice?: number;
    /**
     * average_price number
     * @type {number}
     * @memberof GetMarketsPrices200Ok
     */
    averagePrice?: number;
    /**
     * type_id integer
     * @type {number}
     * @memberof GetMarketsPrices200Ok
     */
    typeId: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetMarketsRegionIdHistory200Ok
 */
export interface GetMarketsRegionIdHistory200Ok {
    /**
     * average number
     * @type {number}
     * @memberof GetMarketsRegionIdHistory200Ok
     */
    average: number;
    /**
     * The date of this historical statistic entry
     * @type {string}
     * @memberof GetMarketsRegionIdHistory200Ok
     */
    date: string;
    /**
     * highest number
     * @type {number}
     * @memberof GetMarketsRegionIdHistory200Ok
     */
    highest: number;
    /**
     * lowest number
     * @type {number}
     * @memberof GetMarketsRegionIdHistory200Ok
     */
    lowest: number;
    /**
     * Total number of orders happened that day
     * @type {number}
     * @memberof GetMarketsRegionIdHistory200Ok
     */
    orderCount: number;
    /**
     * Total
     * @type {number}
     * @memberof GetMarketsRegionIdHistory200Ok
     */
    volume: number;
}

/**
 * Error 520
 * @export
 * @interface GetMarketsRegionIdHistoryError520
 */
export interface GetMarketsRegionIdHistoryError520 {
    /**
     * Error 520 message
     * @type {string}
     * @memberof GetMarketsRegionIdHistoryError520
     */
    error?: string;
}

/**
 * Not found
 * @export
 * @interface GetMarketsRegionIdHistoryNotFound
 */
export interface GetMarketsRegionIdHistoryNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetMarketsRegionIdHistoryNotFound
     */
    error?: string;
}

/**
 * Unprocessable entity
 * @export
 * @interface GetMarketsRegionIdHistoryUnprocessableEntity
 */
export interface GetMarketsRegionIdHistoryUnprocessableEntity {
    /**
     * Unprocessable entity message
     * @type {string}
     * @memberof GetMarketsRegionIdHistoryUnprocessableEntity
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetMarketsRegionIdOrders200Ok
 */
export interface GetMarketsRegionIdOrders200Ok {
    /**
     * duration integer
     * @type {number}
     * @memberof GetMarketsRegionIdOrders200Ok
     */
    duration: number;
    /**
     * is_buy_order boolean
     * @type {boolean}
     * @memberof GetMarketsRegionIdOrders200Ok
     */
    isBuyOrder: boolean;
    /**
     * issued string
     * @type {Date}
     * @memberof GetMarketsRegionIdOrders200Ok
     */
    issued: Date;
    /**
     * location_id integer
     * @type {number}
     * @memberof GetMarketsRegionIdOrders200Ok
     */
    locationId: number;
    /**
     * min_volume integer
     * @type {number}
     * @memberof GetMarketsRegionIdOrders200Ok
     */
    minVolume: number;
    /**
     * order_id integer
     * @type {number}
     * @memberof GetMarketsRegionIdOrders200Ok
     */
    orderId: number;
    /**
     * price number
     * @type {number}
     * @memberof GetMarketsRegionIdOrders200Ok
     */
    price: number;
    /**
     * range string
     * @type {string}
     * @memberof GetMarketsRegionIdOrders200Ok
     */
    range: GetMarketsRegionIdOrders200Ok.RangeEnum;
    /**
     * The solar system this order was placed
     * @type {number}
     * @memberof GetMarketsRegionIdOrders200Ok
     */
    systemId: number;
    /**
     * type_id integer
     * @type {number}
     * @memberof GetMarketsRegionIdOrders200Ok
     */
    typeId: number;
    /**
     * volume_remain integer
     * @type {number}
     * @memberof GetMarketsRegionIdOrders200Ok
     */
    volumeRemain: number;
    /**
     * volume_total integer
     * @type {number}
     * @memberof GetMarketsRegionIdOrders200Ok
     */
    volumeTotal: number;
}

/**
 * @export
 * @namespace GetMarketsRegionIdOrders200Ok
 */
export namespace GetMarketsRegionIdOrders200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum RangeEnum {
        Station = <any> 'station',
        Region = <any> 'region',
        Solarsystem = <any> 'solarsystem',
        _1 = <any> '1',
        _2 = <any> '2',
        _3 = <any> '3',
        _4 = <any> '4',
        _5 = <any> '5',
        _10 = <any> '10',
        _20 = <any> '20',
        _30 = <any> '30',
        _40 = <any> '40'
    }
}

/**
 * Not found
 * @export
 * @interface GetMarketsRegionIdOrdersNotFound
 */
export interface GetMarketsRegionIdOrdersNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetMarketsRegionIdOrdersNotFound
     */
    error?: string;
}

/**
 * Unprocessable entity
 * @export
 * @interface GetMarketsRegionIdOrdersUnprocessableEntity
 */
export interface GetMarketsRegionIdOrdersUnprocessableEntity {
    /**
     * Unprocessable entity message
     * @type {string}
     * @memberof GetMarketsRegionIdOrdersUnprocessableEntity
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetMarketsStructuresStructureId200Ok
 */
export interface GetMarketsStructuresStructureId200Ok {
    /**
     * duration integer
     * @type {number}
     * @memberof GetMarketsStructuresStructureId200Ok
     */
    duration: number;
    /**
     * is_buy_order boolean
     * @type {boolean}
     * @memberof GetMarketsStructuresStructureId200Ok
     */
    isBuyOrder: boolean;
    /**
     * issued string
     * @type {Date}
     * @memberof GetMarketsStructuresStructureId200Ok
     */
    issued: Date;
    /**
     * location_id integer
     * @type {number}
     * @memberof GetMarketsStructuresStructureId200Ok
     */
    locationId: number;
    /**
     * min_volume integer
     * @type {number}
     * @memberof GetMarketsStructuresStructureId200Ok
     */
    minVolume: number;
    /**
     * order_id integer
     * @type {number}
     * @memberof GetMarketsStructuresStructureId200Ok
     */
    orderId: number;
    /**
     * price number
     * @type {number}
     * @memberof GetMarketsStructuresStructureId200Ok
     */
    price: number;
    /**
     * range string
     * @type {string}
     * @memberof GetMarketsStructuresStructureId200Ok
     */
    range: GetMarketsStructuresStructureId200Ok.RangeEnum;
    /**
     * type_id integer
     * @type {number}
     * @memberof GetMarketsStructuresStructureId200Ok
     */
    typeId: number;
    /**
     * volume_remain integer
     * @type {number}
     * @memberof GetMarketsStructuresStructureId200Ok
     */
    volumeRemain: number;
    /**
     * volume_total integer
     * @type {number}
     * @memberof GetMarketsStructuresStructureId200Ok
     */
    volumeTotal: number;
}

/**
 * @export
 * @namespace GetMarketsStructuresStructureId200Ok
 */
export namespace GetMarketsStructuresStructureId200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum RangeEnum {
        Station = <any> 'station',
        Region = <any> 'region',
        Solarsystem = <any> 'solarsystem',
        _1 = <any> '1',
        _2 = <any> '2',
        _3 = <any> '3',
        _4 = <any> '4',
        _5 = <any> '5',
        _10 = <any> '10',
        _20 = <any> '20',
        _30 = <any> '30',
        _40 = <any> '40'
    }
}

/**
 * 200 ok object
 * @export
 * @interface GetOpportunitiesGroupsGroupIdOk
 */
export interface GetOpportunitiesGroupsGroupIdOk {
    /**
     * The groups that are connected to this group on the opportunities map
     * @type {Array<number>}
     * @memberof GetOpportunitiesGroupsGroupIdOk
     */
    connectedGroups: Array<number>;
    /**
     * description string
     * @type {string}
     * @memberof GetOpportunitiesGroupsGroupIdOk
     */
    description: string;
    /**
     * group_id integer
     * @type {number}
     * @memberof GetOpportunitiesGroupsGroupIdOk
     */
    groupId: number;
    /**
     * name string
     * @type {string}
     * @memberof GetOpportunitiesGroupsGroupIdOk
     */
    name: string;
    /**
     * notification string
     * @type {string}
     * @memberof GetOpportunitiesGroupsGroupIdOk
     */
    notification: string;
    /**
     * Tasks need to complete for this group
     * @type {Array<number>}
     * @memberof GetOpportunitiesGroupsGroupIdOk
     */
    requiredTasks: Array<number>;
}

/**
 * 200 ok object
 * @export
 * @interface GetOpportunitiesTasksTaskIdOk
 */
export interface GetOpportunitiesTasksTaskIdOk {
    /**
     * description string
     * @type {string}
     * @memberof GetOpportunitiesTasksTaskIdOk
     */
    description: string;
    /**
     * name string
     * @type {string}
     * @memberof GetOpportunitiesTasksTaskIdOk
     */
    name: string;
    /**
     * notification string
     * @type {string}
     * @memberof GetOpportunitiesTasksTaskIdOk
     */
    notification: string;
    /**
     * task_id integer
     * @type {number}
     * @memberof GetOpportunitiesTasksTaskIdOk
     */
    taskId: number;
}

/**
 * Not found
 * @export
 * @interface GetRouteOriginDestinationNotFound
 */
export interface GetRouteOriginDestinationNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetRouteOriginDestinationNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetSovereigntyCampaigns200Ok
 */
export interface GetSovereigntyCampaigns200Ok {
    /**
     * Score for all attacking parties, only present in Defense Events. 
     * @type {number}
     * @memberof GetSovereigntyCampaigns200Ok
     */
    attackersScore?: number;
    /**
     * Unique ID for this campaign.
     * @type {number}
     * @memberof GetSovereigntyCampaigns200Ok
     */
    campaignId: number;
    /**
     * The constellation in which the campaign will take place. 
     * @type {number}
     * @memberof GetSovereigntyCampaigns200Ok
     */
    constellationId: number;
    /**
     * Defending alliance, only present in Defense Events 
     * @type {number}
     * @memberof GetSovereigntyCampaigns200Ok
     */
    defenderId?: number;
    /**
     * Score for the defending alliance, only present in Defense Events. 
     * @type {number}
     * @memberof GetSovereigntyCampaigns200Ok
     */
    defenderScore?: number;
    /**
     * Type of event this campaign is for. tcu_defense, ihub_defense and station_defense are referred to as \"Defense Events\", station_freeport as \"Freeport Events\". 
     * @type {string}
     * @memberof GetSovereigntyCampaigns200Ok
     */
    eventType: GetSovereigntyCampaigns200Ok.EventTypeEnum;
    /**
     * Alliance participating and their respective scores, only present in Freeport Events. 
     * @type {Array<GetSovereigntyCampaignsParticipant>}
     * @memberof GetSovereigntyCampaigns200Ok
     */
    participants?: Array<GetSovereigntyCampaignsParticipant>;
    /**
     * The solar system the structure is located in. 
     * @type {number}
     * @memberof GetSovereigntyCampaigns200Ok
     */
    solarSystemId: number;
    /**
     * Time the event is scheduled to start. 
     * @type {Date}
     * @memberof GetSovereigntyCampaigns200Ok
     */
    startTime: Date;
    /**
     * The structure item ID that is related to this campaign. 
     * @type {number}
     * @memberof GetSovereigntyCampaigns200Ok
     */
    structureId: number;
}

/**
 * @export
 * @namespace GetSovereigntyCampaigns200Ok
 */
export namespace GetSovereigntyCampaigns200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum EventTypeEnum {
        TcuDefense = <any> 'tcu_defense',
        IhubDefense = <any> 'ihub_defense',
        StationDefense = <any> 'station_defense',
        StationFreeport = <any> 'station_freeport'
    }
}

/**
 * participant object
 * @export
 * @interface GetSovereigntyCampaignsParticipant
 */
export interface GetSovereigntyCampaignsParticipant {
    /**
     * alliance_id integer
     * @type {number}
     * @memberof GetSovereigntyCampaignsParticipant
     */
    allianceId: number;
    /**
     * score number
     * @type {number}
     * @memberof GetSovereigntyCampaignsParticipant
     */
    score: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetSovereigntyMap200Ok
 */
export interface GetSovereigntyMap200Ok {
    /**
     * alliance_id integer
     * @type {number}
     * @memberof GetSovereigntyMap200Ok
     */
    allianceId?: number;
    /**
     * corporation_id integer
     * @type {number}
     * @memberof GetSovereigntyMap200Ok
     */
    corporationId?: number;
    /**
     * faction_id integer
     * @type {number}
     * @memberof GetSovereigntyMap200Ok
     */
    factionId?: number;
    /**
     * system_id integer
     * @type {number}
     * @memberof GetSovereigntyMap200Ok
     */
    systemId: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetSovereigntyStructures200Ok
 */
export interface GetSovereigntyStructures200Ok {
    /**
     * The alliance that owns the structure. 
     * @type {number}
     * @memberof GetSovereigntyStructures200Ok
     */
    allianceId: number;
    /**
     * Solar system in which the structure is located. 
     * @type {number}
     * @memberof GetSovereigntyStructures200Ok
     */
    solarSystemId: number;
    /**
     * Unique item ID for this structure.
     * @type {number}
     * @memberof GetSovereigntyStructures200Ok
     */
    structureId: number;
    /**
     * A reference to the type of structure this is. 
     * @type {number}
     * @memberof GetSovereigntyStructures200Ok
     */
    structureTypeId: number;
    /**
     * The occupancy level for the next or current vulnerability window. This takes into account all development indexes and capital system bonuses. Also known as Activity Defense Multiplier from in the client. It increases the time that attackers must spend using their entosis links on the structure. 
     * @type {number}
     * @memberof GetSovereigntyStructures200Ok
     */
    vulnerabilityOccupancyLevel?: number;
    /**
     * The time at which the next or current vulnerability window ends. At the end of a vulnerability window the next window is recalculated and locked in along with the vulnerabilityOccupancyLevel. If the structure is not in 100% entosis control of the defender, it will go in to 'overtime' and stay vulnerable for as long as that situation persists. Only once the defenders have 100% entosis control and has the vulnerableEndTime passed does the vulnerability interval expire and a new one is calculated. 
     * @type {Date}
     * @memberof GetSovereigntyStructures200Ok
     */
    vulnerableEndTime?: Date;
    /**
     * The next time at which the structure will become vulnerable. Or the start time of the current window if current time is between this and vulnerableEndTime. 
     * @type {Date}
     * @memberof GetSovereigntyStructures200Ok
     */
    vulnerableStartTime?: Date;
}

/**
 * 200 ok object
 * @export
 * @interface GetStatusOk
 */
export interface GetStatusOk {
    /**
     * Current online player count
     * @type {number}
     * @memberof GetStatusOk
     */
    players: number;
    /**
     * Running version as string
     * @type {string}
     * @memberof GetStatusOk
     */
    serverVersion: string;
    /**
     * Server start timestamp
     * @type {Date}
     * @memberof GetStatusOk
     */
    startTime: Date;
    /**
     * If the server is in VIP mode
     * @type {boolean}
     * @memberof GetStatusOk
     */
    vip?: boolean;
}

/**
 * 200 ok object
 * @export
 * @interface GetUniverseAncestries200Ok
 */
export interface GetUniverseAncestries200Ok {
    /**
     * The bloodline associated with this ancestry
     * @type {number}
     * @memberof GetUniverseAncestries200Ok
     */
    bloodlineId: number;
    /**
     * description string
     * @type {string}
     * @memberof GetUniverseAncestries200Ok
     */
    description: string;
    /**
     * icon_id integer
     * @type {number}
     * @memberof GetUniverseAncestries200Ok
     */
    iconId?: number;
    /**
     * id integer
     * @type {number}
     * @memberof GetUniverseAncestries200Ok
     */
    id: number;
    /**
     * name string
     * @type {string}
     * @memberof GetUniverseAncestries200Ok
     */
    name: string;
    /**
     * short_description string
     * @type {string}
     * @memberof GetUniverseAncestries200Ok
     */
    shortDescription?: string;
}

/**
 * Not found
 * @export
 * @interface GetUniverseAsteroidBeltsAsteroidBeltIdNotFound
 */
export interface GetUniverseAsteroidBeltsAsteroidBeltIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetUniverseAsteroidBeltsAsteroidBeltIdNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetUniverseAsteroidBeltsAsteroidBeltIdOk
 */
export interface GetUniverseAsteroidBeltsAsteroidBeltIdOk {
    /**
     * name string
     * @type {string}
     * @memberof GetUniverseAsteroidBeltsAsteroidBeltIdOk
     */
    name: string;
    /**
     * 
     * @type {GetUniverseAsteroidBeltsAsteroidBeltIdPosition}
     * @memberof GetUniverseAsteroidBeltsAsteroidBeltIdOk
     */
    position: GetUniverseAsteroidBeltsAsteroidBeltIdPosition;
    /**
     * The solar system this asteroid belt is in
     * @type {number}
     * @memberof GetUniverseAsteroidBeltsAsteroidBeltIdOk
     */
    systemId: number;
}

/**
 * position object
 * @export
 * @interface GetUniverseAsteroidBeltsAsteroidBeltIdPosition
 */
export interface GetUniverseAsteroidBeltsAsteroidBeltIdPosition {
    /**
     * x number
     * @type {number}
     * @memberof GetUniverseAsteroidBeltsAsteroidBeltIdPosition
     */
    x: number;
    /**
     * y number
     * @type {number}
     * @memberof GetUniverseAsteroidBeltsAsteroidBeltIdPosition
     */
    y: number;
    /**
     * z number
     * @type {number}
     * @memberof GetUniverseAsteroidBeltsAsteroidBeltIdPosition
     */
    z: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetUniverseBloodlines200Ok
 */
export interface GetUniverseBloodlines200Ok {
    /**
     * bloodline_id integer
     * @type {number}
     * @memberof GetUniverseBloodlines200Ok
     */
    bloodlineId: number;
    /**
     * charisma integer
     * @type {number}
     * @memberof GetUniverseBloodlines200Ok
     */
    charisma: number;
    /**
     * corporation_id integer
     * @type {number}
     * @memberof GetUniverseBloodlines200Ok
     */
    corporationId: number;
    /**
     * description string
     * @type {string}
     * @memberof GetUniverseBloodlines200Ok
     */
    description: string;
    /**
     * intelligence integer
     * @type {number}
     * @memberof GetUniverseBloodlines200Ok
     */
    intelligence: number;
    /**
     * memory integer
     * @type {number}
     * @memberof GetUniverseBloodlines200Ok
     */
    memory: number;
    /**
     * name string
     * @type {string}
     * @memberof GetUniverseBloodlines200Ok
     */
    name: string;
    /**
     * perception integer
     * @type {number}
     * @memberof GetUniverseBloodlines200Ok
     */
    perception: number;
    /**
     * race_id integer
     * @type {number}
     * @memberof GetUniverseBloodlines200Ok
     */
    raceId: number;
    /**
     * ship_type_id integer
     * @type {number}
     * @memberof GetUniverseBloodlines200Ok
     */
    shipTypeId: number;
    /**
     * willpower integer
     * @type {number}
     * @memberof GetUniverseBloodlines200Ok
     */
    willpower: number;
}

/**
 * Not found
 * @export
 * @interface GetUniverseCategoriesCategoryIdNotFound
 */
export interface GetUniverseCategoriesCategoryIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetUniverseCategoriesCategoryIdNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetUniverseCategoriesCategoryIdOk
 */
export interface GetUniverseCategoriesCategoryIdOk {
    /**
     * category_id integer
     * @type {number}
     * @memberof GetUniverseCategoriesCategoryIdOk
     */
    categoryId: number;
    /**
     * groups array
     * @type {Array<number>}
     * @memberof GetUniverseCategoriesCategoryIdOk
     */
    groups: Array<number>;
    /**
     * name string
     * @type {string}
     * @memberof GetUniverseCategoriesCategoryIdOk
     */
    name: string;
    /**
     * published boolean
     * @type {boolean}
     * @memberof GetUniverseCategoriesCategoryIdOk
     */
    published: boolean;
}

/**
 * Not found
 * @export
 * @interface GetUniverseConstellationsConstellationIdNotFound
 */
export interface GetUniverseConstellationsConstellationIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetUniverseConstellationsConstellationIdNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetUniverseConstellationsConstellationIdOk
 */
export interface GetUniverseConstellationsConstellationIdOk {
    /**
     * constellation_id integer
     * @type {number}
     * @memberof GetUniverseConstellationsConstellationIdOk
     */
    constellationId: number;
    /**
     * name string
     * @type {string}
     * @memberof GetUniverseConstellationsConstellationIdOk
     */
    name: string;
    /**
     * 
     * @type {GetUniverseConstellationsConstellationIdPosition}
     * @memberof GetUniverseConstellationsConstellationIdOk
     */
    position: GetUniverseConstellationsConstellationIdPosition;
    /**
     * The region this constellation is in
     * @type {number}
     * @memberof GetUniverseConstellationsConstellationIdOk
     */
    regionId: number;
    /**
     * systems array
     * @type {Array<number>}
     * @memberof GetUniverseConstellationsConstellationIdOk
     */
    systems: Array<number>;
}

/**
 * position object
 * @export
 * @interface GetUniverseConstellationsConstellationIdPosition
 */
export interface GetUniverseConstellationsConstellationIdPosition {
    /**
     * x number
     * @type {number}
     * @memberof GetUniverseConstellationsConstellationIdPosition
     */
    x: number;
    /**
     * y number
     * @type {number}
     * @memberof GetUniverseConstellationsConstellationIdPosition
     */
    y: number;
    /**
     * z number
     * @type {number}
     * @memberof GetUniverseConstellationsConstellationIdPosition
     */
    z: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetUniverseFactions200Ok
 */
export interface GetUniverseFactions200Ok {
    /**
     * corporation_id integer
     * @type {number}
     * @memberof GetUniverseFactions200Ok
     */
    corporationId?: number;
    /**
     * description string
     * @type {string}
     * @memberof GetUniverseFactions200Ok
     */
    description: string;
    /**
     * faction_id integer
     * @type {number}
     * @memberof GetUniverseFactions200Ok
     */
    factionId: number;
    /**
     * is_unique boolean
     * @type {boolean}
     * @memberof GetUniverseFactions200Ok
     */
    isUnique: boolean;
    /**
     * militia_corporation_id integer
     * @type {number}
     * @memberof GetUniverseFactions200Ok
     */
    militiaCorporationId?: number;
    /**
     * name string
     * @type {string}
     * @memberof GetUniverseFactions200Ok
     */
    name: string;
    /**
     * size_factor number
     * @type {number}
     * @memberof GetUniverseFactions200Ok
     */
    sizeFactor: number;
    /**
     * solar_system_id integer
     * @type {number}
     * @memberof GetUniverseFactions200Ok
     */
    solarSystemId?: number;
    /**
     * station_count integer
     * @type {number}
     * @memberof GetUniverseFactions200Ok
     */
    stationCount: number;
    /**
     * station_system_count integer
     * @type {number}
     * @memberof GetUniverseFactions200Ok
     */
    stationSystemCount: number;
}

/**
 * Not found
 * @export
 * @interface GetUniverseGraphicsGraphicIdNotFound
 */
export interface GetUniverseGraphicsGraphicIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetUniverseGraphicsGraphicIdNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetUniverseGraphicsGraphicIdOk
 */
export interface GetUniverseGraphicsGraphicIdOk {
    /**
     * collision_file string
     * @type {string}
     * @memberof GetUniverseGraphicsGraphicIdOk
     */
    collisionFile?: string;
    /**
     * graphic_file string
     * @type {string}
     * @memberof GetUniverseGraphicsGraphicIdOk
     */
    graphicFile?: string;
    /**
     * graphic_id integer
     * @type {number}
     * @memberof GetUniverseGraphicsGraphicIdOk
     */
    graphicId: number;
    /**
     * icon_folder string
     * @type {string}
     * @memberof GetUniverseGraphicsGraphicIdOk
     */
    iconFolder?: string;
    /**
     * sof_dna string
     * @type {string}
     * @memberof GetUniverseGraphicsGraphicIdOk
     */
    sofDna?: string;
    /**
     * sof_fation_name string
     * @type {string}
     * @memberof GetUniverseGraphicsGraphicIdOk
     */
    sofFationName?: string;
    /**
     * sof_hull_name string
     * @type {string}
     * @memberof GetUniverseGraphicsGraphicIdOk
     */
    sofHullName?: string;
    /**
     * sof_race_name string
     * @type {string}
     * @memberof GetUniverseGraphicsGraphicIdOk
     */
    sofRaceName?: string;
}

/**
 * Not found
 * @export
 * @interface GetUniverseGroupsGroupIdNotFound
 */
export interface GetUniverseGroupsGroupIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetUniverseGroupsGroupIdNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetUniverseGroupsGroupIdOk
 */
export interface GetUniverseGroupsGroupIdOk {
    /**
     * category_id integer
     * @type {number}
     * @memberof GetUniverseGroupsGroupIdOk
     */
    categoryId: number;
    /**
     * group_id integer
     * @type {number}
     * @memberof GetUniverseGroupsGroupIdOk
     */
    groupId: number;
    /**
     * name string
     * @type {string}
     * @memberof GetUniverseGroupsGroupIdOk
     */
    name: string;
    /**
     * published boolean
     * @type {boolean}
     * @memberof GetUniverseGroupsGroupIdOk
     */
    published: boolean;
    /**
     * types array
     * @type {Array<number>}
     * @memberof GetUniverseGroupsGroupIdOk
     */
    types: Array<number>;
}

/**
 * Not found
 * @export
 * @interface GetUniverseMoonsMoonIdNotFound
 */
export interface GetUniverseMoonsMoonIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetUniverseMoonsMoonIdNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetUniverseMoonsMoonIdOk
 */
export interface GetUniverseMoonsMoonIdOk {
    /**
     * moon_id integer
     * @type {number}
     * @memberof GetUniverseMoonsMoonIdOk
     */
    moonId: number;
    /**
     * name string
     * @type {string}
     * @memberof GetUniverseMoonsMoonIdOk
     */
    name: string;
    /**
     * 
     * @type {GetUniverseMoonsMoonIdPosition}
     * @memberof GetUniverseMoonsMoonIdOk
     */
    position: GetUniverseMoonsMoonIdPosition;
    /**
     * The solar system this moon is in
     * @type {number}
     * @memberof GetUniverseMoonsMoonIdOk
     */
    systemId: number;
}

/**
 * position object
 * @export
 * @interface GetUniverseMoonsMoonIdPosition
 */
export interface GetUniverseMoonsMoonIdPosition {
    /**
     * x number
     * @type {number}
     * @memberof GetUniverseMoonsMoonIdPosition
     */
    x: number;
    /**
     * y number
     * @type {number}
     * @memberof GetUniverseMoonsMoonIdPosition
     */
    y: number;
    /**
     * z number
     * @type {number}
     * @memberof GetUniverseMoonsMoonIdPosition
     */
    z: number;
}

/**
 * Not found
 * @export
 * @interface GetUniversePlanetsPlanetIdNotFound
 */
export interface GetUniversePlanetsPlanetIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetUniversePlanetsPlanetIdNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetUniversePlanetsPlanetIdOk
 */
export interface GetUniversePlanetsPlanetIdOk {
    /**
     * name string
     * @type {string}
     * @memberof GetUniversePlanetsPlanetIdOk
     */
    name: string;
    /**
     * planet_id integer
     * @type {number}
     * @memberof GetUniversePlanetsPlanetIdOk
     */
    planetId: number;
    /**
     * 
     * @type {GetUniversePlanetsPlanetIdPosition}
     * @memberof GetUniversePlanetsPlanetIdOk
     */
    position: GetUniversePlanetsPlanetIdPosition;
    /**
     * The solar system this planet is in
     * @type {number}
     * @memberof GetUniversePlanetsPlanetIdOk
     */
    systemId: number;
    /**
     * type_id integer
     * @type {number}
     * @memberof GetUniversePlanetsPlanetIdOk
     */
    typeId: number;
}

/**
 * position object
 * @export
 * @interface GetUniversePlanetsPlanetIdPosition
 */
export interface GetUniversePlanetsPlanetIdPosition {
    /**
     * x number
     * @type {number}
     * @memberof GetUniversePlanetsPlanetIdPosition
     */
    x: number;
    /**
     * y number
     * @type {number}
     * @memberof GetUniversePlanetsPlanetIdPosition
     */
    y: number;
    /**
     * z number
     * @type {number}
     * @memberof GetUniversePlanetsPlanetIdPosition
     */
    z: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetUniverseRaces200Ok
 */
export interface GetUniverseRaces200Ok {
    /**
     * The alliance generally associated with this race
     * @type {number}
     * @memberof GetUniverseRaces200Ok
     */
    allianceId: number;
    /**
     * description string
     * @type {string}
     * @memberof GetUniverseRaces200Ok
     */
    description: string;
    /**
     * name string
     * @type {string}
     * @memberof GetUniverseRaces200Ok
     */
    name: string;
    /**
     * race_id integer
     * @type {number}
     * @memberof GetUniverseRaces200Ok
     */
    raceId: number;
}

/**
 * Not found
 * @export
 * @interface GetUniverseRegionsRegionIdNotFound
 */
export interface GetUniverseRegionsRegionIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetUniverseRegionsRegionIdNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetUniverseRegionsRegionIdOk
 */
export interface GetUniverseRegionsRegionIdOk {
    /**
     * constellations array
     * @type {Array<number>}
     * @memberof GetUniverseRegionsRegionIdOk
     */
    constellations: Array<number>;
    /**
     * description string
     * @type {string}
     * @memberof GetUniverseRegionsRegionIdOk
     */
    description?: string;
    /**
     * name string
     * @type {string}
     * @memberof GetUniverseRegionsRegionIdOk
     */
    name: string;
    /**
     * region_id integer
     * @type {number}
     * @memberof GetUniverseRegionsRegionIdOk
     */
    regionId: number;
}

/**
 * Schematic not found
 * @export
 * @interface GetUniverseSchematicsSchematicIdNotFound
 */
export interface GetUniverseSchematicsSchematicIdNotFound {
    /**
     * error message
     * @type {string}
     * @memberof GetUniverseSchematicsSchematicIdNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetUniverseSchematicsSchematicIdOk
 */
export interface GetUniverseSchematicsSchematicIdOk {
    /**
     * Time in seconds to process a run
     * @type {number}
     * @memberof GetUniverseSchematicsSchematicIdOk
     */
    cycleTime: number;
    /**
     * schematic_name string
     * @type {string}
     * @memberof GetUniverseSchematicsSchematicIdOk
     */
    schematicName: string;
}

/**
 * destination object
 * @export
 * @interface GetUniverseStargatesStargateIdDestination
 */
export interface GetUniverseStargatesStargateIdDestination {
    /**
     * The stargate this stargate connects to
     * @type {number}
     * @memberof GetUniverseStargatesStargateIdDestination
     */
    stargateId: number;
    /**
     * The solar system this stargate connects to
     * @type {number}
     * @memberof GetUniverseStargatesStargateIdDestination
     */
    systemId: number;
}

/**
 * Not found
 * @export
 * @interface GetUniverseStargatesStargateIdNotFound
 */
export interface GetUniverseStargatesStargateIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetUniverseStargatesStargateIdNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetUniverseStargatesStargateIdOk
 */
export interface GetUniverseStargatesStargateIdOk {
    /**
     * 
     * @type {GetUniverseStargatesStargateIdDestination}
     * @memberof GetUniverseStargatesStargateIdOk
     */
    destination: GetUniverseStargatesStargateIdDestination;
    /**
     * name string
     * @type {string}
     * @memberof GetUniverseStargatesStargateIdOk
     */
    name: string;
    /**
     * 
     * @type {GetUniverseStargatesStargateIdPosition}
     * @memberof GetUniverseStargatesStargateIdOk
     */
    position: GetUniverseStargatesStargateIdPosition;
    /**
     * stargate_id integer
     * @type {number}
     * @memberof GetUniverseStargatesStargateIdOk
     */
    stargateId: number;
    /**
     * The solar system this stargate is in
     * @type {number}
     * @memberof GetUniverseStargatesStargateIdOk
     */
    systemId: number;
    /**
     * type_id integer
     * @type {number}
     * @memberof GetUniverseStargatesStargateIdOk
     */
    typeId: number;
}

/**
 * position object
 * @export
 * @interface GetUniverseStargatesStargateIdPosition
 */
export interface GetUniverseStargatesStargateIdPosition {
    /**
     * x number
     * @type {number}
     * @memberof GetUniverseStargatesStargateIdPosition
     */
    x: number;
    /**
     * y number
     * @type {number}
     * @memberof GetUniverseStargatesStargateIdPosition
     */
    y: number;
    /**
     * z number
     * @type {number}
     * @memberof GetUniverseStargatesStargateIdPosition
     */
    z: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetUniverseStarsStarIdOk
 */
export interface GetUniverseStarsStarIdOk {
    /**
     * Age of star in years
     * @type {number}
     * @memberof GetUniverseStarsStarIdOk
     */
    age: number;
    /**
     * luminosity number
     * @type {number}
     * @memberof GetUniverseStarsStarIdOk
     */
    luminosity: number;
    /**
     * name string
     * @type {string}
     * @memberof GetUniverseStarsStarIdOk
     */
    name: string;
    /**
     * radius integer
     * @type {number}
     * @memberof GetUniverseStarsStarIdOk
     */
    radius: number;
    /**
     * solar_system_id integer
     * @type {number}
     * @memberof GetUniverseStarsStarIdOk
     */
    solarSystemId: number;
    /**
     * spectral_class string
     * @type {string}
     * @memberof GetUniverseStarsStarIdOk
     */
    spectralClass: GetUniverseStarsStarIdOk.SpectralClassEnum;
    /**
     * temperature integer
     * @type {number}
     * @memberof GetUniverseStarsStarIdOk
     */
    temperature: number;
    /**
     * type_id integer
     * @type {number}
     * @memberof GetUniverseStarsStarIdOk
     */
    typeId: number;
}

/**
 * @export
 * @namespace GetUniverseStarsStarIdOk
 */
export namespace GetUniverseStarsStarIdOk {
    /**
     * @export
     * @enum {string}
     */
    export enum SpectralClassEnum {
        K2V = <any> 'K2 V',
        K4V = <any> 'K4 V',
        G2V = <any> 'G2 V',
        G8V = <any> 'G8 V',
        M7V = <any> 'M7 V',
        K7V = <any> 'K7 V',
        M2V = <any> 'M2 V',
        K5V = <any> 'K5 V',
        M3V = <any> 'M3 V',
        G0V = <any> 'G0 V',
        G7V = <any> 'G7 V',
        G3V = <any> 'G3 V',
        F9V = <any> 'F9 V',
        G5V = <any> 'G5 V',
        F6V = <any> 'F6 V',
        K8V = <any> 'K8 V',
        K9V = <any> 'K9 V',
        K6V = <any> 'K6 V',
        G9V = <any> 'G9 V',
        G6V = <any> 'G6 V',
        G4VI = <any> 'G4 VI',
        G4V = <any> 'G4 V',
        F8V = <any> 'F8 V',
        F2V = <any> 'F2 V',
        F1V = <any> 'F1 V',
        K3V = <any> 'K3 V',
        F0VI = <any> 'F0 VI',
        G1VI = <any> 'G1 VI',
        G0VI = <any> 'G0 VI',
        K1V = <any> 'K1 V',
        M4V = <any> 'M4 V',
        M1V = <any> 'M1 V',
        M6V = <any> 'M6 V',
        M0V = <any> 'M0 V',
        K2IV = <any> 'K2 IV',
        G2VI = <any> 'G2 VI',
        K0V = <any> 'K0 V',
        K5IV = <any> 'K5 IV',
        F5VI = <any> 'F5 VI',
        G6VI = <any> 'G6 VI',
        F6VI = <any> 'F6 VI',
        F2IV = <any> 'F2 IV',
        G3VI = <any> 'G3 VI',
        M8V = <any> 'M8 V',
        F1VI = <any> 'F1 VI',
        K1IV = <any> 'K1 IV',
        F7V = <any> 'F7 V',
        G5VI = <any> 'G5 VI',
        M5V = <any> 'M5 V',
        G7VI = <any> 'G7 VI',
        F5V = <any> 'F5 V',
        F4VI = <any> 'F4 VI',
        F8VI = <any> 'F8 VI',
        K3IV = <any> 'K3 IV',
        F4IV = <any> 'F4 IV',
        F0V = <any> 'F0 V',
        G7IV = <any> 'G7 IV',
        G8VI = <any> 'G8 VI',
        F2VI = <any> 'F2 VI',
        F4V = <any> 'F4 V',
        F7VI = <any> 'F7 VI',
        F3V = <any> 'F3 V',
        G1V = <any> 'G1 V',
        G9VI = <any> 'G9 VI',
        F3IV = <any> 'F3 IV',
        F9VI = <any> 'F9 VI',
        M9V = <any> 'M9 V',
        K0IV = <any> 'K0 IV',
        F1IV = <any> 'F1 IV',
        G4IV = <any> 'G4 IV',
        F3VI = <any> 'F3 VI',
        K4IV = <any> 'K4 IV',
        G5IV = <any> 'G5 IV',
        G3IV = <any> 'G3 IV',
        G1IV = <any> 'G1 IV',
        K7IV = <any> 'K7 IV',
        G0IV = <any> 'G0 IV',
        K6IV = <any> 'K6 IV',
        K9IV = <any> 'K9 IV',
        G2IV = <any> 'G2 IV',
        F9IV = <any> 'F9 IV',
        F0IV = <any> 'F0 IV',
        K8IV = <any> 'K8 IV',
        G8IV = <any> 'G8 IV',
        F6IV = <any> 'F6 IV',
        F5IV = <any> 'F5 IV',
        A0 = <any> 'A0',
        A0IV = <any> 'A0IV',
        A0IV2 = <any> 'A0IV2'
    }
}

/**
 * Not found
 * @export
 * @interface GetUniverseStationsStationIdNotFound
 */
export interface GetUniverseStationsStationIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetUniverseStationsStationIdNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetUniverseStationsStationIdOk
 */
export interface GetUniverseStationsStationIdOk {
    /**
     * max_dockable_ship_volume number
     * @type {number}
     * @memberof GetUniverseStationsStationIdOk
     */
    maxDockableShipVolume: number;
    /**
     * name string
     * @type {string}
     * @memberof GetUniverseStationsStationIdOk
     */
    name: string;
    /**
     * office_rental_cost number
     * @type {number}
     * @memberof GetUniverseStationsStationIdOk
     */
    officeRentalCost: number;
    /**
     * ID of the corporation that controls this station
     * @type {number}
     * @memberof GetUniverseStationsStationIdOk
     */
    owner?: number;
    /**
     * 
     * @type {GetUniverseStationsStationIdPosition}
     * @memberof GetUniverseStationsStationIdOk
     */
    position: GetUniverseStationsStationIdPosition;
    /**
     * race_id integer
     * @type {number}
     * @memberof GetUniverseStationsStationIdOk
     */
    raceId?: number;
    /**
     * reprocessing_efficiency number
     * @type {number}
     * @memberof GetUniverseStationsStationIdOk
     */
    reprocessingEfficiency: number;
    /**
     * reprocessing_stations_take number
     * @type {number}
     * @memberof GetUniverseStationsStationIdOk
     */
    reprocessingStationsTake: number;
    /**
     * services array
     * @type {Array<string>}
     * @memberof GetUniverseStationsStationIdOk
     */
    services: Array<GetUniverseStationsStationIdOk.ServicesEnum>;
    /**
     * station_id integer
     * @type {number}
     * @memberof GetUniverseStationsStationIdOk
     */
    stationId: number;
    /**
     * The solar system this station is in
     * @type {number}
     * @memberof GetUniverseStationsStationIdOk
     */
    systemId: number;
    /**
     * type_id integer
     * @type {number}
     * @memberof GetUniverseStationsStationIdOk
     */
    typeId: number;
}

/**
 * @export
 * @namespace GetUniverseStationsStationIdOk
 */
export namespace GetUniverseStationsStationIdOk {
    /**
     * @export
     * @enum {string}
     */
    export enum ServicesEnum {
        BountyMissions = <any> 'bounty-missions',
        AssasinationMissions = <any> 'assasination-missions',
        CourierMissions = <any> 'courier-missions',
        Interbus = <any> 'interbus',
        ReprocessingPlant = <any> 'reprocessing-plant',
        Refinery = <any> 'refinery',
        Market = <any> 'market',
        BlackMarket = <any> 'black-market',
        StockExchange = <any> 'stock-exchange',
        Cloning = <any> 'cloning',
        Surgery = <any> 'surgery',
        DnaTherapy = <any> 'dna-therapy',
        RepairFacilities = <any> 'repair-facilities',
        Factory = <any> 'factory',
        Labratory = <any> 'labratory',
        Gambling = <any> 'gambling',
        Fitting = <any> 'fitting',
        Paintshop = <any> 'paintshop',
        News = <any> 'news',
        Storage = <any> 'storage',
        Insurance = <any> 'insurance',
        Docking = <any> 'docking',
        OfficeRental = <any> 'office-rental',
        JumpCloneFacility = <any> 'jump-clone-facility',
        LoyaltyPointStore = <any> 'loyalty-point-store',
        NavyOffices = <any> 'navy-offices',
        SecurityOffices = <any> 'security-offices'
    }
}

/**
 * position object
 * @export
 * @interface GetUniverseStationsStationIdPosition
 */
export interface GetUniverseStationsStationIdPosition {
    /**
     * x number
     * @type {number}
     * @memberof GetUniverseStationsStationIdPosition
     */
    x: number;
    /**
     * y number
     * @type {number}
     * @memberof GetUniverseStationsStationIdPosition
     */
    y: number;
    /**
     * z number
     * @type {number}
     * @memberof GetUniverseStationsStationIdPosition
     */
    z: number;
}

/**
 * Not found
 * @export
 * @interface GetUniverseStructuresStructureIdNotFound
 */
export interface GetUniverseStructuresStructureIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetUniverseStructuresStructureIdNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetUniverseStructuresStructureIdOk
 */
export interface GetUniverseStructuresStructureIdOk {
    /**
     * The full name of the structure
     * @type {string}
     * @memberof GetUniverseStructuresStructureIdOk
     */
    name: string;
    /**
     * The ID of the corporation who owns this particular structure
     * @type {number}
     * @memberof GetUniverseStructuresStructureIdOk
     */
    ownerId: number;
    /**
     * 
     * @type {GetUniverseStructuresStructureIdPosition}
     * @memberof GetUniverseStructuresStructureIdOk
     */
    position?: GetUniverseStructuresStructureIdPosition;
    /**
     * solar_system_id integer
     * @type {number}
     * @memberof GetUniverseStructuresStructureIdOk
     */
    solarSystemId: number;
    /**
     * type_id integer
     * @type {number}
     * @memberof GetUniverseStructuresStructureIdOk
     */
    typeId?: number;
}

/**
 * Coordinates of the structure in Cartesian space relative to the Sun, in metres. 
 * @export
 * @interface GetUniverseStructuresStructureIdPosition
 */
export interface GetUniverseStructuresStructureIdPosition {
    /**
     * x number
     * @type {number}
     * @memberof GetUniverseStructuresStructureIdPosition
     */
    x: number;
    /**
     * y number
     * @type {number}
     * @memberof GetUniverseStructuresStructureIdPosition
     */
    y: number;
    /**
     * z number
     * @type {number}
     * @memberof GetUniverseStructuresStructureIdPosition
     */
    z: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetUniverseSystemJumps200Ok
 */
export interface GetUniverseSystemJumps200Ok {
    /**
     * ship_jumps integer
     * @type {number}
     * @memberof GetUniverseSystemJumps200Ok
     */
    shipJumps: number;
    /**
     * system_id integer
     * @type {number}
     * @memberof GetUniverseSystemJumps200Ok
     */
    systemId: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetUniverseSystemKills200Ok
 */
export interface GetUniverseSystemKills200Ok {
    /**
     * Number of NPC ships killed in this system
     * @type {number}
     * @memberof GetUniverseSystemKills200Ok
     */
    npcKills: number;
    /**
     * Number of pods killed in this system
     * @type {number}
     * @memberof GetUniverseSystemKills200Ok
     */
    podKills: number;
    /**
     * Number of player ships killed in this system
     * @type {number}
     * @memberof GetUniverseSystemKills200Ok
     */
    shipKills: number;
    /**
     * system_id integer
     * @type {number}
     * @memberof GetUniverseSystemKills200Ok
     */
    systemId: number;
}

/**
 * Not found
 * @export
 * @interface GetUniverseSystemsSystemIdNotFound
 */
export interface GetUniverseSystemsSystemIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetUniverseSystemsSystemIdNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetUniverseSystemsSystemIdOk
 */
export interface GetUniverseSystemsSystemIdOk {
    /**
     * The constellation this solar system is in
     * @type {number}
     * @memberof GetUniverseSystemsSystemIdOk
     */
    constellationId: number;
    /**
     * name string
     * @type {string}
     * @memberof GetUniverseSystemsSystemIdOk
     */
    name: string;
    /**
     * planets array
     * @type {Array<GetUniverseSystemsSystemIdPlanet>}
     * @memberof GetUniverseSystemsSystemIdOk
     */
    planets?: Array<GetUniverseSystemsSystemIdPlanet>;
    /**
     * 
     * @type {GetUniverseSystemsSystemIdPosition}
     * @memberof GetUniverseSystemsSystemIdOk
     */
    position: GetUniverseSystemsSystemIdPosition;
    /**
     * security_class string
     * @type {string}
     * @memberof GetUniverseSystemsSystemIdOk
     */
    securityClass?: string;
    /**
     * security_status number
     * @type {number}
     * @memberof GetUniverseSystemsSystemIdOk
     */
    securityStatus: number;
    /**
     * star_id integer
     * @type {number}
     * @memberof GetUniverseSystemsSystemIdOk
     */
    starId?: number;
    /**
     * stargates array
     * @type {Array<number>}
     * @memberof GetUniverseSystemsSystemIdOk
     */
    stargates?: Array<number>;
    /**
     * stations array
     * @type {Array<number>}
     * @memberof GetUniverseSystemsSystemIdOk
     */
    stations?: Array<number>;
    /**
     * system_id integer
     * @type {number}
     * @memberof GetUniverseSystemsSystemIdOk
     */
    systemId: number;
}

/**
 * planet object
 * @export
 * @interface GetUniverseSystemsSystemIdPlanet
 */
export interface GetUniverseSystemsSystemIdPlanet {
    /**
     * asteroid_belts array
     * @type {Array<number>}
     * @memberof GetUniverseSystemsSystemIdPlanet
     */
    asteroidBelts?: Array<number>;
    /**
     * moons array
     * @type {Array<number>}
     * @memberof GetUniverseSystemsSystemIdPlanet
     */
    moons?: Array<number>;
    /**
     * planet_id integer
     * @type {number}
     * @memberof GetUniverseSystemsSystemIdPlanet
     */
    planetId: number;
}

/**
 * position object
 * @export
 * @interface GetUniverseSystemsSystemIdPosition
 */
export interface GetUniverseSystemsSystemIdPosition {
    /**
     * x number
     * @type {number}
     * @memberof GetUniverseSystemsSystemIdPosition
     */
    x: number;
    /**
     * y number
     * @type {number}
     * @memberof GetUniverseSystemsSystemIdPosition
     */
    y: number;
    /**
     * z number
     * @type {number}
     * @memberof GetUniverseSystemsSystemIdPosition
     */
    z: number;
}

/**
 * dogma_attribute object
 * @export
 * @interface GetUniverseTypesTypeIdDogmaAttribute
 */
export interface GetUniverseTypesTypeIdDogmaAttribute {
    /**
     * attribute_id integer
     * @type {number}
     * @memberof GetUniverseTypesTypeIdDogmaAttribute
     */
    attributeId: number;
    /**
     * value number
     * @type {number}
     * @memberof GetUniverseTypesTypeIdDogmaAttribute
     */
    value: number;
}

/**
 * dogma_effect object
 * @export
 * @interface GetUniverseTypesTypeIdDogmaEffect
 */
export interface GetUniverseTypesTypeIdDogmaEffect {
    /**
     * effect_id integer
     * @type {number}
     * @memberof GetUniverseTypesTypeIdDogmaEffect
     */
    effectId: number;
    /**
     * is_default boolean
     * @type {boolean}
     * @memberof GetUniverseTypesTypeIdDogmaEffect
     */
    isDefault: boolean;
}

/**
 * Not found
 * @export
 * @interface GetUniverseTypesTypeIdNotFound
 */
export interface GetUniverseTypesTypeIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof GetUniverseTypesTypeIdNotFound
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetUniverseTypesTypeIdOk
 */
export interface GetUniverseTypesTypeIdOk {
    /**
     * capacity number
     * @type {number}
     * @memberof GetUniverseTypesTypeIdOk
     */
    capacity?: number;
    /**
     * description string
     * @type {string}
     * @memberof GetUniverseTypesTypeIdOk
     */
    description: string;
    /**
     * dogma_attributes array
     * @type {Array<GetUniverseTypesTypeIdDogmaAttribute>}
     * @memberof GetUniverseTypesTypeIdOk
     */
    dogmaAttributes?: Array<GetUniverseTypesTypeIdDogmaAttribute>;
    /**
     * dogma_effects array
     * @type {Array<GetUniverseTypesTypeIdDogmaEffect>}
     * @memberof GetUniverseTypesTypeIdOk
     */
    dogmaEffects?: Array<GetUniverseTypesTypeIdDogmaEffect>;
    /**
     * graphic_id integer
     * @type {number}
     * @memberof GetUniverseTypesTypeIdOk
     */
    graphicId?: number;
    /**
     * group_id integer
     * @type {number}
     * @memberof GetUniverseTypesTypeIdOk
     */
    groupId: number;
    /**
     * icon_id integer
     * @type {number}
     * @memberof GetUniverseTypesTypeIdOk
     */
    iconId?: number;
    /**
     * This only exists for types that can be put on the market
     * @type {number}
     * @memberof GetUniverseTypesTypeIdOk
     */
    marketGroupId?: number;
    /**
     * mass number
     * @type {number}
     * @memberof GetUniverseTypesTypeIdOk
     */
    mass?: number;
    /**
     * name string
     * @type {string}
     * @memberof GetUniverseTypesTypeIdOk
     */
    name: string;
    /**
     * packaged_volume number
     * @type {number}
     * @memberof GetUniverseTypesTypeIdOk
     */
    packagedVolume?: number;
    /**
     * portion_size integer
     * @type {number}
     * @memberof GetUniverseTypesTypeIdOk
     */
    portionSize?: number;
    /**
     * published boolean
     * @type {boolean}
     * @memberof GetUniverseTypesTypeIdOk
     */
    published: boolean;
    /**
     * radius number
     * @type {number}
     * @memberof GetUniverseTypesTypeIdOk
     */
    radius?: number;
    /**
     * type_id integer
     * @type {number}
     * @memberof GetUniverseTypesTypeIdOk
     */
    typeId: number;
    /**
     * volume number
     * @type {number}
     * @memberof GetUniverseTypesTypeIdOk
     */
    volume?: number;
}

/**
 * The aggressor corporation or alliance that declared this war, only contains either corporation_id or alliance_id
 * @export
 * @interface GetWarsWarIdAggressor
 */
export interface GetWarsWarIdAggressor {
    /**
     * Alliance ID if and only if the aggressor is an alliance
     * @type {number}
     * @memberof GetWarsWarIdAggressor
     */
    allianceId?: number;
    /**
     * Corporation ID if and only if the aggressor is a corporation
     * @type {number}
     * @memberof GetWarsWarIdAggressor
     */
    corporationId?: number;
    /**
     * ISK value of ships the aggressor has destroyed
     * @type {number}
     * @memberof GetWarsWarIdAggressor
     */
    iskDestroyed: number;
    /**
     * The number of ships the aggressor has killed
     * @type {number}
     * @memberof GetWarsWarIdAggressor
     */
    shipsKilled: number;
}

/**
 * ally object
 * @export
 * @interface GetWarsWarIdAlly
 */
export interface GetWarsWarIdAlly {
    /**
     * Alliance ID if and only if this ally is an alliance
     * @type {number}
     * @memberof GetWarsWarIdAlly
     */
    allianceId?: number;
    /**
     * Corporation ID if and only if this ally is a corporation
     * @type {number}
     * @memberof GetWarsWarIdAlly
     */
    corporationId?: number;
}

/**
 * The defending corporation or alliance that declared this war, only contains either corporation_id or alliance_id
 * @export
 * @interface GetWarsWarIdDefender
 */
export interface GetWarsWarIdDefender {
    /**
     * Alliance ID if and only if the defender is an alliance
     * @type {number}
     * @memberof GetWarsWarIdDefender
     */
    allianceId?: number;
    /**
     * Corporation ID if and only if the defender is a corporation
     * @type {number}
     * @memberof GetWarsWarIdDefender
     */
    corporationId?: number;
    /**
     * ISK value of ships the defender has killed
     * @type {number}
     * @memberof GetWarsWarIdDefender
     */
    iskDestroyed: number;
    /**
     * The number of ships the defender has killed
     * @type {number}
     * @memberof GetWarsWarIdDefender
     */
    shipsKilled: number;
}

/**
 * 200 ok object
 * @export
 * @interface GetWarsWarIdKillmails200Ok
 */
export interface GetWarsWarIdKillmails200Ok {
    /**
     * A hash of this killmail
     * @type {string}
     * @memberof GetWarsWarIdKillmails200Ok
     */
    killmailHash: string;
    /**
     * ID of this killmail
     * @type {number}
     * @memberof GetWarsWarIdKillmails200Ok
     */
    killmailId: number;
}

/**
 * Unprocessable entity
 * @export
 * @interface GetWarsWarIdKillmailsUnprocessableEntity
 */
export interface GetWarsWarIdKillmailsUnprocessableEntity {
    /**
     * Unprocessable entity message
     * @type {string}
     * @memberof GetWarsWarIdKillmailsUnprocessableEntity
     */
    error?: string;
}

/**
 * 200 ok object
 * @export
 * @interface GetWarsWarIdOk
 */
export interface GetWarsWarIdOk {
    /**
     * 
     * @type {GetWarsWarIdAggressor}
     * @memberof GetWarsWarIdOk
     */
    aggressor: GetWarsWarIdAggressor;
    /**
     * allied corporations or alliances, each object contains either corporation_id or alliance_id
     * @type {Array<GetWarsWarIdAlly>}
     * @memberof GetWarsWarIdOk
     */
    allies?: Array<GetWarsWarIdAlly>;
    /**
     * Time that the war was declared
     * @type {Date}
     * @memberof GetWarsWarIdOk
     */
    declared: Date;
    /**
     * 
     * @type {GetWarsWarIdDefender}
     * @memberof GetWarsWarIdOk
     */
    defender: GetWarsWarIdDefender;
    /**
     * Time the war ended and shooting was no longer allowed
     * @type {Date}
     * @memberof GetWarsWarIdOk
     */
    finished?: Date;
    /**
     * ID of the specified war
     * @type {number}
     * @memberof GetWarsWarIdOk
     */
    id: number;
    /**
     * Was the war declared mutual by both parties
     * @type {boolean}
     * @memberof GetWarsWarIdOk
     */
    mutual: boolean;
    /**
     * Is the war currently open for allies or not
     * @type {boolean}
     * @memberof GetWarsWarIdOk
     */
    openForAllies: boolean;
    /**
     * Time the war was retracted but both sides could still shoot each other
     * @type {Date}
     * @memberof GetWarsWarIdOk
     */
    retracted?: Date;
    /**
     * Time when the war started and both sides could shoot each other
     * @type {Date}
     * @memberof GetWarsWarIdOk
     */
    started?: Date;
}

/**
 * Unprocessable entity
 * @export
 * @interface GetWarsWarIdUnprocessableEntity
 */
export interface GetWarsWarIdUnprocessableEntity {
    /**
     * Unprocessable entity message
     * @type {string}
     * @memberof GetWarsWarIdUnprocessableEntity
     */
    error?: string;
}

/**
 * Internal server error model
 * @export
 * @interface InternalServerError
 */
export interface InternalServerError {
    /**
     * Internal server error message
     * @type {string}
     * @memberof InternalServerError
     */
    error: string;
}

/**
 * 200 ok object
 * @export
 * @interface PostCharactersAffiliation200Ok
 */
export interface PostCharactersAffiliation200Ok {
    /**
     * The character's alliance ID, if their corporation is in an alliance
     * @type {number}
     * @memberof PostCharactersAffiliation200Ok
     */
    allianceId?: number;
    /**
     * The character's ID
     * @type {number}
     * @memberof PostCharactersAffiliation200Ok
     */
    characterId: number;
    /**
     * The character's corporation ID
     * @type {number}
     * @memberof PostCharactersAffiliation200Ok
     */
    corporationId: number;
    /**
     * The character's faction ID, if their corporation is in a faction
     * @type {number}
     * @memberof PostCharactersAffiliation200Ok
     */
    factionId?: number;
}

/**
 * 200 ok object
 * @export
 * @interface PostCharactersCharacterIdAssetsLocations200Ok
 */
export interface PostCharactersCharacterIdAssetsLocations200Ok {
    /**
     * item_id integer
     * @type {number}
     * @memberof PostCharactersCharacterIdAssetsLocations200Ok
     */
    itemId: number;
    /**
     * 
     * @type {PostCharactersCharacterIdAssetsLocationsPosition}
     * @memberof PostCharactersCharacterIdAssetsLocations200Ok
     */
    position: PostCharactersCharacterIdAssetsLocationsPosition;
}

/**
 * position object
 * @export
 * @interface PostCharactersCharacterIdAssetsLocationsPosition
 */
export interface PostCharactersCharacterIdAssetsLocationsPosition {
    /**
     * x number
     * @type {number}
     * @memberof PostCharactersCharacterIdAssetsLocationsPosition
     */
    x: number;
    /**
     * y number
     * @type {number}
     * @memberof PostCharactersCharacterIdAssetsLocationsPosition
     */
    y: number;
    /**
     * z number
     * @type {number}
     * @memberof PostCharactersCharacterIdAssetsLocationsPosition
     */
    z: number;
}

/**
 * 200 ok object
 * @export
 * @interface PostCharactersCharacterIdAssetsNames200Ok
 */
export interface PostCharactersCharacterIdAssetsNames200Ok {
    /**
     * item_id integer
     * @type {number}
     * @memberof PostCharactersCharacterIdAssetsNames200Ok
     */
    itemId: number;
    /**
     * name string
     * @type {string}
     * @memberof PostCharactersCharacterIdAssetsNames200Ok
     */
    name: string;
}

/**
 * Error 520
 * @export
 * @interface PostCharactersCharacterIdContactsError520
 */
export interface PostCharactersCharacterIdContactsError520 {
    /**
     * Error 520 message
     * @type {string}
     * @memberof PostCharactersCharacterIdContactsError520
     */
    error?: string;
}

/**
 * 201 created object
 * @export
 * @interface PostCharactersCharacterIdFittingsCreated
 */
export interface PostCharactersCharacterIdFittingsCreated {
    /**
     * fitting_id integer
     * @type {number}
     * @memberof PostCharactersCharacterIdFittingsCreated
     */
    fittingId: number;
}

/**
 * fitting object
 * @export
 * @interface PostCharactersCharacterIdFittingsFitting
 */
export interface PostCharactersCharacterIdFittingsFitting {
    /**
     * description string
     * @type {string}
     * @memberof PostCharactersCharacterIdFittingsFitting
     */
    description: string;
    /**
     * items array
     * @type {Array<PostCharactersCharacterIdFittingsItem>}
     * @memberof PostCharactersCharacterIdFittingsFitting
     */
    items: Array<PostCharactersCharacterIdFittingsItem>;
    /**
     * name string
     * @type {string}
     * @memberof PostCharactersCharacterIdFittingsFitting
     */
    name: string;
    /**
     * ship_type_id integer
     * @type {number}
     * @memberof PostCharactersCharacterIdFittingsFitting
     */
    shipTypeId: number;
}

/**
 * item object
 * @export
 * @interface PostCharactersCharacterIdFittingsItem
 */
export interface PostCharactersCharacterIdFittingsItem {
    /**
     * Fitting location for the item. Entries placed in 'Invalid' will be discarded. If this leaves the fitting with nothing, it will cause an error.
     * @type {string}
     * @memberof PostCharactersCharacterIdFittingsItem
     */
    flag: PostCharactersCharacterIdFittingsItem.FlagEnum;
    /**
     * quantity integer
     * @type {number}
     * @memberof PostCharactersCharacterIdFittingsItem
     */
    quantity: number;
    /**
     * type_id integer
     * @type {number}
     * @memberof PostCharactersCharacterIdFittingsItem
     */
    typeId: number;
}

/**
 * @export
 * @namespace PostCharactersCharacterIdFittingsItem
 */
export namespace PostCharactersCharacterIdFittingsItem {
    /**
     * @export
     * @enum {string}
     */
    export enum FlagEnum {
        Cargo = <any> 'Cargo',
        DroneBay = <any> 'DroneBay',
        FighterBay = <any> 'FighterBay',
        HiSlot0 = <any> 'HiSlot0',
        HiSlot1 = <any> 'HiSlot1',
        HiSlot2 = <any> 'HiSlot2',
        HiSlot3 = <any> 'HiSlot3',
        HiSlot4 = <any> 'HiSlot4',
        HiSlot5 = <any> 'HiSlot5',
        HiSlot6 = <any> 'HiSlot6',
        HiSlot7 = <any> 'HiSlot7',
        Invalid = <any> 'Invalid',
        LoSlot0 = <any> 'LoSlot0',
        LoSlot1 = <any> 'LoSlot1',
        LoSlot2 = <any> 'LoSlot2',
        LoSlot3 = <any> 'LoSlot3',
        LoSlot4 = <any> 'LoSlot4',
        LoSlot5 = <any> 'LoSlot5',
        LoSlot6 = <any> 'LoSlot6',
        LoSlot7 = <any> 'LoSlot7',
        MedSlot0 = <any> 'MedSlot0',
        MedSlot1 = <any> 'MedSlot1',
        MedSlot2 = <any> 'MedSlot2',
        MedSlot3 = <any> 'MedSlot3',
        MedSlot4 = <any> 'MedSlot4',
        MedSlot5 = <any> 'MedSlot5',
        MedSlot6 = <any> 'MedSlot6',
        MedSlot7 = <any> 'MedSlot7',
        RigSlot0 = <any> 'RigSlot0',
        RigSlot1 = <any> 'RigSlot1',
        RigSlot2 = <any> 'RigSlot2',
        ServiceSlot0 = <any> 'ServiceSlot0',
        ServiceSlot1 = <any> 'ServiceSlot1',
        ServiceSlot2 = <any> 'ServiceSlot2',
        ServiceSlot3 = <any> 'ServiceSlot3',
        ServiceSlot4 = <any> 'ServiceSlot4',
        ServiceSlot5 = <any> 'ServiceSlot5',
        ServiceSlot6 = <any> 'ServiceSlot6',
        ServiceSlot7 = <any> 'ServiceSlot7',
        SubSystemSlot0 = <any> 'SubSystemSlot0',
        SubSystemSlot1 = <any> 'SubSystemSlot1',
        SubSystemSlot2 = <any> 'SubSystemSlot2',
        SubSystemSlot3 = <any> 'SubSystemSlot3'
    }
}

/**
 * Error 520
 * @export
 * @interface PostCharactersCharacterIdMailError520
 */
export interface PostCharactersCharacterIdMailError520 {
    /**
     * Error 520 message
     * @type {string}
     * @memberof PostCharactersCharacterIdMailError520
     */
    error?: string;
}

/**
 * label object
 * @export
 * @interface PostCharactersCharacterIdMailLabelsLabel
 */
export interface PostCharactersCharacterIdMailLabelsLabel {
    /**
     * Hexadecimal string representing label color, in RGB format
     * @type {string}
     * @memberof PostCharactersCharacterIdMailLabelsLabel
     */
    color?: PostCharactersCharacterIdMailLabelsLabel.ColorEnum;
    /**
     * name string
     * @type {string}
     * @memberof PostCharactersCharacterIdMailLabelsLabel
     */
    name: string;
}

/**
 * @export
 * @namespace PostCharactersCharacterIdMailLabelsLabel
 */
export namespace PostCharactersCharacterIdMailLabelsLabel {
    /**
     * @export
     * @enum {string}
     */
    export enum ColorEnum {
        _0000fe = <any> '#0000fe',
        _006634 = <any> '#006634',
        _0099ff = <any> '#0099ff',
        _00ff33 = <any> '#00ff33',
        _01ffff = <any> '#01ffff',
        _349800 = <any> '#349800',
        _660066 = <any> '#660066',
        _666666 = <any> '#666666',
        _999999 = <any> '#999999',
        _99ffff = <any> '#99ffff',
        _9a0000 = <any> '#9a0000',
        Ccff9a = <any> '#ccff9a',
        E6e6e6 = <any> '#e6e6e6',
        Fe0000 = <any> '#fe0000',
        Ff6600 = <any> '#ff6600',
        Ffff01 = <any> '#ffff01',
        Ffffcd = <any> '#ffffcd',
        Ffffff = <any> '#ffffff'
    }
}

/**
 * mail object
 * @export
 * @interface PostCharactersCharacterIdMailMail
 */
export interface PostCharactersCharacterIdMailMail {
    /**
     * approved_cost integer
     * @type {number}
     * @memberof PostCharactersCharacterIdMailMail
     */
    approvedCost?: number;
    /**
     * body string
     * @type {string}
     * @memberof PostCharactersCharacterIdMailMail
     */
    body: string;
    /**
     * recipients array
     * @type {Array<PostCharactersCharacterIdMailRecipient>}
     * @memberof PostCharactersCharacterIdMailMail
     */
    recipients: Array<PostCharactersCharacterIdMailRecipient>;
    /**
     * subject string
     * @type {string}
     * @memberof PostCharactersCharacterIdMailMail
     */
    subject: string;
}

/**
 * recipient object
 * @export
 * @interface PostCharactersCharacterIdMailRecipient
 */
export interface PostCharactersCharacterIdMailRecipient {
    /**
     * recipient_id integer
     * @type {number}
     * @memberof PostCharactersCharacterIdMailRecipient
     */
    recipientId: number;
    /**
     * recipient_type string
     * @type {string}
     * @memberof PostCharactersCharacterIdMailRecipient
     */
    recipientType: PostCharactersCharacterIdMailRecipient.RecipientTypeEnum;
}

/**
 * @export
 * @namespace PostCharactersCharacterIdMailRecipient
 */
export namespace PostCharactersCharacterIdMailRecipient {
    /**
     * @export
     * @enum {string}
     */
    export enum RecipientTypeEnum {
        Alliance = <any> 'alliance',
        Character = <any> 'character',
        Corporation = <any> 'corporation',
        MailingList = <any> 'mailing_list'
    }
}

/**
 * 200 ok object
 * @export
 * @interface PostCorporationsCorporationIdAssetsLocations200Ok
 */
export interface PostCorporationsCorporationIdAssetsLocations200Ok {
    /**
     * item_id integer
     * @type {number}
     * @memberof PostCorporationsCorporationIdAssetsLocations200Ok
     */
    itemId: number;
    /**
     * 
     * @type {PostCorporationsCorporationIdAssetsLocationsPosition}
     * @memberof PostCorporationsCorporationIdAssetsLocations200Ok
     */
    position: PostCorporationsCorporationIdAssetsLocationsPosition;
}

/**
 * Not found
 * @export
 * @interface PostCorporationsCorporationIdAssetsLocationsNotFound
 */
export interface PostCorporationsCorporationIdAssetsLocationsNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof PostCorporationsCorporationIdAssetsLocationsNotFound
     */
    error?: string;
}

/**
 * position object
 * @export
 * @interface PostCorporationsCorporationIdAssetsLocationsPosition
 */
export interface PostCorporationsCorporationIdAssetsLocationsPosition {
    /**
     * x number
     * @type {number}
     * @memberof PostCorporationsCorporationIdAssetsLocationsPosition
     */
    x: number;
    /**
     * y number
     * @type {number}
     * @memberof PostCorporationsCorporationIdAssetsLocationsPosition
     */
    y: number;
    /**
     * z number
     * @type {number}
     * @memberof PostCorporationsCorporationIdAssetsLocationsPosition
     */
    z: number;
}

/**
 * 200 ok object
 * @export
 * @interface PostCorporationsCorporationIdAssetsNames200Ok
 */
export interface PostCorporationsCorporationIdAssetsNames200Ok {
    /**
     * item_id integer
     * @type {number}
     * @memberof PostCorporationsCorporationIdAssetsNames200Ok
     */
    itemId: number;
    /**
     * name string
     * @type {string}
     * @memberof PostCorporationsCorporationIdAssetsNames200Ok
     */
    name: string;
}

/**
 * Not found
 * @export
 * @interface PostCorporationsCorporationIdAssetsNamesNotFound
 */
export interface PostCorporationsCorporationIdAssetsNamesNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof PostCorporationsCorporationIdAssetsNamesNotFound
     */
    error?: string;
}

/**
 * invitation object
 * @export
 * @interface PostFleetsFleetIdMembersInvitation
 */
export interface PostFleetsFleetIdMembersInvitation {
    /**
     * The character you want to invite
     * @type {number}
     * @memberof PostFleetsFleetIdMembersInvitation
     */
    characterId: number;
    /**
     * If a character is invited with the `fleet_commander` role, neither `wing_id` or `squad_id` should be specified. If a character is invited with the `wing_commander` role, only `wing_id` should be specified. If a character is invited with the `squad_commander` role, both `wing_id` and `squad_id` should be specified. If a character is invited with the `squad_member` role, `wing_id` and `squad_id` should either both be specified or not specified at all. If they aren’t specified, the invited character will join any squad with available positions.
     * @type {string}
     * @memberof PostFleetsFleetIdMembersInvitation
     */
    role: PostFleetsFleetIdMembersInvitation.RoleEnum;
    /**
     * squad_id integer
     * @type {number}
     * @memberof PostFleetsFleetIdMembersInvitation
     */
    squadId?: number;
    /**
     * wing_id integer
     * @type {number}
     * @memberof PostFleetsFleetIdMembersInvitation
     */
    wingId?: number;
}

/**
 * @export
 * @namespace PostFleetsFleetIdMembersInvitation
 */
export namespace PostFleetsFleetIdMembersInvitation {
    /**
     * @export
     * @enum {string}
     */
    export enum RoleEnum {
        FleetCommander = <any> 'fleet_commander',
        WingCommander = <any> 'wing_commander',
        SquadCommander = <any> 'squad_commander',
        SquadMember = <any> 'squad_member'
    }
}

/**
 * Not found
 * @export
 * @interface PostFleetsFleetIdMembersNotFound
 */
export interface PostFleetsFleetIdMembersNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof PostFleetsFleetIdMembersNotFound
     */
    error?: string;
}

/**
 * 422 unprocessable entity object
 * @export
 * @interface PostFleetsFleetIdMembersUnprocessableEntity
 */
export interface PostFleetsFleetIdMembersUnprocessableEntity {
    /**
     * error message
     * @type {string}
     * @memberof PostFleetsFleetIdMembersUnprocessableEntity
     */
    error?: string;
}

/**
 * 201 created object
 * @export
 * @interface PostFleetsFleetIdWingsCreated
 */
export interface PostFleetsFleetIdWingsCreated {
    /**
     * The wing_id of the newly created wing
     * @type {number}
     * @memberof PostFleetsFleetIdWingsCreated
     */
    wingId: number;
}

/**
 * Not found
 * @export
 * @interface PostFleetsFleetIdWingsNotFound
 */
export interface PostFleetsFleetIdWingsNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof PostFleetsFleetIdWingsNotFound
     */
    error?: string;
}

/**
 * 201 created object
 * @export
 * @interface PostFleetsFleetIdWingsWingIdSquadsCreated
 */
export interface PostFleetsFleetIdWingsWingIdSquadsCreated {
    /**
     * The squad_id of the newly created squad
     * @type {number}
     * @memberof PostFleetsFleetIdWingsWingIdSquadsCreated
     */
    squadId: number;
}

/**
 * Not found
 * @export
 * @interface PostFleetsFleetIdWingsWingIdSquadsNotFound
 */
export interface PostFleetsFleetIdWingsWingIdSquadsNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof PostFleetsFleetIdWingsWingIdSquadsNotFound
     */
    error?: string;
}

/**
 * new_mail object
 * @export
 * @interface PostUiOpenwindowNewmailNewMail
 */
export interface PostUiOpenwindowNewmailNewMail {
    /**
     * body string
     * @type {string}
     * @memberof PostUiOpenwindowNewmailNewMail
     */
    body: string;
    /**
     * recipients array
     * @type {Array<number>}
     * @memberof PostUiOpenwindowNewmailNewMail
     */
    recipients: Array<number>;
    /**
     * subject string
     * @type {string}
     * @memberof PostUiOpenwindowNewmailNewMail
     */
    subject: string;
    /**
     * to_corp_or_alliance_id integer
     * @type {number}
     * @memberof PostUiOpenwindowNewmailNewMail
     */
    toCorpOrAllianceId?: number;
    /**
     * Corporations, alliances and mailing lists are all types of mailing groups. You may only send to one mailing group, at a time, so you may fill out either this field or the to_corp_or_alliance_ids field
     * @type {number}
     * @memberof PostUiOpenwindowNewmailNewMail
     */
    toMailingListId?: number;
}

/**
 * Unprocessable entity
 * @export
 * @interface PostUiOpenwindowNewmailUnprocessableEntity
 */
export interface PostUiOpenwindowNewmailUnprocessableEntity {
    /**
     * Unprocessable entity message
     * @type {string}
     * @memberof PostUiOpenwindowNewmailUnprocessableEntity
     */
    error?: string;
}

/**
 * agent object
 * @export
 * @interface PostUniverseIdsAgent
 */
export interface PostUniverseIdsAgent {
    /**
     * id integer
     * @type {number}
     * @memberof PostUniverseIdsAgent
     */
    id?: number;
    /**
     * name string
     * @type {string}
     * @memberof PostUniverseIdsAgent
     */
    name?: string;
}

/**
 * alliance object
 * @export
 * @interface PostUniverseIdsAlliance
 */
export interface PostUniverseIdsAlliance {
    /**
     * id integer
     * @type {number}
     * @memberof PostUniverseIdsAlliance
     */
    id?: number;
    /**
     * name string
     * @type {string}
     * @memberof PostUniverseIdsAlliance
     */
    name?: string;
}

/**
 * character object
 * @export
 * @interface PostUniverseIdsCharacter
 */
export interface PostUniverseIdsCharacter {
    /**
     * id integer
     * @type {number}
     * @memberof PostUniverseIdsCharacter
     */
    id?: number;
    /**
     * name string
     * @type {string}
     * @memberof PostUniverseIdsCharacter
     */
    name?: string;
}

/**
 * constellation object
 * @export
 * @interface PostUniverseIdsConstellation
 */
export interface PostUniverseIdsConstellation {
    /**
     * id integer
     * @type {number}
     * @memberof PostUniverseIdsConstellation
     */
    id?: number;
    /**
     * name string
     * @type {string}
     * @memberof PostUniverseIdsConstellation
     */
    name?: string;
}

/**
 * corporation object
 * @export
 * @interface PostUniverseIdsCorporation
 */
export interface PostUniverseIdsCorporation {
    /**
     * id integer
     * @type {number}
     * @memberof PostUniverseIdsCorporation
     */
    id?: number;
    /**
     * name string
     * @type {string}
     * @memberof PostUniverseIdsCorporation
     */
    name?: string;
}

/**
 * faction object
 * @export
 * @interface PostUniverseIdsFaction
 */
export interface PostUniverseIdsFaction {
    /**
     * id integer
     * @type {number}
     * @memberof PostUniverseIdsFaction
     */
    id?: number;
    /**
     * name string
     * @type {string}
     * @memberof PostUniverseIdsFaction
     */
    name?: string;
}

/**
 * inventory_type object
 * @export
 * @interface PostUniverseIdsInventoryType
 */
export interface PostUniverseIdsInventoryType {
    /**
     * id integer
     * @type {number}
     * @memberof PostUniverseIdsInventoryType
     */
    id?: number;
    /**
     * name string
     * @type {string}
     * @memberof PostUniverseIdsInventoryType
     */
    name?: string;
}

/**
 * 200 ok object
 * @export
 * @interface PostUniverseIdsOk
 */
export interface PostUniverseIdsOk {
    /**
     * agents array
     * @type {Array<PostUniverseIdsAgent>}
     * @memberof PostUniverseIdsOk
     */
    agents?: Array<PostUniverseIdsAgent>;
    /**
     * alliances array
     * @type {Array<PostUniverseIdsAlliance>}
     * @memberof PostUniverseIdsOk
     */
    alliances?: Array<PostUniverseIdsAlliance>;
    /**
     * characters array
     * @type {Array<PostUniverseIdsCharacter>}
     * @memberof PostUniverseIdsOk
     */
    characters?: Array<PostUniverseIdsCharacter>;
    /**
     * constellations array
     * @type {Array<PostUniverseIdsConstellation>}
     * @memberof PostUniverseIdsOk
     */
    constellations?: Array<PostUniverseIdsConstellation>;
    /**
     * corporations array
     * @type {Array<PostUniverseIdsCorporation>}
     * @memberof PostUniverseIdsOk
     */
    corporations?: Array<PostUniverseIdsCorporation>;
    /**
     * factions array
     * @type {Array<PostUniverseIdsFaction>}
     * @memberof PostUniverseIdsOk
     */
    factions?: Array<PostUniverseIdsFaction>;
    /**
     * inventory_types array
     * @type {Array<PostUniverseIdsInventoryType>}
     * @memberof PostUniverseIdsOk
     */
    inventoryTypes?: Array<PostUniverseIdsInventoryType>;
    /**
     * regions array
     * @type {Array<PostUniverseIdsRegion>}
     * @memberof PostUniverseIdsOk
     */
    regions?: Array<PostUniverseIdsRegion>;
    /**
     * stations array
     * @type {Array<PostUniverseIdsStation>}
     * @memberof PostUniverseIdsOk
     */
    stations?: Array<PostUniverseIdsStation>;
    /**
     * systems array
     * @type {Array<PostUniverseIdsSystem>}
     * @memberof PostUniverseIdsOk
     */
    systems?: Array<PostUniverseIdsSystem>;
}

/**
 * region object
 * @export
 * @interface PostUniverseIdsRegion
 */
export interface PostUniverseIdsRegion {
    /**
     * id integer
     * @type {number}
     * @memberof PostUniverseIdsRegion
     */
    id?: number;
    /**
     * name string
     * @type {string}
     * @memberof PostUniverseIdsRegion
     */
    name?: string;
}

/**
 * station object
 * @export
 * @interface PostUniverseIdsStation
 */
export interface PostUniverseIdsStation {
    /**
     * id integer
     * @type {number}
     * @memberof PostUniverseIdsStation
     */
    id?: number;
    /**
     * name string
     * @type {string}
     * @memberof PostUniverseIdsStation
     */
    name?: string;
}

/**
 * system object
 * @export
 * @interface PostUniverseIdsSystem
 */
export interface PostUniverseIdsSystem {
    /**
     * id integer
     * @type {number}
     * @memberof PostUniverseIdsSystem
     */
    id?: number;
    /**
     * name string
     * @type {string}
     * @memberof PostUniverseIdsSystem
     */
    name?: string;
}

/**
 * 200 ok object
 * @export
 * @interface PostUniverseNames200Ok
 */
export interface PostUniverseNames200Ok {
    /**
     * category string
     * @type {string}
     * @memberof PostUniverseNames200Ok
     */
    category: PostUniverseNames200Ok.CategoryEnum;
    /**
     * id integer
     * @type {number}
     * @memberof PostUniverseNames200Ok
     */
    id: number;
    /**
     * name string
     * @type {string}
     * @memberof PostUniverseNames200Ok
     */
    name: string;
}

/**
 * @export
 * @namespace PostUniverseNames200Ok
 */
export namespace PostUniverseNames200Ok {
    /**
     * @export
     * @enum {string}
     */
    export enum CategoryEnum {
        Alliance = <any> 'alliance',
        Character = <any> 'character',
        Constellation = <any> 'constellation',
        Corporation = <any> 'corporation',
        InventoryType = <any> 'inventory_type',
        Region = <any> 'region',
        SolarSystem = <any> 'solar_system',
        Station = <any> 'station',
        Faction = <any> 'faction'
    }
}

/**
 * Not found
 * @export
 * @interface PostUniverseNamesNotFound
 */
export interface PostUniverseNamesNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof PostUniverseNamesNotFound
     */
    error?: string;
}

/**
 * response object
 * @export
 * @interface PutCharactersCharacterIdCalendarEventIdResponse
 */
export interface PutCharactersCharacterIdCalendarEventIdResponse {
    /**
     * response string
     * @type {string}
     * @memberof PutCharactersCharacterIdCalendarEventIdResponse
     */
    response: PutCharactersCharacterIdCalendarEventIdResponse.ResponseEnum;
}

/**
 * @export
 * @namespace PutCharactersCharacterIdCalendarEventIdResponse
 */
export namespace PutCharactersCharacterIdCalendarEventIdResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum ResponseEnum {
        Accepted = <any> 'accepted',
        Declined = <any> 'declined',
        Tentative = <any> 'tentative'
    }
}

/**
 * contents object
 * @export
 * @interface PutCharactersCharacterIdMailMailIdContents
 */
export interface PutCharactersCharacterIdMailMailIdContents {
    /**
     * Labels to assign to the mail. Pre-existing labels are unassigned.
     * @type {Array<number>}
     * @memberof PutCharactersCharacterIdMailMailIdContents
     */
    labels?: Array<number>;
    /**
     * Whether the mail is flagged as read
     * @type {boolean}
     * @memberof PutCharactersCharacterIdMailMailIdContents
     */
    read?: boolean;
}

/**
 * movement object
 * @export
 * @interface PutFleetsFleetIdMembersMemberIdMovement
 */
export interface PutFleetsFleetIdMembersMemberIdMovement {
    /**
     * If a character is moved to the `fleet_commander` role, neither `wing_id` or `squad_id` should be specified. If a character is moved to the `wing_commander` role, only `wing_id` should be specified. If a character is moved to the `squad_commander` role, both `wing_id` and `squad_id` should be specified. If a character is moved to the `squad_member` role, both `wing_id` and `squad_id` should be specified.
     * @type {string}
     * @memberof PutFleetsFleetIdMembersMemberIdMovement
     */
    role: PutFleetsFleetIdMembersMemberIdMovement.RoleEnum;
    /**
     * squad_id integer
     * @type {number}
     * @memberof PutFleetsFleetIdMembersMemberIdMovement
     */
    squadId?: number;
    /**
     * wing_id integer
     * @type {number}
     * @memberof PutFleetsFleetIdMembersMemberIdMovement
     */
    wingId?: number;
}

/**
 * @export
 * @namespace PutFleetsFleetIdMembersMemberIdMovement
 */
export namespace PutFleetsFleetIdMembersMemberIdMovement {
    /**
     * @export
     * @enum {string}
     */
    export enum RoleEnum {
        FleetCommander = <any> 'fleet_commander',
        WingCommander = <any> 'wing_commander',
        SquadCommander = <any> 'squad_commander',
        SquadMember = <any> 'squad_member'
    }
}

/**
 * Not found
 * @export
 * @interface PutFleetsFleetIdMembersMemberIdNotFound
 */
export interface PutFleetsFleetIdMembersMemberIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof PutFleetsFleetIdMembersMemberIdNotFound
     */
    error?: string;
}

/**
 * 422 unprocessable entity object
 * @export
 * @interface PutFleetsFleetIdMembersMemberIdUnprocessableEntity
 */
export interface PutFleetsFleetIdMembersMemberIdUnprocessableEntity {
    /**
     * error message
     * @type {string}
     * @memberof PutFleetsFleetIdMembersMemberIdUnprocessableEntity
     */
    error?: string;
}

/**
 * new_settings object
 * @export
 * @interface PutFleetsFleetIdNewSettings
 */
export interface PutFleetsFleetIdNewSettings {
    /**
     * Should free-move be enabled in the fleet
     * @type {boolean}
     * @memberof PutFleetsFleetIdNewSettings
     */
    isFreeMove?: boolean;
    /**
     * New fleet MOTD in CCP flavoured HTML
     * @type {string}
     * @memberof PutFleetsFleetIdNewSettings
     */
    motd?: string;
}

/**
 * Not found
 * @export
 * @interface PutFleetsFleetIdNotFound
 */
export interface PutFleetsFleetIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof PutFleetsFleetIdNotFound
     */
    error?: string;
}

/**
 * naming object
 * @export
 * @interface PutFleetsFleetIdSquadsSquadIdNaming
 */
export interface PutFleetsFleetIdSquadsSquadIdNaming {
    /**
     * name string
     * @type {string}
     * @memberof PutFleetsFleetIdSquadsSquadIdNaming
     */
    name: string;
}

/**
 * Not found
 * @export
 * @interface PutFleetsFleetIdSquadsSquadIdNotFound
 */
export interface PutFleetsFleetIdSquadsSquadIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof PutFleetsFleetIdSquadsSquadIdNotFound
     */
    error?: string;
}

/**
 * naming object
 * @export
 * @interface PutFleetsFleetIdWingsWingIdNaming
 */
export interface PutFleetsFleetIdWingsWingIdNaming {
    /**
     * name string
     * @type {string}
     * @memberof PutFleetsFleetIdWingsWingIdNaming
     */
    name: string;
}

/**
 * Not found
 * @export
 * @interface PutFleetsFleetIdWingsWingIdNotFound
 */
export interface PutFleetsFleetIdWingsWingIdNotFound {
    /**
     * Not found message
     * @type {string}
     * @memberof PutFleetsFleetIdWingsWingIdNotFound
     */
    error?: string;
}

/**
 * Service unavailable model
 * @export
 * @interface ServiceUnavailable
 */
export interface ServiceUnavailable {
    /**
     * Service unavailable message
     * @type {string}
     * @memberof ServiceUnavailable
     */
    error: string;
}

/**
 * Unauthorized model
 * @export
 * @interface Unauthorized
 */
export interface Unauthorized {
    /**
     * Unauthorized message
     * @type {string}
     * @memberof Unauthorized
     */
    error: string;
}


/**
 * AllianceApi - fetch parameter creator
 * @export
 */
export const AllianceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all active player alliances  --- Alternate route: `/dev/alliances/`  Alternate route: `/legacy/alliances/`  Alternate route: `/v1/alliances/`  Alternate route: `/v2/alliances/`  --- This route is cached for up to 3600 seconds
         * @summary List all alliances
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlliances(datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            const localVarPath = `/alliances/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Public information about an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/`  Alternate route: `/legacy/alliances/{alliance_id}/`  Alternate route: `/v3/alliances/{alliance_id}/`  Alternate route: `/v4/alliances/{alliance_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get alliance information
         * @param {number} allianceId An EVE alliance ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlliancesAllianceId(allianceId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'allianceId' is not null or undefined
            if (allianceId === null || allianceId === undefined) {
                throw new RequiredError('allianceId','Required parameter allianceId was null or undefined when calling getAlliancesAllianceId.');
            }
            const localVarPath = `/alliances/{alliance_id}/`
                .replace(`{${"alliance_id"}}`, encodeURIComponent(String(allianceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all current member corporations of an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/corporations/`  Alternate route: `/legacy/alliances/{alliance_id}/corporations/`  Alternate route: `/v1/alliances/{alliance_id}/corporations/`  Alternate route: `/v2/alliances/{alliance_id}/corporations/`  --- This route is cached for up to 3600 seconds
         * @summary List alliance's corporations
         * @param {number} allianceId An EVE alliance ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlliancesAllianceIdCorporations(allianceId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'allianceId' is not null or undefined
            if (allianceId === null || allianceId === undefined) {
                throw new RequiredError('allianceId','Required parameter allianceId was null or undefined when calling getAlliancesAllianceIdCorporations.');
            }
            const localVarPath = `/alliances/{alliance_id}/corporations/`
                .replace(`{${"alliance_id"}}`, encodeURIComponent(String(allianceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the icon urls for a alliance  --- Alternate route: `/legacy/alliances/{alliance_id}/icons/`  Alternate route: `/v1/alliances/{alliance_id}/icons/`  --- This route expires daily at 11:05  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/alliances/{alliance_id}/icons/)
         * @summary Get alliance icon
         * @param {number} allianceId An EVE alliance ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlliancesAllianceIdIcons(allianceId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'allianceId' is not null or undefined
            if (allianceId === null || allianceId === undefined) {
                throw new RequiredError('allianceId','Required parameter allianceId was null or undefined when calling getAlliancesAllianceIdIcons.');
            }
            const localVarPath = `/alliances/{alliance_id}/icons/`
                .replace(`{${"alliance_id"}}`, encodeURIComponent(String(allianceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AllianceApi - functional programming interface
 * @export
 */
export const AllianceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List all active player alliances  --- Alternate route: `/dev/alliances/`  Alternate route: `/legacy/alliances/`  Alternate route: `/v1/alliances/`  Alternate route: `/v2/alliances/`  --- This route is cached for up to 3600 seconds
         * @summary List all alliances
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlliances(datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = AllianceApiFetchParamCreator(configuration).getAlliances(datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Public information about an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/`  Alternate route: `/legacy/alliances/{alliance_id}/`  Alternate route: `/v3/alliances/{alliance_id}/`  Alternate route: `/v4/alliances/{alliance_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get alliance information
         * @param {number} allianceId An EVE alliance ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlliancesAllianceId(allianceId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAlliancesAllianceIdOk> {
            const localVarFetchArgs = AllianceApiFetchParamCreator(configuration).getAlliancesAllianceId(allianceId, datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all current member corporations of an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/corporations/`  Alternate route: `/legacy/alliances/{alliance_id}/corporations/`  Alternate route: `/v1/alliances/{alliance_id}/corporations/`  Alternate route: `/v2/alliances/{alliance_id}/corporations/`  --- This route is cached for up to 3600 seconds
         * @summary List alliance's corporations
         * @param {number} allianceId An EVE alliance ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlliancesAllianceIdCorporations(allianceId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = AllianceApiFetchParamCreator(configuration).getAlliancesAllianceIdCorporations(allianceId, datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the icon urls for a alliance  --- Alternate route: `/legacy/alliances/{alliance_id}/icons/`  Alternate route: `/v1/alliances/{alliance_id}/icons/`  --- This route expires daily at 11:05  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/alliances/{alliance_id}/icons/)
         * @summary Get alliance icon
         * @param {number} allianceId An EVE alliance ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlliancesAllianceIdIcons(allianceId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAlliancesAllianceIdIconsOk> {
            const localVarFetchArgs = AllianceApiFetchParamCreator(configuration).getAlliancesAllianceIdIcons(allianceId, datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AllianceApi - factory interface
 * @export
 */
export const AllianceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * List all active player alliances  --- Alternate route: `/dev/alliances/`  Alternate route: `/legacy/alliances/`  Alternate route: `/v1/alliances/`  Alternate route: `/v2/alliances/`  --- This route is cached for up to 3600 seconds
         * @summary List all alliances
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlliances(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return AllianceApiFp(configuration).getAlliances(datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Public information about an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/`  Alternate route: `/legacy/alliances/{alliance_id}/`  Alternate route: `/v3/alliances/{alliance_id}/`  Alternate route: `/v4/alliances/{alliance_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get alliance information
         * @param {number} allianceId An EVE alliance ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlliancesAllianceId(allianceId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return AllianceApiFp(configuration).getAlliancesAllianceId(allianceId, datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * List all current member corporations of an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/corporations/`  Alternate route: `/legacy/alliances/{alliance_id}/corporations/`  Alternate route: `/v1/alliances/{alliance_id}/corporations/`  Alternate route: `/v2/alliances/{alliance_id}/corporations/`  --- This route is cached for up to 3600 seconds
         * @summary List alliance's corporations
         * @param {number} allianceId An EVE alliance ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlliancesAllianceIdCorporations(allianceId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return AllianceApiFp(configuration).getAlliancesAllianceIdCorporations(allianceId, datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Get the icon urls for a alliance  --- Alternate route: `/legacy/alliances/{alliance_id}/icons/`  Alternate route: `/v1/alliances/{alliance_id}/icons/`  --- This route expires daily at 11:05  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/alliances/{alliance_id}/icons/)
         * @summary Get alliance icon
         * @param {number} allianceId An EVE alliance ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlliancesAllianceIdIcons(allianceId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return AllianceApiFp(configuration).getAlliancesAllianceIdIcons(allianceId, datasource, ifNoneMatch, options)(fetch, basePath);
        },
    };
};

/**
 * AllianceApi - object-oriented interface
 * @export
 * @class AllianceApi
 * @extends {BaseAPI}
 */
export class AllianceApi extends BaseAPI {
    /**
     * List all active player alliances  --- Alternate route: `/dev/alliances/`  Alternate route: `/legacy/alliances/`  Alternate route: `/v1/alliances/`  Alternate route: `/v2/alliances/`  --- This route is cached for up to 3600 seconds
     * @summary List all alliances
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllianceApi
     */
    public getAlliances(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return AllianceApiFp(this.configuration).getAlliances(datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Public information about an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/`  Alternate route: `/legacy/alliances/{alliance_id}/`  Alternate route: `/v3/alliances/{alliance_id}/`  Alternate route: `/v4/alliances/{alliance_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get alliance information
     * @param {number} allianceId An EVE alliance ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllianceApi
     */
    public getAlliancesAllianceId(allianceId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return AllianceApiFp(this.configuration).getAlliancesAllianceId(allianceId, datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * List all current member corporations of an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/corporations/`  Alternate route: `/legacy/alliances/{alliance_id}/corporations/`  Alternate route: `/v1/alliances/{alliance_id}/corporations/`  Alternate route: `/v2/alliances/{alliance_id}/corporations/`  --- This route is cached for up to 3600 seconds
     * @summary List alliance's corporations
     * @param {number} allianceId An EVE alliance ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllianceApi
     */
    public getAlliancesAllianceIdCorporations(allianceId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return AllianceApiFp(this.configuration).getAlliancesAllianceIdCorporations(allianceId, datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Get the icon urls for a alliance  --- Alternate route: `/legacy/alliances/{alliance_id}/icons/`  Alternate route: `/v1/alliances/{alliance_id}/icons/`  --- This route expires daily at 11:05  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/alliances/{alliance_id}/icons/)
     * @summary Get alliance icon
     * @param {number} allianceId An EVE alliance ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllianceApi
     */
    public getAlliancesAllianceIdIcons(allianceId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return AllianceApiFp(this.configuration).getAlliancesAllianceIdIcons(allianceId, datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

}

/**
 * AssetsApi - fetch parameter creator
 * @export
 */
export const AssetsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return a list of the characters assets  --- Alternate route: `/dev/characters/{character_id}/assets/`  Alternate route: `/v5/characters/{character_id}/assets/`  --- This route is cached for up to 3600 seconds
         * @summary Get character assets
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdAssets(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdAssets.');
            }
            const localVarPath = `/characters/{character_id}/assets/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-assets.read_assets.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of the corporation assets  --- Alternate route: `/dev/corporations/{corporation_id}/assets/`  Alternate route: `/v5/corporations/{corporation_id}/assets/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation assets
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdAssets(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdAssets.');
            }
            const localVarPath = `/corporations/{corporation_id}/assets/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-assets.read_corporation_assets.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return locations for a set of item ids, which you can get from character assets endpoint. Coordinates for items in hangars or stations are set to (0,0,0)  --- Alternate route: `/dev/characters/{character_id}/assets/locations/`  Alternate route: `/v2/characters/{character_id}/assets/locations/` 
         * @summary Get character asset locations
         * @param {number} characterId An EVE character ID
         * @param {Array<number>} itemIds A list of item ids
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdAssetsLocations(characterId: number, itemIds: Array<number>, datasource?: 'tranquility', token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling postCharactersCharacterIdAssetsLocations.');
            }
            // verify required parameter 'itemIds' is not null or undefined
            if (itemIds === null || itemIds === undefined) {
                throw new RequiredError('itemIds','Required parameter itemIds was null or undefined when calling postCharactersCharacterIdAssetsLocations.');
            }
            const localVarPath = `/characters/{character_id}/assets/locations/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-assets.read_assets.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;number&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(itemIds || {}) : (itemIds || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return names for a set of item ids, which you can get from character assets endpoint. Typically used for items that can customize names, like containers or ships.  --- Alternate route: `/dev/characters/{character_id}/assets/names/`  Alternate route: `/legacy/characters/{character_id}/assets/names/`  Alternate route: `/v1/characters/{character_id}/assets/names/` 
         * @summary Get character asset names
         * @param {number} characterId An EVE character ID
         * @param {Array<number>} itemIds A list of item ids
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdAssetsNames(characterId: number, itemIds: Array<number>, datasource?: 'tranquility', token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling postCharactersCharacterIdAssetsNames.');
            }
            // verify required parameter 'itemIds' is not null or undefined
            if (itemIds === null || itemIds === undefined) {
                throw new RequiredError('itemIds','Required parameter itemIds was null or undefined when calling postCharactersCharacterIdAssetsNames.');
            }
            const localVarPath = `/characters/{character_id}/assets/names/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-assets.read_assets.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;number&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(itemIds || {}) : (itemIds || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return locations for a set of item ids, which you can get from corporation assets endpoint. Coordinates for items in hangars or stations are set to (0,0,0)  --- Alternate route: `/dev/corporations/{corporation_id}/assets/locations/`  Alternate route: `/v2/corporations/{corporation_id}/assets/locations/`   --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation asset locations
         * @param {number} corporationId An EVE corporation ID
         * @param {Array<number>} itemIds A list of item ids
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCorporationsCorporationIdAssetsLocations(corporationId: number, itemIds: Array<number>, datasource?: 'tranquility', token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling postCorporationsCorporationIdAssetsLocations.');
            }
            // verify required parameter 'itemIds' is not null or undefined
            if (itemIds === null || itemIds === undefined) {
                throw new RequiredError('itemIds','Required parameter itemIds was null or undefined when calling postCorporationsCorporationIdAssetsLocations.');
            }
            const localVarPath = `/corporations/{corporation_id}/assets/locations/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-assets.read_corporation_assets.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;number&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(itemIds || {}) : (itemIds || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return names for a set of item ids, which you can get from corporation assets endpoint. Only valid for items that can customize names, like containers or ships  --- Alternate route: `/dev/corporations/{corporation_id}/assets/names/`  Alternate route: `/legacy/corporations/{corporation_id}/assets/names/`  Alternate route: `/v1/corporations/{corporation_id}/assets/names/`   --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation asset names
         * @param {number} corporationId An EVE corporation ID
         * @param {Array<number>} itemIds A list of item ids
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCorporationsCorporationIdAssetsNames(corporationId: number, itemIds: Array<number>, datasource?: 'tranquility', token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling postCorporationsCorporationIdAssetsNames.');
            }
            // verify required parameter 'itemIds' is not null or undefined
            if (itemIds === null || itemIds === undefined) {
                throw new RequiredError('itemIds','Required parameter itemIds was null or undefined when calling postCorporationsCorporationIdAssetsNames.');
            }
            const localVarPath = `/corporations/{corporation_id}/assets/names/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-assets.read_corporation_assets.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;number&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(itemIds || {}) : (itemIds || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetsApi - functional programming interface
 * @export
 */
export const AssetsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Return a list of the characters assets  --- Alternate route: `/dev/characters/{character_id}/assets/`  Alternate route: `/v5/characters/{character_id}/assets/`  --- This route is cached for up to 3600 seconds
         * @summary Get character assets
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdAssets(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCharactersCharacterIdAssets200Ok>> {
            const localVarFetchArgs = AssetsApiFetchParamCreator(configuration).getCharactersCharacterIdAssets(characterId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a list of the corporation assets  --- Alternate route: `/dev/corporations/{corporation_id}/assets/`  Alternate route: `/v5/corporations/{corporation_id}/assets/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation assets
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdAssets(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationsCorporationIdAssets200Ok>> {
            const localVarFetchArgs = AssetsApiFetchParamCreator(configuration).getCorporationsCorporationIdAssets(corporationId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return locations for a set of item ids, which you can get from character assets endpoint. Coordinates for items in hangars or stations are set to (0,0,0)  --- Alternate route: `/dev/characters/{character_id}/assets/locations/`  Alternate route: `/v2/characters/{character_id}/assets/locations/` 
         * @summary Get character asset locations
         * @param {number} characterId An EVE character ID
         * @param {Array<number>} itemIds A list of item ids
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdAssetsLocations(characterId: number, itemIds: Array<number>, datasource?: 'tranquility', token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PostCharactersCharacterIdAssetsLocations200Ok>> {
            const localVarFetchArgs = AssetsApiFetchParamCreator(configuration).postCharactersCharacterIdAssetsLocations(characterId, itemIds, datasource, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return names for a set of item ids, which you can get from character assets endpoint. Typically used for items that can customize names, like containers or ships.  --- Alternate route: `/dev/characters/{character_id}/assets/names/`  Alternate route: `/legacy/characters/{character_id}/assets/names/`  Alternate route: `/v1/characters/{character_id}/assets/names/` 
         * @summary Get character asset names
         * @param {number} characterId An EVE character ID
         * @param {Array<number>} itemIds A list of item ids
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdAssetsNames(characterId: number, itemIds: Array<number>, datasource?: 'tranquility', token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PostCharactersCharacterIdAssetsNames200Ok>> {
            const localVarFetchArgs = AssetsApiFetchParamCreator(configuration).postCharactersCharacterIdAssetsNames(characterId, itemIds, datasource, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return locations for a set of item ids, which you can get from corporation assets endpoint. Coordinates for items in hangars or stations are set to (0,0,0)  --- Alternate route: `/dev/corporations/{corporation_id}/assets/locations/`  Alternate route: `/v2/corporations/{corporation_id}/assets/locations/`   --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation asset locations
         * @param {number} corporationId An EVE corporation ID
         * @param {Array<number>} itemIds A list of item ids
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCorporationsCorporationIdAssetsLocations(corporationId: number, itemIds: Array<number>, datasource?: 'tranquility', token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PostCorporationsCorporationIdAssetsLocations200Ok>> {
            const localVarFetchArgs = AssetsApiFetchParamCreator(configuration).postCorporationsCorporationIdAssetsLocations(corporationId, itemIds, datasource, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return names for a set of item ids, which you can get from corporation assets endpoint. Only valid for items that can customize names, like containers or ships  --- Alternate route: `/dev/corporations/{corporation_id}/assets/names/`  Alternate route: `/legacy/corporations/{corporation_id}/assets/names/`  Alternate route: `/v1/corporations/{corporation_id}/assets/names/`   --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation asset names
         * @param {number} corporationId An EVE corporation ID
         * @param {Array<number>} itemIds A list of item ids
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCorporationsCorporationIdAssetsNames(corporationId: number, itemIds: Array<number>, datasource?: 'tranquility', token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PostCorporationsCorporationIdAssetsNames200Ok>> {
            const localVarFetchArgs = AssetsApiFetchParamCreator(configuration).postCorporationsCorporationIdAssetsNames(corporationId, itemIds, datasource, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AssetsApi - factory interface
 * @export
 */
export const AssetsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Return a list of the characters assets  --- Alternate route: `/dev/characters/{character_id}/assets/`  Alternate route: `/v5/characters/{character_id}/assets/`  --- This route is cached for up to 3600 seconds
         * @summary Get character assets
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdAssets(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return AssetsApiFp(configuration).getCharactersCharacterIdAssets(characterId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
        /**
         * Return a list of the corporation assets  --- Alternate route: `/dev/corporations/{corporation_id}/assets/`  Alternate route: `/v5/corporations/{corporation_id}/assets/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation assets
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdAssets(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return AssetsApiFp(configuration).getCorporationsCorporationIdAssets(corporationId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
        /**
         * Return locations for a set of item ids, which you can get from character assets endpoint. Coordinates for items in hangars or stations are set to (0,0,0)  --- Alternate route: `/dev/characters/{character_id}/assets/locations/`  Alternate route: `/v2/characters/{character_id}/assets/locations/` 
         * @summary Get character asset locations
         * @param {number} characterId An EVE character ID
         * @param {Array<number>} itemIds A list of item ids
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdAssetsLocations(characterId: number, itemIds: Array<number>, datasource?: 'tranquility', token?: string, options?: any) {
            return AssetsApiFp(configuration).postCharactersCharacterIdAssetsLocations(characterId, itemIds, datasource, token, options)(fetch, basePath);
        },
        /**
         * Return names for a set of item ids, which you can get from character assets endpoint. Typically used for items that can customize names, like containers or ships.  --- Alternate route: `/dev/characters/{character_id}/assets/names/`  Alternate route: `/legacy/characters/{character_id}/assets/names/`  Alternate route: `/v1/characters/{character_id}/assets/names/` 
         * @summary Get character asset names
         * @param {number} characterId An EVE character ID
         * @param {Array<number>} itemIds A list of item ids
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdAssetsNames(characterId: number, itemIds: Array<number>, datasource?: 'tranquility', token?: string, options?: any) {
            return AssetsApiFp(configuration).postCharactersCharacterIdAssetsNames(characterId, itemIds, datasource, token, options)(fetch, basePath);
        },
        /**
         * Return locations for a set of item ids, which you can get from corporation assets endpoint. Coordinates for items in hangars or stations are set to (0,0,0)  --- Alternate route: `/dev/corporations/{corporation_id}/assets/locations/`  Alternate route: `/v2/corporations/{corporation_id}/assets/locations/`   --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation asset locations
         * @param {number} corporationId An EVE corporation ID
         * @param {Array<number>} itemIds A list of item ids
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCorporationsCorporationIdAssetsLocations(corporationId: number, itemIds: Array<number>, datasource?: 'tranquility', token?: string, options?: any) {
            return AssetsApiFp(configuration).postCorporationsCorporationIdAssetsLocations(corporationId, itemIds, datasource, token, options)(fetch, basePath);
        },
        /**
         * Return names for a set of item ids, which you can get from corporation assets endpoint. Only valid for items that can customize names, like containers or ships  --- Alternate route: `/dev/corporations/{corporation_id}/assets/names/`  Alternate route: `/legacy/corporations/{corporation_id}/assets/names/`  Alternate route: `/v1/corporations/{corporation_id}/assets/names/`   --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation asset names
         * @param {number} corporationId An EVE corporation ID
         * @param {Array<number>} itemIds A list of item ids
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCorporationsCorporationIdAssetsNames(corporationId: number, itemIds: Array<number>, datasource?: 'tranquility', token?: string, options?: any) {
            return AssetsApiFp(configuration).postCorporationsCorporationIdAssetsNames(corporationId, itemIds, datasource, token, options)(fetch, basePath);
        },
    };
};

/**
 * AssetsApi - object-oriented interface
 * @export
 * @class AssetsApi
 * @extends {BaseAPI}
 */
export class AssetsApi extends BaseAPI {
    /**
     * Return a list of the characters assets  --- Alternate route: `/dev/characters/{character_id}/assets/`  Alternate route: `/v5/characters/{character_id}/assets/`  --- This route is cached for up to 3600 seconds
     * @summary Get character assets
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public getCharactersCharacterIdAssets(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return AssetsApiFp(this.configuration).getCharactersCharacterIdAssets(characterId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return a list of the corporation assets  --- Alternate route: `/dev/corporations/{corporation_id}/assets/`  Alternate route: `/v5/corporations/{corporation_id}/assets/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation assets
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public getCorporationsCorporationIdAssets(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return AssetsApiFp(this.configuration).getCorporationsCorporationIdAssets(corporationId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return locations for a set of item ids, which you can get from character assets endpoint. Coordinates for items in hangars or stations are set to (0,0,0)  --- Alternate route: `/dev/characters/{character_id}/assets/locations/`  Alternate route: `/v2/characters/{character_id}/assets/locations/` 
     * @summary Get character asset locations
     * @param {number} characterId An EVE character ID
     * @param {Array<number>} itemIds A list of item ids
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public postCharactersCharacterIdAssetsLocations(characterId: number, itemIds: Array<number>, datasource?: 'tranquility', token?: string, options?: any) {
        return AssetsApiFp(this.configuration).postCharactersCharacterIdAssetsLocations(characterId, itemIds, datasource, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return names for a set of item ids, which you can get from character assets endpoint. Typically used for items that can customize names, like containers or ships.  --- Alternate route: `/dev/characters/{character_id}/assets/names/`  Alternate route: `/legacy/characters/{character_id}/assets/names/`  Alternate route: `/v1/characters/{character_id}/assets/names/` 
     * @summary Get character asset names
     * @param {number} characterId An EVE character ID
     * @param {Array<number>} itemIds A list of item ids
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public postCharactersCharacterIdAssetsNames(characterId: number, itemIds: Array<number>, datasource?: 'tranquility', token?: string, options?: any) {
        return AssetsApiFp(this.configuration).postCharactersCharacterIdAssetsNames(characterId, itemIds, datasource, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return locations for a set of item ids, which you can get from corporation assets endpoint. Coordinates for items in hangars or stations are set to (0,0,0)  --- Alternate route: `/dev/corporations/{corporation_id}/assets/locations/`  Alternate route: `/v2/corporations/{corporation_id}/assets/locations/`   --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation asset locations
     * @param {number} corporationId An EVE corporation ID
     * @param {Array<number>} itemIds A list of item ids
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public postCorporationsCorporationIdAssetsLocations(corporationId: number, itemIds: Array<number>, datasource?: 'tranquility', token?: string, options?: any) {
        return AssetsApiFp(this.configuration).postCorporationsCorporationIdAssetsLocations(corporationId, itemIds, datasource, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return names for a set of item ids, which you can get from corporation assets endpoint. Only valid for items that can customize names, like containers or ships  --- Alternate route: `/dev/corporations/{corporation_id}/assets/names/`  Alternate route: `/legacy/corporations/{corporation_id}/assets/names/`  Alternate route: `/v1/corporations/{corporation_id}/assets/names/`   --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation asset names
     * @param {number} corporationId An EVE corporation ID
     * @param {Array<number>} itemIds A list of item ids
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public postCorporationsCorporationIdAssetsNames(corporationId: number, itemIds: Array<number>, datasource?: 'tranquility', token?: string, options?: any) {
        return AssetsApiFp(this.configuration).postCorporationsCorporationIdAssetsNames(corporationId, itemIds, datasource, token, options)(this.fetch, this.basePath);
    }

}

/**
 * BookmarksApi - fetch parameter creator
 * @export
 */
export const BookmarksApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A list of your character's personal bookmarks  --- Alternate route: `/dev/characters/{character_id}/bookmarks/`  Alternate route: `/v2/characters/{character_id}/bookmarks/`  --- This route is cached for up to 3600 seconds
         * @summary List bookmarks
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdBookmarks(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdBookmarks.');
            }
            const localVarPath = `/characters/{character_id}/bookmarks/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-bookmarks.read_character_bookmarks.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A list of your character's personal bookmark folders  --- Alternate route: `/dev/characters/{character_id}/bookmarks/folders/`  Alternate route: `/v2/characters/{character_id}/bookmarks/folders/`  --- This route is cached for up to 3600 seconds
         * @summary List bookmark folders
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdBookmarksFolders(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdBookmarksFolders.');
            }
            const localVarPath = `/characters/{character_id}/bookmarks/folders/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-bookmarks.read_character_bookmarks.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A list of your corporation's bookmarks  --- Alternate route: `/dev/corporations/{corporation_id}/bookmarks/`  Alternate route: `/legacy/corporations/{corporation_id}/bookmarks/`  Alternate route: `/v1/corporations/{corporation_id}/bookmarks/`  --- This route is cached for up to 3600 seconds
         * @summary List corporation bookmarks
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdBookmarks(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdBookmarks.');
            }
            const localVarPath = `/corporations/{corporation_id}/bookmarks/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-bookmarks.read_corporation_bookmarks.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A list of your corporation's bookmark folders  --- Alternate route: `/dev/corporations/{corporation_id}/bookmarks/folders/`  Alternate route: `/legacy/corporations/{corporation_id}/bookmarks/folders/`  Alternate route: `/v1/corporations/{corporation_id}/bookmarks/folders/`  --- This route is cached for up to 3600 seconds
         * @summary List corporation bookmark folders
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdBookmarksFolders(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdBookmarksFolders.');
            }
            const localVarPath = `/corporations/{corporation_id}/bookmarks/folders/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-bookmarks.read_corporation_bookmarks.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BookmarksApi - functional programming interface
 * @export
 */
export const BookmarksApiFp = function(configuration?: Configuration) {
    return {
        /**
         * A list of your character's personal bookmarks  --- Alternate route: `/dev/characters/{character_id}/bookmarks/`  Alternate route: `/v2/characters/{character_id}/bookmarks/`  --- This route is cached for up to 3600 seconds
         * @summary List bookmarks
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdBookmarks(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCharactersCharacterIdBookmarks200Ok>> {
            const localVarFetchArgs = BookmarksApiFetchParamCreator(configuration).getCharactersCharacterIdBookmarks(characterId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * A list of your character's personal bookmark folders  --- Alternate route: `/dev/characters/{character_id}/bookmarks/folders/`  Alternate route: `/v2/characters/{character_id}/bookmarks/folders/`  --- This route is cached for up to 3600 seconds
         * @summary List bookmark folders
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdBookmarksFolders(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCharactersCharacterIdBookmarksFolders200Ok>> {
            const localVarFetchArgs = BookmarksApiFetchParamCreator(configuration).getCharactersCharacterIdBookmarksFolders(characterId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * A list of your corporation's bookmarks  --- Alternate route: `/dev/corporations/{corporation_id}/bookmarks/`  Alternate route: `/legacy/corporations/{corporation_id}/bookmarks/`  Alternate route: `/v1/corporations/{corporation_id}/bookmarks/`  --- This route is cached for up to 3600 seconds
         * @summary List corporation bookmarks
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdBookmarks(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationsCorporationIdBookmarks200Ok>> {
            const localVarFetchArgs = BookmarksApiFetchParamCreator(configuration).getCorporationsCorporationIdBookmarks(corporationId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * A list of your corporation's bookmark folders  --- Alternate route: `/dev/corporations/{corporation_id}/bookmarks/folders/`  Alternate route: `/legacy/corporations/{corporation_id}/bookmarks/folders/`  Alternate route: `/v1/corporations/{corporation_id}/bookmarks/folders/`  --- This route is cached for up to 3600 seconds
         * @summary List corporation bookmark folders
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdBookmarksFolders(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationsCorporationIdBookmarksFolders200Ok>> {
            const localVarFetchArgs = BookmarksApiFetchParamCreator(configuration).getCorporationsCorporationIdBookmarksFolders(corporationId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BookmarksApi - factory interface
 * @export
 */
export const BookmarksApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * A list of your character's personal bookmarks  --- Alternate route: `/dev/characters/{character_id}/bookmarks/`  Alternate route: `/v2/characters/{character_id}/bookmarks/`  --- This route is cached for up to 3600 seconds
         * @summary List bookmarks
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdBookmarks(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return BookmarksApiFp(configuration).getCharactersCharacterIdBookmarks(characterId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
        /**
         * A list of your character's personal bookmark folders  --- Alternate route: `/dev/characters/{character_id}/bookmarks/folders/`  Alternate route: `/v2/characters/{character_id}/bookmarks/folders/`  --- This route is cached for up to 3600 seconds
         * @summary List bookmark folders
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdBookmarksFolders(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return BookmarksApiFp(configuration).getCharactersCharacterIdBookmarksFolders(characterId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
        /**
         * A list of your corporation's bookmarks  --- Alternate route: `/dev/corporations/{corporation_id}/bookmarks/`  Alternate route: `/legacy/corporations/{corporation_id}/bookmarks/`  Alternate route: `/v1/corporations/{corporation_id}/bookmarks/`  --- This route is cached for up to 3600 seconds
         * @summary List corporation bookmarks
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdBookmarks(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return BookmarksApiFp(configuration).getCorporationsCorporationIdBookmarks(corporationId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
        /**
         * A list of your corporation's bookmark folders  --- Alternate route: `/dev/corporations/{corporation_id}/bookmarks/folders/`  Alternate route: `/legacy/corporations/{corporation_id}/bookmarks/folders/`  Alternate route: `/v1/corporations/{corporation_id}/bookmarks/folders/`  --- This route is cached for up to 3600 seconds
         * @summary List corporation bookmark folders
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdBookmarksFolders(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return BookmarksApiFp(configuration).getCorporationsCorporationIdBookmarksFolders(corporationId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
    };
};

/**
 * BookmarksApi - object-oriented interface
 * @export
 * @class BookmarksApi
 * @extends {BaseAPI}
 */
export class BookmarksApi extends BaseAPI {
    /**
     * A list of your character's personal bookmarks  --- Alternate route: `/dev/characters/{character_id}/bookmarks/`  Alternate route: `/v2/characters/{character_id}/bookmarks/`  --- This route is cached for up to 3600 seconds
     * @summary List bookmarks
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookmarksApi
     */
    public getCharactersCharacterIdBookmarks(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return BookmarksApiFp(this.configuration).getCharactersCharacterIdBookmarks(characterId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * A list of your character's personal bookmark folders  --- Alternate route: `/dev/characters/{character_id}/bookmarks/folders/`  Alternate route: `/v2/characters/{character_id}/bookmarks/folders/`  --- This route is cached for up to 3600 seconds
     * @summary List bookmark folders
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookmarksApi
     */
    public getCharactersCharacterIdBookmarksFolders(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return BookmarksApiFp(this.configuration).getCharactersCharacterIdBookmarksFolders(characterId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * A list of your corporation's bookmarks  --- Alternate route: `/dev/corporations/{corporation_id}/bookmarks/`  Alternate route: `/legacy/corporations/{corporation_id}/bookmarks/`  Alternate route: `/v1/corporations/{corporation_id}/bookmarks/`  --- This route is cached for up to 3600 seconds
     * @summary List corporation bookmarks
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookmarksApi
     */
    public getCorporationsCorporationIdBookmarks(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return BookmarksApiFp(this.configuration).getCorporationsCorporationIdBookmarks(corporationId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * A list of your corporation's bookmark folders  --- Alternate route: `/dev/corporations/{corporation_id}/bookmarks/folders/`  Alternate route: `/legacy/corporations/{corporation_id}/bookmarks/folders/`  Alternate route: `/v1/corporations/{corporation_id}/bookmarks/folders/`  --- This route is cached for up to 3600 seconds
     * @summary List corporation bookmark folders
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookmarksApi
     */
    public getCorporationsCorporationIdBookmarksFolders(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return BookmarksApiFp(this.configuration).getCorporationsCorporationIdBookmarksFolders(corporationId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

}

/**
 * CalendarApi - fetch parameter creator
 * @export
 */
export const CalendarApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get 50 event summaries from the calendar. If no from_event ID is given, the resource will return the next 50 chronological event summaries from now. If a from_event ID is specified, it will return the next 50 chronological event summaries from after that event  --- Alternate route: `/dev/characters/{character_id}/calendar/`  Alternate route: `/legacy/characters/{character_id}/calendar/`  Alternate route: `/v1/characters/{character_id}/calendar/`  Alternate route: `/v2/characters/{character_id}/calendar/`  --- This route is cached for up to 5 seconds
         * @summary List calendar event summaries
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {number} [fromEvent] The event ID to retrieve events from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdCalendar(characterId: number, datasource?: 'tranquility', fromEvent?: number, ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdCalendar.');
            }
            const localVarPath = `/characters/{character_id}/calendar/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-calendar.read_calendar_events.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (fromEvent !== undefined) {
                localVarQueryParameter['from_event'] = fromEvent;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all the information for a specific event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v3/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v4/characters/{character_id}/calendar/{event_id}/`  --- This route is cached for up to 5 seconds
         * @summary Get an event
         * @param {number} characterId An EVE character ID
         * @param {number} eventId The id of the event requested
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdCalendarEventId(characterId: number, eventId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdCalendarEventId.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling getCharactersCharacterIdCalendarEventId.');
            }
            const localVarPath = `/characters/{character_id}/calendar/{event_id}/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)))
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-calendar.read_calendar_events.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all invited attendees for a given event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/v1/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/v2/characters/{character_id}/calendar/{event_id}/attendees/`  --- This route is cached for up to 600 seconds
         * @summary Get attendees
         * @param {number} characterId An EVE character ID
         * @param {number} eventId The id of the event requested
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdCalendarEventIdAttendees(characterId: number, eventId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdCalendarEventIdAttendees.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling getCharactersCharacterIdCalendarEventIdAttendees.');
            }
            const localVarPath = `/characters/{character_id}/calendar/{event_id}/attendees/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)))
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-calendar.read_calendar_events.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set your response status to an event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v3/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v4/characters/{character_id}/calendar/{event_id}/`  --- This route is cached for up to 5 seconds
         * @summary Respond to an event
         * @param {number} characterId An EVE character ID
         * @param {number} eventId The ID of the event requested
         * @param {PutCharactersCharacterIdCalendarEventIdResponse} response The response value to set, overriding current value
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCharactersCharacterIdCalendarEventId(characterId: number, eventId: number, response: PutCharactersCharacterIdCalendarEventIdResponse, datasource?: 'tranquility', token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling putCharactersCharacterIdCalendarEventId.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling putCharactersCharacterIdCalendarEventId.');
            }
            // verify required parameter 'response' is not null or undefined
            if (response === null || response === undefined) {
                throw new RequiredError('response','Required parameter response was null or undefined when calling putCharactersCharacterIdCalendarEventId.');
            }
            const localVarPath = `/characters/{character_id}/calendar/{event_id}/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)))
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-calendar.respond_calendar_events.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PutCharactersCharacterIdCalendarEventIdResponse" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(response || {}) : (response || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CalendarApi - functional programming interface
 * @export
 */
export const CalendarApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get 50 event summaries from the calendar. If no from_event ID is given, the resource will return the next 50 chronological event summaries from now. If a from_event ID is specified, it will return the next 50 chronological event summaries from after that event  --- Alternate route: `/dev/characters/{character_id}/calendar/`  Alternate route: `/legacy/characters/{character_id}/calendar/`  Alternate route: `/v1/characters/{character_id}/calendar/`  Alternate route: `/v2/characters/{character_id}/calendar/`  --- This route is cached for up to 5 seconds
         * @summary List calendar event summaries
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {number} [fromEvent] The event ID to retrieve events from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdCalendar(characterId: number, datasource?: 'tranquility', fromEvent?: number, ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCharactersCharacterIdCalendar200Ok>> {
            const localVarFetchArgs = CalendarApiFetchParamCreator(configuration).getCharactersCharacterIdCalendar(characterId, datasource, fromEvent, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all the information for a specific event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v3/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v4/characters/{character_id}/calendar/{event_id}/`  --- This route is cached for up to 5 seconds
         * @summary Get an event
         * @param {number} characterId An EVE character ID
         * @param {number} eventId The id of the event requested
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdCalendarEventId(characterId: number, eventId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCharactersCharacterIdCalendarEventIdOk> {
            const localVarFetchArgs = CalendarApiFetchParamCreator(configuration).getCharactersCharacterIdCalendarEventId(characterId, eventId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all invited attendees for a given event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/v1/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/v2/characters/{character_id}/calendar/{event_id}/attendees/`  --- This route is cached for up to 600 seconds
         * @summary Get attendees
         * @param {number} characterId An EVE character ID
         * @param {number} eventId The id of the event requested
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdCalendarEventIdAttendees(characterId: number, eventId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCharactersCharacterIdCalendarEventIdAttendees200Ok>> {
            const localVarFetchArgs = CalendarApiFetchParamCreator(configuration).getCharactersCharacterIdCalendarEventIdAttendees(characterId, eventId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Set your response status to an event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v3/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v4/characters/{character_id}/calendar/{event_id}/`  --- This route is cached for up to 5 seconds
         * @summary Respond to an event
         * @param {number} characterId An EVE character ID
         * @param {number} eventId The ID of the event requested
         * @param {PutCharactersCharacterIdCalendarEventIdResponse} response The response value to set, overriding current value
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCharactersCharacterIdCalendarEventId(characterId: number, eventId: number, response: PutCharactersCharacterIdCalendarEventIdResponse, datasource?: 'tranquility', token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CalendarApiFetchParamCreator(configuration).putCharactersCharacterIdCalendarEventId(characterId, eventId, response, datasource, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CalendarApi - factory interface
 * @export
 */
export const CalendarApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get 50 event summaries from the calendar. If no from_event ID is given, the resource will return the next 50 chronological event summaries from now. If a from_event ID is specified, it will return the next 50 chronological event summaries from after that event  --- Alternate route: `/dev/characters/{character_id}/calendar/`  Alternate route: `/legacy/characters/{character_id}/calendar/`  Alternate route: `/v1/characters/{character_id}/calendar/`  Alternate route: `/v2/characters/{character_id}/calendar/`  --- This route is cached for up to 5 seconds
         * @summary List calendar event summaries
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {number} [fromEvent] The event ID to retrieve events from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdCalendar(characterId: number, datasource?: 'tranquility', fromEvent?: number, ifNoneMatch?: string, token?: string, options?: any) {
            return CalendarApiFp(configuration).getCharactersCharacterIdCalendar(characterId, datasource, fromEvent, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Get all the information for a specific event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v3/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v4/characters/{character_id}/calendar/{event_id}/`  --- This route is cached for up to 5 seconds
         * @summary Get an event
         * @param {number} characterId An EVE character ID
         * @param {number} eventId The id of the event requested
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdCalendarEventId(characterId: number, eventId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return CalendarApiFp(configuration).getCharactersCharacterIdCalendarEventId(characterId, eventId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Get all invited attendees for a given event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/v1/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/v2/characters/{character_id}/calendar/{event_id}/attendees/`  --- This route is cached for up to 600 seconds
         * @summary Get attendees
         * @param {number} characterId An EVE character ID
         * @param {number} eventId The id of the event requested
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdCalendarEventIdAttendees(characterId: number, eventId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return CalendarApiFp(configuration).getCharactersCharacterIdCalendarEventIdAttendees(characterId, eventId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Set your response status to an event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v3/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v4/characters/{character_id}/calendar/{event_id}/`  --- This route is cached for up to 5 seconds
         * @summary Respond to an event
         * @param {number} characterId An EVE character ID
         * @param {number} eventId The ID of the event requested
         * @param {PutCharactersCharacterIdCalendarEventIdResponse} response The response value to set, overriding current value
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCharactersCharacterIdCalendarEventId(characterId: number, eventId: number, response: PutCharactersCharacterIdCalendarEventIdResponse, datasource?: 'tranquility', token?: string, options?: any) {
            return CalendarApiFp(configuration).putCharactersCharacterIdCalendarEventId(characterId, eventId, response, datasource, token, options)(fetch, basePath);
        },
    };
};

/**
 * CalendarApi - object-oriented interface
 * @export
 * @class CalendarApi
 * @extends {BaseAPI}
 */
export class CalendarApi extends BaseAPI {
    /**
     * Get 50 event summaries from the calendar. If no from_event ID is given, the resource will return the next 50 chronological event summaries from now. If a from_event ID is specified, it will return the next 50 chronological event summaries from after that event  --- Alternate route: `/dev/characters/{character_id}/calendar/`  Alternate route: `/legacy/characters/{character_id}/calendar/`  Alternate route: `/v1/characters/{character_id}/calendar/`  Alternate route: `/v2/characters/{character_id}/calendar/`  --- This route is cached for up to 5 seconds
     * @summary List calendar event summaries
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {number} [fromEvent] The event ID to retrieve events from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarApi
     */
    public getCharactersCharacterIdCalendar(characterId: number, datasource?: 'tranquility', fromEvent?: number, ifNoneMatch?: string, token?: string, options?: any) {
        return CalendarApiFp(this.configuration).getCharactersCharacterIdCalendar(characterId, datasource, fromEvent, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Get all the information for a specific event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v3/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v4/characters/{character_id}/calendar/{event_id}/`  --- This route is cached for up to 5 seconds
     * @summary Get an event
     * @param {number} characterId An EVE character ID
     * @param {number} eventId The id of the event requested
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarApi
     */
    public getCharactersCharacterIdCalendarEventId(characterId: number, eventId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return CalendarApiFp(this.configuration).getCharactersCharacterIdCalendarEventId(characterId, eventId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Get all invited attendees for a given event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/v1/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/v2/characters/{character_id}/calendar/{event_id}/attendees/`  --- This route is cached for up to 600 seconds
     * @summary Get attendees
     * @param {number} characterId An EVE character ID
     * @param {number} eventId The id of the event requested
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarApi
     */
    public getCharactersCharacterIdCalendarEventIdAttendees(characterId: number, eventId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return CalendarApiFp(this.configuration).getCharactersCharacterIdCalendarEventIdAttendees(characterId, eventId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Set your response status to an event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v3/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v4/characters/{character_id}/calendar/{event_id}/`  --- This route is cached for up to 5 seconds
     * @summary Respond to an event
     * @param {number} characterId An EVE character ID
     * @param {number} eventId The ID of the event requested
     * @param {PutCharactersCharacterIdCalendarEventIdResponse} response The response value to set, overriding current value
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarApi
     */
    public putCharactersCharacterIdCalendarEventId(characterId: number, eventId: number, response: PutCharactersCharacterIdCalendarEventIdResponse, datasource?: 'tranquility', token?: string, options?: any) {
        return CalendarApiFp(this.configuration).putCharactersCharacterIdCalendarEventId(characterId, eventId, response, datasource, token, options)(this.fetch, this.basePath);
    }

}

/**
 * CharacterApi - fetch parameter creator
 * @export
 */
export const CharacterApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Public information about a character  --- Alternate route: `/dev/characters/{character_id}/`  Alternate route: `/legacy/characters/{character_id}/`  Alternate route: `/v5/characters/{character_id}/`  --- This route is cached for up to 86400 seconds
         * @summary Get character's public information
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterId(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterId.');
            }
            const localVarPath = `/characters/{character_id}/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of agents research information for a character. The formula for finding the current research points with an agent is: currentPoints = remainderPoints + pointsPerDay * days(currentTime - researchStartDate)  --- Alternate route: `/dev/characters/{character_id}/agents_research/`  Alternate route: `/v2/characters/{character_id}/agents_research/`  --- This route is cached for up to 3600 seconds
         * @summary Get agents research
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdAgentsResearch(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdAgentsResearch.');
            }
            const localVarPath = `/characters/{character_id}/agents_research/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-characters.read_agents_research.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of blueprints the character owns  --- Alternate route: `/dev/characters/{character_id}/blueprints/`  Alternate route: `/v3/characters/{character_id}/blueprints/`  --- This route is cached for up to 3600 seconds
         * @summary Get blueprints
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdBlueprints(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdBlueprints.');
            }
            const localVarPath = `/characters/{character_id}/blueprints/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-characters.read_blueprints.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all the corporations a character has been a member of  --- Alternate route: `/dev/characters/{character_id}/corporationhistory/`  Alternate route: `/v2/characters/{character_id}/corporationhistory/`  --- This route is cached for up to 86400 seconds
         * @summary Get corporation history
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdCorporationhistory(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdCorporationhistory.');
            }
            const localVarPath = `/characters/{character_id}/corporationhistory/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a character's jump activation and fatigue information  --- Alternate route: `/dev/characters/{character_id}/fatigue/`  Alternate route: `/v2/characters/{character_id}/fatigue/`  --- This route is cached for up to 300 seconds
         * @summary Get jump fatigue
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdFatigue(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdFatigue.');
            }
            const localVarPath = `/characters/{character_id}/fatigue/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-characters.read_fatigue.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of medals the character has  --- Alternate route: `/dev/characters/{character_id}/medals/`  Alternate route: `/v2/characters/{character_id}/medals/`  --- This route is cached for up to 3600 seconds
         * @summary Get medals
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdMedals(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdMedals.');
            }
            const localVarPath = `/characters/{character_id}/medals/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-characters.read_medals.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return character notifications  --- Alternate route: `/dev/characters/{character_id}/notifications/`  Alternate route: `/v5/characters/{character_id}/notifications/`  Alternate route: `/v6/characters/{character_id}/notifications/`  --- This route is cached for up to 600 seconds
         * @summary Get character notifications
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdNotifications(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdNotifications.');
            }
            const localVarPath = `/characters/{character_id}/notifications/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-characters.read_notifications.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return notifications about having been added to someone's contact list  --- Alternate route: `/dev/characters/{character_id}/notifications/contacts/`  Alternate route: `/v2/characters/{character_id}/notifications/contacts/`  --- This route is cached for up to 600 seconds
         * @summary Get new contact notifications
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdNotificationsContacts(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdNotificationsContacts.');
            }
            const localVarPath = `/characters/{character_id}/notifications/contacts/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-characters.read_notifications.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get portrait urls for a character  --- Alternate route: `/dev/characters/{character_id}/portrait/`  Alternate route: `/v2/characters/{character_id}/portrait/`  Alternate route: `/v3/characters/{character_id}/portrait/`  --- This route expires daily at 11:05
         * @summary Get character portraits
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdPortrait(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdPortrait.');
            }
            const localVarPath = `/characters/{character_id}/portrait/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a character's corporation roles  --- Alternate route: `/dev/characters/{character_id}/roles/`  Alternate route: `/v3/characters/{character_id}/roles/`  --- This route is cached for up to 3600 seconds
         * @summary Get character corporation roles
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdRoles(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdRoles.');
            }
            const localVarPath = `/characters/{character_id}/roles/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-characters.read_corporation_roles.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return character standings from agents, NPC corporations, and factions  --- Alternate route: `/dev/characters/{character_id}/standings/`  Alternate route: `/v2/characters/{character_id}/standings/`  --- This route is cached for up to 3600 seconds
         * @summary Get standings
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdStandings(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdStandings.');
            }
            const localVarPath = `/characters/{character_id}/standings/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-characters.read_standings.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a character's titles  --- Alternate route: `/dev/characters/{character_id}/titles/`  Alternate route: `/v2/characters/{character_id}/titles/`  --- This route is cached for up to 3600 seconds
         * @summary Get character corporation titles
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdTitles(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdTitles.');
            }
            const localVarPath = `/characters/{character_id}/titles/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-characters.read_titles.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bulk lookup of character IDs to corporation, alliance and faction  --- Alternate route: `/dev/characters/affiliation/`  Alternate route: `/v2/characters/affiliation/`  --- This route is cached for up to 3600 seconds
         * @summary Character affiliation
         * @param {Array<number>} characters The character IDs to fetch affiliations for. All characters must exist, or none will be returned
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersAffiliation(characters: Array<number>, datasource?: 'tranquility', options: any = {}): FetchArgs {
            // verify required parameter 'characters' is not null or undefined
            if (characters === null || characters === undefined) {
                throw new RequiredError('characters','Required parameter characters was null or undefined when calling postCharactersAffiliation.');
            }
            const localVarPath = `/characters/affiliation/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;number&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(characters || {}) : (characters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a source character ID in the url and a set of target character ID's in the body, returns a CSPA charge cost  --- Alternate route: `/dev/characters/{character_id}/cspa/`  Alternate route: `/v5/characters/{character_id}/cspa/` 
         * @summary Calculate a CSPA charge cost
         * @param {number} characterId An EVE character ID
         * @param {Array<number>} characters The target characters to calculate the charge for
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdCspa(characterId: number, characters: Array<number>, datasource?: 'tranquility', token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling postCharactersCharacterIdCspa.');
            }
            // verify required parameter 'characters' is not null or undefined
            if (characters === null || characters === undefined) {
                throw new RequiredError('characters','Required parameter characters was null or undefined when calling postCharactersCharacterIdCspa.');
            }
            const localVarPath = `/characters/{character_id}/cspa/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-characters.read_contacts.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;number&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(characters || {}) : (characters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CharacterApi - functional programming interface
 * @export
 */
export const CharacterApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Public information about a character  --- Alternate route: `/dev/characters/{character_id}/`  Alternate route: `/legacy/characters/{character_id}/`  Alternate route: `/v5/characters/{character_id}/`  --- This route is cached for up to 86400 seconds
         * @summary Get character's public information
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterId(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCharactersCharacterIdOk> {
            const localVarFetchArgs = CharacterApiFetchParamCreator(configuration).getCharactersCharacterId(characterId, datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a list of agents research information for a character. The formula for finding the current research points with an agent is: currentPoints = remainderPoints + pointsPerDay * days(currentTime - researchStartDate)  --- Alternate route: `/dev/characters/{character_id}/agents_research/`  Alternate route: `/v2/characters/{character_id}/agents_research/`  --- This route is cached for up to 3600 seconds
         * @summary Get agents research
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdAgentsResearch(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCharactersCharacterIdAgentsResearch200Ok>> {
            const localVarFetchArgs = CharacterApiFetchParamCreator(configuration).getCharactersCharacterIdAgentsResearch(characterId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a list of blueprints the character owns  --- Alternate route: `/dev/characters/{character_id}/blueprints/`  Alternate route: `/v3/characters/{character_id}/blueprints/`  --- This route is cached for up to 3600 seconds
         * @summary Get blueprints
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdBlueprints(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCharactersCharacterIdBlueprints200Ok>> {
            const localVarFetchArgs = CharacterApiFetchParamCreator(configuration).getCharactersCharacterIdBlueprints(characterId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of all the corporations a character has been a member of  --- Alternate route: `/dev/characters/{character_id}/corporationhistory/`  Alternate route: `/v2/characters/{character_id}/corporationhistory/`  --- This route is cached for up to 86400 seconds
         * @summary Get corporation history
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdCorporationhistory(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCharactersCharacterIdCorporationhistory200Ok>> {
            const localVarFetchArgs = CharacterApiFetchParamCreator(configuration).getCharactersCharacterIdCorporationhistory(characterId, datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a character's jump activation and fatigue information  --- Alternate route: `/dev/characters/{character_id}/fatigue/`  Alternate route: `/v2/characters/{character_id}/fatigue/`  --- This route is cached for up to 300 seconds
         * @summary Get jump fatigue
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdFatigue(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCharactersCharacterIdFatigueOk> {
            const localVarFetchArgs = CharacterApiFetchParamCreator(configuration).getCharactersCharacterIdFatigue(characterId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a list of medals the character has  --- Alternate route: `/dev/characters/{character_id}/medals/`  Alternate route: `/v2/characters/{character_id}/medals/`  --- This route is cached for up to 3600 seconds
         * @summary Get medals
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdMedals(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCharactersCharacterIdMedals200Ok>> {
            const localVarFetchArgs = CharacterApiFetchParamCreator(configuration).getCharactersCharacterIdMedals(characterId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return character notifications  --- Alternate route: `/dev/characters/{character_id}/notifications/`  Alternate route: `/v5/characters/{character_id}/notifications/`  Alternate route: `/v6/characters/{character_id}/notifications/`  --- This route is cached for up to 600 seconds
         * @summary Get character notifications
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdNotifications(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCharactersCharacterIdNotifications200Ok>> {
            const localVarFetchArgs = CharacterApiFetchParamCreator(configuration).getCharactersCharacterIdNotifications(characterId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return notifications about having been added to someone's contact list  --- Alternate route: `/dev/characters/{character_id}/notifications/contacts/`  Alternate route: `/v2/characters/{character_id}/notifications/contacts/`  --- This route is cached for up to 600 seconds
         * @summary Get new contact notifications
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdNotificationsContacts(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCharactersCharacterIdNotificationsContacts200Ok>> {
            const localVarFetchArgs = CharacterApiFetchParamCreator(configuration).getCharactersCharacterIdNotificationsContacts(characterId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get portrait urls for a character  --- Alternate route: `/dev/characters/{character_id}/portrait/`  Alternate route: `/v2/characters/{character_id}/portrait/`  Alternate route: `/v3/characters/{character_id}/portrait/`  --- This route expires daily at 11:05
         * @summary Get character portraits
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdPortrait(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCharactersCharacterIdPortraitOk> {
            const localVarFetchArgs = CharacterApiFetchParamCreator(configuration).getCharactersCharacterIdPortrait(characterId, datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a character's corporation roles  --- Alternate route: `/dev/characters/{character_id}/roles/`  Alternate route: `/v3/characters/{character_id}/roles/`  --- This route is cached for up to 3600 seconds
         * @summary Get character corporation roles
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdRoles(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCharactersCharacterIdRolesOk> {
            const localVarFetchArgs = CharacterApiFetchParamCreator(configuration).getCharactersCharacterIdRoles(characterId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return character standings from agents, NPC corporations, and factions  --- Alternate route: `/dev/characters/{character_id}/standings/`  Alternate route: `/v2/characters/{character_id}/standings/`  --- This route is cached for up to 3600 seconds
         * @summary Get standings
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdStandings(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCharactersCharacterIdStandings200Ok>> {
            const localVarFetchArgs = CharacterApiFetchParamCreator(configuration).getCharactersCharacterIdStandings(characterId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a character's titles  --- Alternate route: `/dev/characters/{character_id}/titles/`  Alternate route: `/v2/characters/{character_id}/titles/`  --- This route is cached for up to 3600 seconds
         * @summary Get character corporation titles
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdTitles(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCharactersCharacterIdTitles200Ok>> {
            const localVarFetchArgs = CharacterApiFetchParamCreator(configuration).getCharactersCharacterIdTitles(characterId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Bulk lookup of character IDs to corporation, alliance and faction  --- Alternate route: `/dev/characters/affiliation/`  Alternate route: `/v2/characters/affiliation/`  --- This route is cached for up to 3600 seconds
         * @summary Character affiliation
         * @param {Array<number>} characters The character IDs to fetch affiliations for. All characters must exist, or none will be returned
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersAffiliation(characters: Array<number>, datasource?: 'tranquility', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PostCharactersAffiliation200Ok>> {
            const localVarFetchArgs = CharacterApiFetchParamCreator(configuration).postCharactersAffiliation(characters, datasource, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Takes a source character ID in the url and a set of target character ID's in the body, returns a CSPA charge cost  --- Alternate route: `/dev/characters/{character_id}/cspa/`  Alternate route: `/v5/characters/{character_id}/cspa/` 
         * @summary Calculate a CSPA charge cost
         * @param {number} characterId An EVE character ID
         * @param {Array<number>} characters The target characters to calculate the charge for
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdCspa(characterId: number, characters: Array<number>, datasource?: 'tranquility', token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = CharacterApiFetchParamCreator(configuration).postCharactersCharacterIdCspa(characterId, characters, datasource, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CharacterApi - factory interface
 * @export
 */
export const CharacterApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Public information about a character  --- Alternate route: `/dev/characters/{character_id}/`  Alternate route: `/legacy/characters/{character_id}/`  Alternate route: `/v5/characters/{character_id}/`  --- This route is cached for up to 86400 seconds
         * @summary Get character's public information
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterId(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return CharacterApiFp(configuration).getCharactersCharacterId(characterId, datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Return a list of agents research information for a character. The formula for finding the current research points with an agent is: currentPoints = remainderPoints + pointsPerDay * days(currentTime - researchStartDate)  --- Alternate route: `/dev/characters/{character_id}/agents_research/`  Alternate route: `/v2/characters/{character_id}/agents_research/`  --- This route is cached for up to 3600 seconds
         * @summary Get agents research
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdAgentsResearch(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return CharacterApiFp(configuration).getCharactersCharacterIdAgentsResearch(characterId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Return a list of blueprints the character owns  --- Alternate route: `/dev/characters/{character_id}/blueprints/`  Alternate route: `/v3/characters/{character_id}/blueprints/`  --- This route is cached for up to 3600 seconds
         * @summary Get blueprints
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdBlueprints(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return CharacterApiFp(configuration).getCharactersCharacterIdBlueprints(characterId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
        /**
         * Get a list of all the corporations a character has been a member of  --- Alternate route: `/dev/characters/{character_id}/corporationhistory/`  Alternate route: `/v2/characters/{character_id}/corporationhistory/`  --- This route is cached for up to 86400 seconds
         * @summary Get corporation history
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdCorporationhistory(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return CharacterApiFp(configuration).getCharactersCharacterIdCorporationhistory(characterId, datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Return a character's jump activation and fatigue information  --- Alternate route: `/dev/characters/{character_id}/fatigue/`  Alternate route: `/v2/characters/{character_id}/fatigue/`  --- This route is cached for up to 300 seconds
         * @summary Get jump fatigue
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdFatigue(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return CharacterApiFp(configuration).getCharactersCharacterIdFatigue(characterId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Return a list of medals the character has  --- Alternate route: `/dev/characters/{character_id}/medals/`  Alternate route: `/v2/characters/{character_id}/medals/`  --- This route is cached for up to 3600 seconds
         * @summary Get medals
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdMedals(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return CharacterApiFp(configuration).getCharactersCharacterIdMedals(characterId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Return character notifications  --- Alternate route: `/dev/characters/{character_id}/notifications/`  Alternate route: `/v5/characters/{character_id}/notifications/`  Alternate route: `/v6/characters/{character_id}/notifications/`  --- This route is cached for up to 600 seconds
         * @summary Get character notifications
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdNotifications(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return CharacterApiFp(configuration).getCharactersCharacterIdNotifications(characterId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Return notifications about having been added to someone's contact list  --- Alternate route: `/dev/characters/{character_id}/notifications/contacts/`  Alternate route: `/v2/characters/{character_id}/notifications/contacts/`  --- This route is cached for up to 600 seconds
         * @summary Get new contact notifications
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdNotificationsContacts(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return CharacterApiFp(configuration).getCharactersCharacterIdNotificationsContacts(characterId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Get portrait urls for a character  --- Alternate route: `/dev/characters/{character_id}/portrait/`  Alternate route: `/v2/characters/{character_id}/portrait/`  Alternate route: `/v3/characters/{character_id}/portrait/`  --- This route expires daily at 11:05
         * @summary Get character portraits
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdPortrait(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return CharacterApiFp(configuration).getCharactersCharacterIdPortrait(characterId, datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Returns a character's corporation roles  --- Alternate route: `/dev/characters/{character_id}/roles/`  Alternate route: `/v3/characters/{character_id}/roles/`  --- This route is cached for up to 3600 seconds
         * @summary Get character corporation roles
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdRoles(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return CharacterApiFp(configuration).getCharactersCharacterIdRoles(characterId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Return character standings from agents, NPC corporations, and factions  --- Alternate route: `/dev/characters/{character_id}/standings/`  Alternate route: `/v2/characters/{character_id}/standings/`  --- This route is cached for up to 3600 seconds
         * @summary Get standings
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdStandings(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return CharacterApiFp(configuration).getCharactersCharacterIdStandings(characterId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Returns a character's titles  --- Alternate route: `/dev/characters/{character_id}/titles/`  Alternate route: `/v2/characters/{character_id}/titles/`  --- This route is cached for up to 3600 seconds
         * @summary Get character corporation titles
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdTitles(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return CharacterApiFp(configuration).getCharactersCharacterIdTitles(characterId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Bulk lookup of character IDs to corporation, alliance and faction  --- Alternate route: `/dev/characters/affiliation/`  Alternate route: `/v2/characters/affiliation/`  --- This route is cached for up to 3600 seconds
         * @summary Character affiliation
         * @param {Array<number>} characters The character IDs to fetch affiliations for. All characters must exist, or none will be returned
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersAffiliation(characters: Array<number>, datasource?: 'tranquility', options?: any) {
            return CharacterApiFp(configuration).postCharactersAffiliation(characters, datasource, options)(fetch, basePath);
        },
        /**
         * Takes a source character ID in the url and a set of target character ID's in the body, returns a CSPA charge cost  --- Alternate route: `/dev/characters/{character_id}/cspa/`  Alternate route: `/v5/characters/{character_id}/cspa/` 
         * @summary Calculate a CSPA charge cost
         * @param {number} characterId An EVE character ID
         * @param {Array<number>} characters The target characters to calculate the charge for
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdCspa(characterId: number, characters: Array<number>, datasource?: 'tranquility', token?: string, options?: any) {
            return CharacterApiFp(configuration).postCharactersCharacterIdCspa(characterId, characters, datasource, token, options)(fetch, basePath);
        },
    };
};

/**
 * CharacterApi - object-oriented interface
 * @export
 * @class CharacterApi
 * @extends {BaseAPI}
 */
export class CharacterApi extends BaseAPI {
    /**
     * Public information about a character  --- Alternate route: `/dev/characters/{character_id}/`  Alternate route: `/legacy/characters/{character_id}/`  Alternate route: `/v5/characters/{character_id}/`  --- This route is cached for up to 86400 seconds
     * @summary Get character's public information
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public getCharactersCharacterId(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return CharacterApiFp(this.configuration).getCharactersCharacterId(characterId, datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Return a list of agents research information for a character. The formula for finding the current research points with an agent is: currentPoints = remainderPoints + pointsPerDay * days(currentTime - researchStartDate)  --- Alternate route: `/dev/characters/{character_id}/agents_research/`  Alternate route: `/v2/characters/{character_id}/agents_research/`  --- This route is cached for up to 3600 seconds
     * @summary Get agents research
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public getCharactersCharacterIdAgentsResearch(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return CharacterApiFp(this.configuration).getCharactersCharacterIdAgentsResearch(characterId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return a list of blueprints the character owns  --- Alternate route: `/dev/characters/{character_id}/blueprints/`  Alternate route: `/v3/characters/{character_id}/blueprints/`  --- This route is cached for up to 3600 seconds
     * @summary Get blueprints
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public getCharactersCharacterIdBlueprints(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return CharacterApiFp(this.configuration).getCharactersCharacterIdBlueprints(characterId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of all the corporations a character has been a member of  --- Alternate route: `/dev/characters/{character_id}/corporationhistory/`  Alternate route: `/v2/characters/{character_id}/corporationhistory/`  --- This route is cached for up to 86400 seconds
     * @summary Get corporation history
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public getCharactersCharacterIdCorporationhistory(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return CharacterApiFp(this.configuration).getCharactersCharacterIdCorporationhistory(characterId, datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Return a character's jump activation and fatigue information  --- Alternate route: `/dev/characters/{character_id}/fatigue/`  Alternate route: `/v2/characters/{character_id}/fatigue/`  --- This route is cached for up to 300 seconds
     * @summary Get jump fatigue
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public getCharactersCharacterIdFatigue(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return CharacterApiFp(this.configuration).getCharactersCharacterIdFatigue(characterId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return a list of medals the character has  --- Alternate route: `/dev/characters/{character_id}/medals/`  Alternate route: `/v2/characters/{character_id}/medals/`  --- This route is cached for up to 3600 seconds
     * @summary Get medals
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public getCharactersCharacterIdMedals(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return CharacterApiFp(this.configuration).getCharactersCharacterIdMedals(characterId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return character notifications  --- Alternate route: `/dev/characters/{character_id}/notifications/`  Alternate route: `/v5/characters/{character_id}/notifications/`  Alternate route: `/v6/characters/{character_id}/notifications/`  --- This route is cached for up to 600 seconds
     * @summary Get character notifications
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public getCharactersCharacterIdNotifications(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return CharacterApiFp(this.configuration).getCharactersCharacterIdNotifications(characterId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return notifications about having been added to someone's contact list  --- Alternate route: `/dev/characters/{character_id}/notifications/contacts/`  Alternate route: `/v2/characters/{character_id}/notifications/contacts/`  --- This route is cached for up to 600 seconds
     * @summary Get new contact notifications
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public getCharactersCharacterIdNotificationsContacts(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return CharacterApiFp(this.configuration).getCharactersCharacterIdNotificationsContacts(characterId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Get portrait urls for a character  --- Alternate route: `/dev/characters/{character_id}/portrait/`  Alternate route: `/v2/characters/{character_id}/portrait/`  Alternate route: `/v3/characters/{character_id}/portrait/`  --- This route expires daily at 11:05
     * @summary Get character portraits
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public getCharactersCharacterIdPortrait(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return CharacterApiFp(this.configuration).getCharactersCharacterIdPortrait(characterId, datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a character's corporation roles  --- Alternate route: `/dev/characters/{character_id}/roles/`  Alternate route: `/v3/characters/{character_id}/roles/`  --- This route is cached for up to 3600 seconds
     * @summary Get character corporation roles
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public getCharactersCharacterIdRoles(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return CharacterApiFp(this.configuration).getCharactersCharacterIdRoles(characterId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return character standings from agents, NPC corporations, and factions  --- Alternate route: `/dev/characters/{character_id}/standings/`  Alternate route: `/v2/characters/{character_id}/standings/`  --- This route is cached for up to 3600 seconds
     * @summary Get standings
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public getCharactersCharacterIdStandings(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return CharacterApiFp(this.configuration).getCharactersCharacterIdStandings(characterId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a character's titles  --- Alternate route: `/dev/characters/{character_id}/titles/`  Alternate route: `/v2/characters/{character_id}/titles/`  --- This route is cached for up to 3600 seconds
     * @summary Get character corporation titles
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public getCharactersCharacterIdTitles(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return CharacterApiFp(this.configuration).getCharactersCharacterIdTitles(characterId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Bulk lookup of character IDs to corporation, alliance and faction  --- Alternate route: `/dev/characters/affiliation/`  Alternate route: `/v2/characters/affiliation/`  --- This route is cached for up to 3600 seconds
     * @summary Character affiliation
     * @param {Array<number>} characters The character IDs to fetch affiliations for. All characters must exist, or none will be returned
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public postCharactersAffiliation(characters: Array<number>, datasource?: 'tranquility', options?: any) {
        return CharacterApiFp(this.configuration).postCharactersAffiliation(characters, datasource, options)(this.fetch, this.basePath);
    }

    /**
     * Takes a source character ID in the url and a set of target character ID's in the body, returns a CSPA charge cost  --- Alternate route: `/dev/characters/{character_id}/cspa/`  Alternate route: `/v5/characters/{character_id}/cspa/` 
     * @summary Calculate a CSPA charge cost
     * @param {number} characterId An EVE character ID
     * @param {Array<number>} characters The target characters to calculate the charge for
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharacterApi
     */
    public postCharactersCharacterIdCspa(characterId: number, characters: Array<number>, datasource?: 'tranquility', token?: string, options?: any) {
        return CharacterApiFp(this.configuration).postCharactersCharacterIdCspa(characterId, characters, datasource, token, options)(this.fetch, this.basePath);
    }

}

/**
 * ClonesApi - fetch parameter creator
 * @export
 */
export const ClonesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A list of the character's clones  --- Alternate route: `/dev/characters/{character_id}/clones/`  Alternate route: `/v3/characters/{character_id}/clones/`  Alternate route: `/v4/characters/{character_id}/clones/`  --- This route is cached for up to 120 seconds
         * @summary Get clones
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdClones(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdClones.');
            }
            const localVarPath = `/characters/{character_id}/clones/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-clones.read_clones.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return implants on the active clone of a character  --- Alternate route: `/dev/characters/{character_id}/implants/`  Alternate route: `/legacy/characters/{character_id}/implants/`  Alternate route: `/v1/characters/{character_id}/implants/`  Alternate route: `/v2/characters/{character_id}/implants/`  --- This route is cached for up to 120 seconds
         * @summary Get active implants
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdImplants(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdImplants.');
            }
            const localVarPath = `/characters/{character_id}/implants/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-clones.read_implants.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClonesApi - functional programming interface
 * @export
 */
export const ClonesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * A list of the character's clones  --- Alternate route: `/dev/characters/{character_id}/clones/`  Alternate route: `/v3/characters/{character_id}/clones/`  Alternate route: `/v4/characters/{character_id}/clones/`  --- This route is cached for up to 120 seconds
         * @summary Get clones
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdClones(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCharactersCharacterIdClonesOk> {
            const localVarFetchArgs = ClonesApiFetchParamCreator(configuration).getCharactersCharacterIdClones(characterId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return implants on the active clone of a character  --- Alternate route: `/dev/characters/{character_id}/implants/`  Alternate route: `/legacy/characters/{character_id}/implants/`  Alternate route: `/v1/characters/{character_id}/implants/`  Alternate route: `/v2/characters/{character_id}/implants/`  --- This route is cached for up to 120 seconds
         * @summary Get active implants
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdImplants(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = ClonesApiFetchParamCreator(configuration).getCharactersCharacterIdImplants(characterId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ClonesApi - factory interface
 * @export
 */
export const ClonesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * A list of the character's clones  --- Alternate route: `/dev/characters/{character_id}/clones/`  Alternate route: `/v3/characters/{character_id}/clones/`  Alternate route: `/v4/characters/{character_id}/clones/`  --- This route is cached for up to 120 seconds
         * @summary Get clones
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdClones(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return ClonesApiFp(configuration).getCharactersCharacterIdClones(characterId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Return implants on the active clone of a character  --- Alternate route: `/dev/characters/{character_id}/implants/`  Alternate route: `/legacy/characters/{character_id}/implants/`  Alternate route: `/v1/characters/{character_id}/implants/`  Alternate route: `/v2/characters/{character_id}/implants/`  --- This route is cached for up to 120 seconds
         * @summary Get active implants
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdImplants(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return ClonesApiFp(configuration).getCharactersCharacterIdImplants(characterId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
    };
};

/**
 * ClonesApi - object-oriented interface
 * @export
 * @class ClonesApi
 * @extends {BaseAPI}
 */
export class ClonesApi extends BaseAPI {
    /**
     * A list of the character's clones  --- Alternate route: `/dev/characters/{character_id}/clones/`  Alternate route: `/v3/characters/{character_id}/clones/`  Alternate route: `/v4/characters/{character_id}/clones/`  --- This route is cached for up to 120 seconds
     * @summary Get clones
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClonesApi
     */
    public getCharactersCharacterIdClones(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return ClonesApiFp(this.configuration).getCharactersCharacterIdClones(characterId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return implants on the active clone of a character  --- Alternate route: `/dev/characters/{character_id}/implants/`  Alternate route: `/legacy/characters/{character_id}/implants/`  Alternate route: `/v1/characters/{character_id}/implants/`  Alternate route: `/v2/characters/{character_id}/implants/`  --- This route is cached for up to 120 seconds
     * @summary Get active implants
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClonesApi
     */
    public getCharactersCharacterIdImplants(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return ClonesApiFp(this.configuration).getCharactersCharacterIdImplants(characterId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

}

/**
 * ContactsApi - fetch parameter creator
 * @export
 */
export const ContactsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Bulk delete contacts  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/` 
         * @summary Delete contacts
         * @param {number} characterId An EVE character ID
         * @param {Array<number>} contactIds A list of contacts to delete
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharactersCharacterIdContacts(characterId: number, contactIds: Array<number>, datasource?: 'tranquility', token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling deleteCharactersCharacterIdContacts.');
            }
            // verify required parameter 'contactIds' is not null or undefined
            if (contactIds === null || contactIds === undefined) {
                throw new RequiredError('contactIds','Required parameter contactIds was null or undefined when calling deleteCharactersCharacterIdContacts.');
            }
            const localVarPath = `/characters/{character_id}/contacts/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-characters.write_contacts.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (contactIds) {
                localVarQueryParameter['contact_ids'] = contactIds;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return contacts of an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/contacts/`  Alternate route: `/v2/alliances/{alliance_id}/contacts/`  --- This route is cached for up to 300 seconds
         * @summary Get alliance contacts
         * @param {number} allianceId An EVE alliance ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlliancesAllianceIdContacts(allianceId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'allianceId' is not null or undefined
            if (allianceId === null || allianceId === undefined) {
                throw new RequiredError('allianceId','Required parameter allianceId was null or undefined when calling getAlliancesAllianceIdContacts.');
            }
            const localVarPath = `/alliances/{alliance_id}/contacts/`
                .replace(`{${"alliance_id"}}`, encodeURIComponent(String(allianceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-alliances.read_contacts.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return custom labels for an alliance's contacts  --- Alternate route: `/dev/alliances/{alliance_id}/contacts/labels/`  Alternate route: `/legacy/alliances/{alliance_id}/contacts/labels/`  Alternate route: `/v1/alliances/{alliance_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
         * @summary Get alliance contact labels
         * @param {number} allianceId An EVE alliance ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlliancesAllianceIdContactsLabels(allianceId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'allianceId' is not null or undefined
            if (allianceId === null || allianceId === undefined) {
                throw new RequiredError('allianceId','Required parameter allianceId was null or undefined when calling getAlliancesAllianceIdContactsLabels.');
            }
            const localVarPath = `/alliances/{alliance_id}/contacts/labels/`
                .replace(`{${"alliance_id"}}`, encodeURIComponent(String(allianceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-alliances.read_contacts.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return contacts of a character  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/`  --- This route is cached for up to 300 seconds
         * @summary Get contacts
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdContacts(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdContacts.');
            }
            const localVarPath = `/characters/{character_id}/contacts/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-characters.read_contacts.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return custom labels for a character's contacts  --- Alternate route: `/dev/characters/{character_id}/contacts/labels/`  Alternate route: `/legacy/characters/{character_id}/contacts/labels/`  Alternate route: `/v1/characters/{character_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
         * @summary Get contact labels
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdContactsLabels(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdContactsLabels.');
            }
            const localVarPath = `/characters/{character_id}/contacts/labels/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-characters.read_contacts.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return contacts of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/contacts/`  Alternate route: `/v2/corporations/{corporation_id}/contacts/`  --- This route is cached for up to 300 seconds
         * @summary Get corporation contacts
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdContacts(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdContacts.');
            }
            const localVarPath = `/corporations/{corporation_id}/contacts/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-corporations.read_contacts.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return custom labels for a corporation's contacts  --- Alternate route: `/dev/corporations/{corporation_id}/contacts/labels/`  Alternate route: `/legacy/corporations/{corporation_id}/contacts/labels/`  Alternate route: `/v1/corporations/{corporation_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
         * @summary Get corporation contact labels
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdContactsLabels(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdContactsLabels.');
            }
            const localVarPath = `/corporations/{corporation_id}/contacts/labels/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-corporations.read_contacts.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bulk add contacts with same settings  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/` 
         * @summary Add contacts
         * @param {number} characterId An EVE character ID
         * @param {Array<number>} contactIds A list of contacts
         * @param {number} standing Standing for the contact
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {Array<number>} [labelIds] Add custom labels to the new contact
         * @param {string} [token] Access token to use if unable to set a header
         * @param {boolean} [watched] Whether the contact should be watched, note this is only effective on characters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdContacts(characterId: number, contactIds: Array<number>, standing: number, datasource?: 'tranquility', labelIds?: Array<number>, token?: string, watched?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling postCharactersCharacterIdContacts.');
            }
            // verify required parameter 'contactIds' is not null or undefined
            if (contactIds === null || contactIds === undefined) {
                throw new RequiredError('contactIds','Required parameter contactIds was null or undefined when calling postCharactersCharacterIdContacts.');
            }
            // verify required parameter 'standing' is not null or undefined
            if (standing === null || standing === undefined) {
                throw new RequiredError('standing','Required parameter standing was null or undefined when calling postCharactersCharacterIdContacts.');
            }
            const localVarPath = `/characters/{character_id}/contacts/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-characters.write_contacts.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (labelIds) {
                localVarQueryParameter['label_ids'] = labelIds;
            }

            if (standing !== undefined) {
                localVarQueryParameter['standing'] = standing;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (watched !== undefined) {
                localVarQueryParameter['watched'] = watched;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;number&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(contactIds || {}) : (contactIds || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bulk edit contacts with same settings  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/` 
         * @summary Edit contacts
         * @param {number} characterId An EVE character ID
         * @param {Array<number>} contactIds A list of contacts
         * @param {number} standing Standing for the contact
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {Array<number>} [labelIds] Add custom labels to the contact
         * @param {string} [token] Access token to use if unable to set a header
         * @param {boolean} [watched] Whether the contact should be watched, note this is only effective on characters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCharactersCharacterIdContacts(characterId: number, contactIds: Array<number>, standing: number, datasource?: 'tranquility', labelIds?: Array<number>, token?: string, watched?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling putCharactersCharacterIdContacts.');
            }
            // verify required parameter 'contactIds' is not null or undefined
            if (contactIds === null || contactIds === undefined) {
                throw new RequiredError('contactIds','Required parameter contactIds was null or undefined when calling putCharactersCharacterIdContacts.');
            }
            // verify required parameter 'standing' is not null or undefined
            if (standing === null || standing === undefined) {
                throw new RequiredError('standing','Required parameter standing was null or undefined when calling putCharactersCharacterIdContacts.');
            }
            const localVarPath = `/characters/{character_id}/contacts/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-characters.write_contacts.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (labelIds) {
                localVarQueryParameter['label_ids'] = labelIds;
            }

            if (standing !== undefined) {
                localVarQueryParameter['standing'] = standing;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (watched !== undefined) {
                localVarQueryParameter['watched'] = watched;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;number&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(contactIds || {}) : (contactIds || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactsApi - functional programming interface
 * @export
 */
export const ContactsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Bulk delete contacts  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/` 
         * @summary Delete contacts
         * @param {number} characterId An EVE character ID
         * @param {Array<number>} contactIds A list of contacts to delete
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharactersCharacterIdContacts(characterId: number, contactIds: Array<number>, datasource?: 'tranquility', token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ContactsApiFetchParamCreator(configuration).deleteCharactersCharacterIdContacts(characterId, contactIds, datasource, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return contacts of an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/contacts/`  Alternate route: `/v2/alliances/{alliance_id}/contacts/`  --- This route is cached for up to 300 seconds
         * @summary Get alliance contacts
         * @param {number} allianceId An EVE alliance ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlliancesAllianceIdContacts(allianceId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetAlliancesAllianceIdContacts200Ok>> {
            const localVarFetchArgs = ContactsApiFetchParamCreator(configuration).getAlliancesAllianceIdContacts(allianceId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return custom labels for an alliance's contacts  --- Alternate route: `/dev/alliances/{alliance_id}/contacts/labels/`  Alternate route: `/legacy/alliances/{alliance_id}/contacts/labels/`  Alternate route: `/v1/alliances/{alliance_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
         * @summary Get alliance contact labels
         * @param {number} allianceId An EVE alliance ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlliancesAllianceIdContactsLabels(allianceId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetAlliancesAllianceIdContactsLabels200Ok>> {
            const localVarFetchArgs = ContactsApiFetchParamCreator(configuration).getAlliancesAllianceIdContactsLabels(allianceId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return contacts of a character  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/`  --- This route is cached for up to 300 seconds
         * @summary Get contacts
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdContacts(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCharactersCharacterIdContacts200Ok>> {
            const localVarFetchArgs = ContactsApiFetchParamCreator(configuration).getCharactersCharacterIdContacts(characterId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return custom labels for a character's contacts  --- Alternate route: `/dev/characters/{character_id}/contacts/labels/`  Alternate route: `/legacy/characters/{character_id}/contacts/labels/`  Alternate route: `/v1/characters/{character_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
         * @summary Get contact labels
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdContactsLabels(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCharactersCharacterIdContactsLabels200Ok>> {
            const localVarFetchArgs = ContactsApiFetchParamCreator(configuration).getCharactersCharacterIdContactsLabels(characterId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return contacts of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/contacts/`  Alternate route: `/v2/corporations/{corporation_id}/contacts/`  --- This route is cached for up to 300 seconds
         * @summary Get corporation contacts
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdContacts(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationsCorporationIdContacts200Ok>> {
            const localVarFetchArgs = ContactsApiFetchParamCreator(configuration).getCorporationsCorporationIdContacts(corporationId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return custom labels for a corporation's contacts  --- Alternate route: `/dev/corporations/{corporation_id}/contacts/labels/`  Alternate route: `/legacy/corporations/{corporation_id}/contacts/labels/`  Alternate route: `/v1/corporations/{corporation_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
         * @summary Get corporation contact labels
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdContactsLabels(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationsCorporationIdContactsLabels200Ok>> {
            const localVarFetchArgs = ContactsApiFetchParamCreator(configuration).getCorporationsCorporationIdContactsLabels(corporationId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Bulk add contacts with same settings  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/` 
         * @summary Add contacts
         * @param {number} characterId An EVE character ID
         * @param {Array<number>} contactIds A list of contacts
         * @param {number} standing Standing for the contact
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {Array<number>} [labelIds] Add custom labels to the new contact
         * @param {string} [token] Access token to use if unable to set a header
         * @param {boolean} [watched] Whether the contact should be watched, note this is only effective on characters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdContacts(characterId: number, contactIds: Array<number>, standing: number, datasource?: 'tranquility', labelIds?: Array<number>, token?: string, watched?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = ContactsApiFetchParamCreator(configuration).postCharactersCharacterIdContacts(characterId, contactIds, standing, datasource, labelIds, token, watched, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Bulk edit contacts with same settings  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/` 
         * @summary Edit contacts
         * @param {number} characterId An EVE character ID
         * @param {Array<number>} contactIds A list of contacts
         * @param {number} standing Standing for the contact
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {Array<number>} [labelIds] Add custom labels to the contact
         * @param {string} [token] Access token to use if unable to set a header
         * @param {boolean} [watched] Whether the contact should be watched, note this is only effective on characters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCharactersCharacterIdContacts(characterId: number, contactIds: Array<number>, standing: number, datasource?: 'tranquility', labelIds?: Array<number>, token?: string, watched?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ContactsApiFetchParamCreator(configuration).putCharactersCharacterIdContacts(characterId, contactIds, standing, datasource, labelIds, token, watched, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ContactsApi - factory interface
 * @export
 */
export const ContactsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Bulk delete contacts  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/` 
         * @summary Delete contacts
         * @param {number} characterId An EVE character ID
         * @param {Array<number>} contactIds A list of contacts to delete
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharactersCharacterIdContacts(characterId: number, contactIds: Array<number>, datasource?: 'tranquility', token?: string, options?: any) {
            return ContactsApiFp(configuration).deleteCharactersCharacterIdContacts(characterId, contactIds, datasource, token, options)(fetch, basePath);
        },
        /**
         * Return contacts of an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/contacts/`  Alternate route: `/v2/alliances/{alliance_id}/contacts/`  --- This route is cached for up to 300 seconds
         * @summary Get alliance contacts
         * @param {number} allianceId An EVE alliance ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlliancesAllianceIdContacts(allianceId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return ContactsApiFp(configuration).getAlliancesAllianceIdContacts(allianceId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
        /**
         * Return custom labels for an alliance's contacts  --- Alternate route: `/dev/alliances/{alliance_id}/contacts/labels/`  Alternate route: `/legacy/alliances/{alliance_id}/contacts/labels/`  Alternate route: `/v1/alliances/{alliance_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
         * @summary Get alliance contact labels
         * @param {number} allianceId An EVE alliance ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlliancesAllianceIdContactsLabels(allianceId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return ContactsApiFp(configuration).getAlliancesAllianceIdContactsLabels(allianceId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Return contacts of a character  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/`  --- This route is cached for up to 300 seconds
         * @summary Get contacts
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdContacts(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return ContactsApiFp(configuration).getCharactersCharacterIdContacts(characterId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
        /**
         * Return custom labels for a character's contacts  --- Alternate route: `/dev/characters/{character_id}/contacts/labels/`  Alternate route: `/legacy/characters/{character_id}/contacts/labels/`  Alternate route: `/v1/characters/{character_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
         * @summary Get contact labels
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdContactsLabels(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return ContactsApiFp(configuration).getCharactersCharacterIdContactsLabels(characterId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Return contacts of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/contacts/`  Alternate route: `/v2/corporations/{corporation_id}/contacts/`  --- This route is cached for up to 300 seconds
         * @summary Get corporation contacts
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdContacts(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return ContactsApiFp(configuration).getCorporationsCorporationIdContacts(corporationId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
        /**
         * Return custom labels for a corporation's contacts  --- Alternate route: `/dev/corporations/{corporation_id}/contacts/labels/`  Alternate route: `/legacy/corporations/{corporation_id}/contacts/labels/`  Alternate route: `/v1/corporations/{corporation_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
         * @summary Get corporation contact labels
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdContactsLabels(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return ContactsApiFp(configuration).getCorporationsCorporationIdContactsLabels(corporationId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Bulk add contacts with same settings  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/` 
         * @summary Add contacts
         * @param {number} characterId An EVE character ID
         * @param {Array<number>} contactIds A list of contacts
         * @param {number} standing Standing for the contact
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {Array<number>} [labelIds] Add custom labels to the new contact
         * @param {string} [token] Access token to use if unable to set a header
         * @param {boolean} [watched] Whether the contact should be watched, note this is only effective on characters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdContacts(characterId: number, contactIds: Array<number>, standing: number, datasource?: 'tranquility', labelIds?: Array<number>, token?: string, watched?: boolean, options?: any) {
            return ContactsApiFp(configuration).postCharactersCharacterIdContacts(characterId, contactIds, standing, datasource, labelIds, token, watched, options)(fetch, basePath);
        },
        /**
         * Bulk edit contacts with same settings  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/` 
         * @summary Edit contacts
         * @param {number} characterId An EVE character ID
         * @param {Array<number>} contactIds A list of contacts
         * @param {number} standing Standing for the contact
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {Array<number>} [labelIds] Add custom labels to the contact
         * @param {string} [token] Access token to use if unable to set a header
         * @param {boolean} [watched] Whether the contact should be watched, note this is only effective on characters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCharactersCharacterIdContacts(characterId: number, contactIds: Array<number>, standing: number, datasource?: 'tranquility', labelIds?: Array<number>, token?: string, watched?: boolean, options?: any) {
            return ContactsApiFp(configuration).putCharactersCharacterIdContacts(characterId, contactIds, standing, datasource, labelIds, token, watched, options)(fetch, basePath);
        },
    };
};

/**
 * ContactsApi - object-oriented interface
 * @export
 * @class ContactsApi
 * @extends {BaseAPI}
 */
export class ContactsApi extends BaseAPI {
    /**
     * Bulk delete contacts  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/` 
     * @summary Delete contacts
     * @param {number} characterId An EVE character ID
     * @param {Array<number>} contactIds A list of contacts to delete
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public deleteCharactersCharacterIdContacts(characterId: number, contactIds: Array<number>, datasource?: 'tranquility', token?: string, options?: any) {
        return ContactsApiFp(this.configuration).deleteCharactersCharacterIdContacts(characterId, contactIds, datasource, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return contacts of an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/contacts/`  Alternate route: `/v2/alliances/{alliance_id}/contacts/`  --- This route is cached for up to 300 seconds
     * @summary Get alliance contacts
     * @param {number} allianceId An EVE alliance ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public getAlliancesAllianceIdContacts(allianceId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return ContactsApiFp(this.configuration).getAlliancesAllianceIdContacts(allianceId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return custom labels for an alliance's contacts  --- Alternate route: `/dev/alliances/{alliance_id}/contacts/labels/`  Alternate route: `/legacy/alliances/{alliance_id}/contacts/labels/`  Alternate route: `/v1/alliances/{alliance_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
     * @summary Get alliance contact labels
     * @param {number} allianceId An EVE alliance ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public getAlliancesAllianceIdContactsLabels(allianceId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return ContactsApiFp(this.configuration).getAlliancesAllianceIdContactsLabels(allianceId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return contacts of a character  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/`  --- This route is cached for up to 300 seconds
     * @summary Get contacts
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public getCharactersCharacterIdContacts(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return ContactsApiFp(this.configuration).getCharactersCharacterIdContacts(characterId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return custom labels for a character's contacts  --- Alternate route: `/dev/characters/{character_id}/contacts/labels/`  Alternate route: `/legacy/characters/{character_id}/contacts/labels/`  Alternate route: `/v1/characters/{character_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
     * @summary Get contact labels
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public getCharactersCharacterIdContactsLabels(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return ContactsApiFp(this.configuration).getCharactersCharacterIdContactsLabels(characterId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return contacts of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/contacts/`  Alternate route: `/v2/corporations/{corporation_id}/contacts/`  --- This route is cached for up to 300 seconds
     * @summary Get corporation contacts
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public getCorporationsCorporationIdContacts(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return ContactsApiFp(this.configuration).getCorporationsCorporationIdContacts(corporationId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return custom labels for a corporation's contacts  --- Alternate route: `/dev/corporations/{corporation_id}/contacts/labels/`  Alternate route: `/legacy/corporations/{corporation_id}/contacts/labels/`  Alternate route: `/v1/corporations/{corporation_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
     * @summary Get corporation contact labels
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public getCorporationsCorporationIdContactsLabels(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return ContactsApiFp(this.configuration).getCorporationsCorporationIdContactsLabels(corporationId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Bulk add contacts with same settings  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/` 
     * @summary Add contacts
     * @param {number} characterId An EVE character ID
     * @param {Array<number>} contactIds A list of contacts
     * @param {number} standing Standing for the contact
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {Array<number>} [labelIds] Add custom labels to the new contact
     * @param {string} [token] Access token to use if unable to set a header
     * @param {boolean} [watched] Whether the contact should be watched, note this is only effective on characters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public postCharactersCharacterIdContacts(characterId: number, contactIds: Array<number>, standing: number, datasource?: 'tranquility', labelIds?: Array<number>, token?: string, watched?: boolean, options?: any) {
        return ContactsApiFp(this.configuration).postCharactersCharacterIdContacts(characterId, contactIds, standing, datasource, labelIds, token, watched, options)(this.fetch, this.basePath);
    }

    /**
     * Bulk edit contacts with same settings  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/` 
     * @summary Edit contacts
     * @param {number} characterId An EVE character ID
     * @param {Array<number>} contactIds A list of contacts
     * @param {number} standing Standing for the contact
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {Array<number>} [labelIds] Add custom labels to the contact
     * @param {string} [token] Access token to use if unable to set a header
     * @param {boolean} [watched] Whether the contact should be watched, note this is only effective on characters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public putCharactersCharacterIdContacts(characterId: number, contactIds: Array<number>, standing: number, datasource?: 'tranquility', labelIds?: Array<number>, token?: string, watched?: boolean, options?: any) {
        return ContactsApiFp(this.configuration).putCharactersCharacterIdContacts(characterId, contactIds, standing, datasource, labelIds, token, watched, options)(this.fetch, this.basePath);
    }

}

/**
 * ContractsApi - fetch parameter creator
 * @export
 */
export const ContractsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns contracts available to a character, only if the character is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is \"in_progress\".  --- Alternate route: `/dev/characters/{character_id}/contracts/`  Alternate route: `/legacy/characters/{character_id}/contracts/`  Alternate route: `/v1/characters/{character_id}/contracts/`  --- This route is cached for up to 300 seconds
         * @summary Get contracts
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdContracts(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdContracts.');
            }
            const localVarPath = `/characters/{character_id}/contracts/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-contracts.read_character_contracts.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists bids on a particular auction contract  --- Alternate route: `/dev/characters/{character_id}/contracts/{contract_id}/bids/`  Alternate route: `/legacy/characters/{character_id}/contracts/{contract_id}/bids/`  Alternate route: `/v1/characters/{character_id}/contracts/{contract_id}/bids/`  --- This route is cached for up to 300 seconds
         * @summary Get contract bids
         * @param {number} characterId An EVE character ID
         * @param {number} contractId ID of a contract
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdContractsContractIdBids(characterId: number, contractId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdContractsContractIdBids.');
            }
            // verify required parameter 'contractId' is not null or undefined
            if (contractId === null || contractId === undefined) {
                throw new RequiredError('contractId','Required parameter contractId was null or undefined when calling getCharactersCharacterIdContractsContractIdBids.');
            }
            const localVarPath = `/characters/{character_id}/contracts/{contract_id}/bids/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)))
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-contracts.read_character_contracts.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists items of a particular contract  --- Alternate route: `/dev/characters/{character_id}/contracts/{contract_id}/items/`  Alternate route: `/legacy/characters/{character_id}/contracts/{contract_id}/items/`  Alternate route: `/v1/characters/{character_id}/contracts/{contract_id}/items/`  --- This route is cached for up to 3600 seconds
         * @summary Get contract items
         * @param {number} characterId An EVE character ID
         * @param {number} contractId ID of a contract
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdContractsContractIdItems(characterId: number, contractId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdContractsContractIdItems.');
            }
            // verify required parameter 'contractId' is not null or undefined
            if (contractId === null || contractId === undefined) {
                throw new RequiredError('contractId','Required parameter contractId was null or undefined when calling getCharactersCharacterIdContractsContractIdItems.');
            }
            const localVarPath = `/characters/{character_id}/contracts/{contract_id}/items/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)))
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-contracts.read_character_contracts.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists bids on a public auction contract  --- Alternate route: `/dev/contracts/public/bids/{contract_id}/`  Alternate route: `/legacy/contracts/public/bids/{contract_id}/`  Alternate route: `/v1/contracts/public/bids/{contract_id}/`  --- This route is cached for up to 300 seconds
         * @summary Get public contract bids
         * @param {number} contractId ID of a contract
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractsPublicBidsContractId(contractId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options: any = {}): FetchArgs {
            // verify required parameter 'contractId' is not null or undefined
            if (contractId === null || contractId === undefined) {
                throw new RequiredError('contractId','Required parameter contractId was null or undefined when calling getContractsPublicBidsContractId.');
            }
            const localVarPath = `/contracts/public/bids/{contract_id}/`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists items of a public contract  --- Alternate route: `/dev/contracts/public/items/{contract_id}/`  Alternate route: `/legacy/contracts/public/items/{contract_id}/`  Alternate route: `/v1/contracts/public/items/{contract_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get public contract items
         * @param {number} contractId ID of a contract
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractsPublicItemsContractId(contractId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options: any = {}): FetchArgs {
            // verify required parameter 'contractId' is not null or undefined
            if (contractId === null || contractId === undefined) {
                throw new RequiredError('contractId','Required parameter contractId was null or undefined when calling getContractsPublicItemsContractId.');
            }
            const localVarPath = `/contracts/public/items/{contract_id}/`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of all public contracts in the given region  --- Alternate route: `/dev/contracts/public/{region_id}/`  Alternate route: `/legacy/contracts/public/{region_id}/`  Alternate route: `/v1/contracts/public/{region_id}/`  --- This route is cached for up to 1800 seconds
         * @summary Get public contracts
         * @param {number} regionId An EVE region id
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractsPublicRegionId(regionId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options: any = {}): FetchArgs {
            // verify required parameter 'regionId' is not null or undefined
            if (regionId === null || regionId === undefined) {
                throw new RequiredError('regionId','Required parameter regionId was null or undefined when calling getContractsPublicRegionId.');
            }
            const localVarPath = `/contracts/public/{region_id}/`
                .replace(`{${"region_id"}}`, encodeURIComponent(String(regionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns contracts available to a corporation, only if the corporation is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is \"in_progress\".  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/`  --- This route is cached for up to 300 seconds
         * @summary Get corporation contracts
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdContracts(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdContracts.');
            }
            const localVarPath = `/corporations/{corporation_id}/contracts/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-contracts.read_corporation_contracts.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists bids on a particular auction contract  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/{contract_id}/bids/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/{contract_id}/bids/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/{contract_id}/bids/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation contract bids
         * @param {number} contractId ID of a contract
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdContractsContractIdBids(contractId: number, corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'contractId' is not null or undefined
            if (contractId === null || contractId === undefined) {
                throw new RequiredError('contractId','Required parameter contractId was null or undefined when calling getCorporationsCorporationIdContractsContractIdBids.');
            }
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdContractsContractIdBids.');
            }
            const localVarPath = `/corporations/{corporation_id}/contracts/{contract_id}/bids/`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-contracts.read_corporation_contracts.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists items of a particular contract  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/{contract_id}/items/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/{contract_id}/items/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/{contract_id}/items/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation contract items
         * @param {number} contractId ID of a contract
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdContractsContractIdItems(contractId: number, corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'contractId' is not null or undefined
            if (contractId === null || contractId === undefined) {
                throw new RequiredError('contractId','Required parameter contractId was null or undefined when calling getCorporationsCorporationIdContractsContractIdItems.');
            }
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdContractsContractIdItems.');
            }
            const localVarPath = `/corporations/{corporation_id}/contracts/{contract_id}/items/`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-contracts.read_corporation_contracts.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContractsApi - functional programming interface
 * @export
 */
export const ContractsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns contracts available to a character, only if the character is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is \"in_progress\".  --- Alternate route: `/dev/characters/{character_id}/contracts/`  Alternate route: `/legacy/characters/{character_id}/contracts/`  Alternate route: `/v1/characters/{character_id}/contracts/`  --- This route is cached for up to 300 seconds
         * @summary Get contracts
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdContracts(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCharactersCharacterIdContracts200Ok>> {
            const localVarFetchArgs = ContractsApiFetchParamCreator(configuration).getCharactersCharacterIdContracts(characterId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists bids on a particular auction contract  --- Alternate route: `/dev/characters/{character_id}/contracts/{contract_id}/bids/`  Alternate route: `/legacy/characters/{character_id}/contracts/{contract_id}/bids/`  Alternate route: `/v1/characters/{character_id}/contracts/{contract_id}/bids/`  --- This route is cached for up to 300 seconds
         * @summary Get contract bids
         * @param {number} characterId An EVE character ID
         * @param {number} contractId ID of a contract
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdContractsContractIdBids(characterId: number, contractId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCharactersCharacterIdContractsContractIdBids200Ok>> {
            const localVarFetchArgs = ContractsApiFetchParamCreator(configuration).getCharactersCharacterIdContractsContractIdBids(characterId, contractId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists items of a particular contract  --- Alternate route: `/dev/characters/{character_id}/contracts/{contract_id}/items/`  Alternate route: `/legacy/characters/{character_id}/contracts/{contract_id}/items/`  Alternate route: `/v1/characters/{character_id}/contracts/{contract_id}/items/`  --- This route is cached for up to 3600 seconds
         * @summary Get contract items
         * @param {number} characterId An EVE character ID
         * @param {number} contractId ID of a contract
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdContractsContractIdItems(characterId: number, contractId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCharactersCharacterIdContractsContractIdItems200Ok>> {
            const localVarFetchArgs = ContractsApiFetchParamCreator(configuration).getCharactersCharacterIdContractsContractIdItems(characterId, contractId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists bids on a public auction contract  --- Alternate route: `/dev/contracts/public/bids/{contract_id}/`  Alternate route: `/legacy/contracts/public/bids/{contract_id}/`  Alternate route: `/v1/contracts/public/bids/{contract_id}/`  --- This route is cached for up to 300 seconds
         * @summary Get public contract bids
         * @param {number} contractId ID of a contract
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractsPublicBidsContractId(contractId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetContractsPublicBidsContractId200Ok>> {
            const localVarFetchArgs = ContractsApiFetchParamCreator(configuration).getContractsPublicBidsContractId(contractId, datasource, ifNoneMatch, page, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists items of a public contract  --- Alternate route: `/dev/contracts/public/items/{contract_id}/`  Alternate route: `/legacy/contracts/public/items/{contract_id}/`  Alternate route: `/v1/contracts/public/items/{contract_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get public contract items
         * @param {number} contractId ID of a contract
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractsPublicItemsContractId(contractId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetContractsPublicItemsContractId200Ok>> {
            const localVarFetchArgs = ContractsApiFetchParamCreator(configuration).getContractsPublicItemsContractId(contractId, datasource, ifNoneMatch, page, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a paginated list of all public contracts in the given region  --- Alternate route: `/dev/contracts/public/{region_id}/`  Alternate route: `/legacy/contracts/public/{region_id}/`  Alternate route: `/v1/contracts/public/{region_id}/`  --- This route is cached for up to 1800 seconds
         * @summary Get public contracts
         * @param {number} regionId An EVE region id
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractsPublicRegionId(regionId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetContractsPublicRegionId200Ok>> {
            const localVarFetchArgs = ContractsApiFetchParamCreator(configuration).getContractsPublicRegionId(regionId, datasource, ifNoneMatch, page, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns contracts available to a corporation, only if the corporation is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is \"in_progress\".  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/`  --- This route is cached for up to 300 seconds
         * @summary Get corporation contracts
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdContracts(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationsCorporationIdContracts200Ok>> {
            const localVarFetchArgs = ContractsApiFetchParamCreator(configuration).getCorporationsCorporationIdContracts(corporationId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists bids on a particular auction contract  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/{contract_id}/bids/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/{contract_id}/bids/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/{contract_id}/bids/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation contract bids
         * @param {number} contractId ID of a contract
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdContractsContractIdBids(contractId: number, corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationsCorporationIdContractsContractIdBids200Ok>> {
            const localVarFetchArgs = ContractsApiFetchParamCreator(configuration).getCorporationsCorporationIdContractsContractIdBids(contractId, corporationId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists items of a particular contract  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/{contract_id}/items/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/{contract_id}/items/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/{contract_id}/items/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation contract items
         * @param {number} contractId ID of a contract
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdContractsContractIdItems(contractId: number, corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationsCorporationIdContractsContractIdItems200Ok>> {
            const localVarFetchArgs = ContractsApiFetchParamCreator(configuration).getCorporationsCorporationIdContractsContractIdItems(contractId, corporationId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ContractsApi - factory interface
 * @export
 */
export const ContractsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns contracts available to a character, only if the character is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is \"in_progress\".  --- Alternate route: `/dev/characters/{character_id}/contracts/`  Alternate route: `/legacy/characters/{character_id}/contracts/`  Alternate route: `/v1/characters/{character_id}/contracts/`  --- This route is cached for up to 300 seconds
         * @summary Get contracts
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdContracts(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return ContractsApiFp(configuration).getCharactersCharacterIdContracts(characterId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
        /**
         * Lists bids on a particular auction contract  --- Alternate route: `/dev/characters/{character_id}/contracts/{contract_id}/bids/`  Alternate route: `/legacy/characters/{character_id}/contracts/{contract_id}/bids/`  Alternate route: `/v1/characters/{character_id}/contracts/{contract_id}/bids/`  --- This route is cached for up to 300 seconds
         * @summary Get contract bids
         * @param {number} characterId An EVE character ID
         * @param {number} contractId ID of a contract
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdContractsContractIdBids(characterId: number, contractId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return ContractsApiFp(configuration).getCharactersCharacterIdContractsContractIdBids(characterId, contractId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Lists items of a particular contract  --- Alternate route: `/dev/characters/{character_id}/contracts/{contract_id}/items/`  Alternate route: `/legacy/characters/{character_id}/contracts/{contract_id}/items/`  Alternate route: `/v1/characters/{character_id}/contracts/{contract_id}/items/`  --- This route is cached for up to 3600 seconds
         * @summary Get contract items
         * @param {number} characterId An EVE character ID
         * @param {number} contractId ID of a contract
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdContractsContractIdItems(characterId: number, contractId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return ContractsApiFp(configuration).getCharactersCharacterIdContractsContractIdItems(characterId, contractId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Lists bids on a public auction contract  --- Alternate route: `/dev/contracts/public/bids/{contract_id}/`  Alternate route: `/legacy/contracts/public/bids/{contract_id}/`  Alternate route: `/v1/contracts/public/bids/{contract_id}/`  --- This route is cached for up to 300 seconds
         * @summary Get public contract bids
         * @param {number} contractId ID of a contract
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractsPublicBidsContractId(contractId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options?: any) {
            return ContractsApiFp(configuration).getContractsPublicBidsContractId(contractId, datasource, ifNoneMatch, page, options)(fetch, basePath);
        },
        /**
         * Lists items of a public contract  --- Alternate route: `/dev/contracts/public/items/{contract_id}/`  Alternate route: `/legacy/contracts/public/items/{contract_id}/`  Alternate route: `/v1/contracts/public/items/{contract_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get public contract items
         * @param {number} contractId ID of a contract
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractsPublicItemsContractId(contractId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options?: any) {
            return ContractsApiFp(configuration).getContractsPublicItemsContractId(contractId, datasource, ifNoneMatch, page, options)(fetch, basePath);
        },
        /**
         * Returns a paginated list of all public contracts in the given region  --- Alternate route: `/dev/contracts/public/{region_id}/`  Alternate route: `/legacy/contracts/public/{region_id}/`  Alternate route: `/v1/contracts/public/{region_id}/`  --- This route is cached for up to 1800 seconds
         * @summary Get public contracts
         * @param {number} regionId An EVE region id
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractsPublicRegionId(regionId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options?: any) {
            return ContractsApiFp(configuration).getContractsPublicRegionId(regionId, datasource, ifNoneMatch, page, options)(fetch, basePath);
        },
        /**
         * Returns contracts available to a corporation, only if the corporation is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is \"in_progress\".  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/`  --- This route is cached for up to 300 seconds
         * @summary Get corporation contracts
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdContracts(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return ContractsApiFp(configuration).getCorporationsCorporationIdContracts(corporationId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
        /**
         * Lists bids on a particular auction contract  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/{contract_id}/bids/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/{contract_id}/bids/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/{contract_id}/bids/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation contract bids
         * @param {number} contractId ID of a contract
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdContractsContractIdBids(contractId: number, corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return ContractsApiFp(configuration).getCorporationsCorporationIdContractsContractIdBids(contractId, corporationId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
        /**
         * Lists items of a particular contract  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/{contract_id}/items/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/{contract_id}/items/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/{contract_id}/items/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation contract items
         * @param {number} contractId ID of a contract
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdContractsContractIdItems(contractId: number, corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return ContractsApiFp(configuration).getCorporationsCorporationIdContractsContractIdItems(contractId, corporationId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
    };
};

/**
 * ContractsApi - object-oriented interface
 * @export
 * @class ContractsApi
 * @extends {BaseAPI}
 */
export class ContractsApi extends BaseAPI {
    /**
     * Returns contracts available to a character, only if the character is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is \"in_progress\".  --- Alternate route: `/dev/characters/{character_id}/contracts/`  Alternate route: `/legacy/characters/{character_id}/contracts/`  Alternate route: `/v1/characters/{character_id}/contracts/`  --- This route is cached for up to 300 seconds
     * @summary Get contracts
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public getCharactersCharacterIdContracts(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return ContractsApiFp(this.configuration).getCharactersCharacterIdContracts(characterId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * Lists bids on a particular auction contract  --- Alternate route: `/dev/characters/{character_id}/contracts/{contract_id}/bids/`  Alternate route: `/legacy/characters/{character_id}/contracts/{contract_id}/bids/`  Alternate route: `/v1/characters/{character_id}/contracts/{contract_id}/bids/`  --- This route is cached for up to 300 seconds
     * @summary Get contract bids
     * @param {number} characterId An EVE character ID
     * @param {number} contractId ID of a contract
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public getCharactersCharacterIdContractsContractIdBids(characterId: number, contractId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return ContractsApiFp(this.configuration).getCharactersCharacterIdContractsContractIdBids(characterId, contractId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Lists items of a particular contract  --- Alternate route: `/dev/characters/{character_id}/contracts/{contract_id}/items/`  Alternate route: `/legacy/characters/{character_id}/contracts/{contract_id}/items/`  Alternate route: `/v1/characters/{character_id}/contracts/{contract_id}/items/`  --- This route is cached for up to 3600 seconds
     * @summary Get contract items
     * @param {number} characterId An EVE character ID
     * @param {number} contractId ID of a contract
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public getCharactersCharacterIdContractsContractIdItems(characterId: number, contractId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return ContractsApiFp(this.configuration).getCharactersCharacterIdContractsContractIdItems(characterId, contractId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Lists bids on a public auction contract  --- Alternate route: `/dev/contracts/public/bids/{contract_id}/`  Alternate route: `/legacy/contracts/public/bids/{contract_id}/`  Alternate route: `/v1/contracts/public/bids/{contract_id}/`  --- This route is cached for up to 300 seconds
     * @summary Get public contract bids
     * @param {number} contractId ID of a contract
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public getContractsPublicBidsContractId(contractId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options?: any) {
        return ContractsApiFp(this.configuration).getContractsPublicBidsContractId(contractId, datasource, ifNoneMatch, page, options)(this.fetch, this.basePath);
    }

    /**
     * Lists items of a public contract  --- Alternate route: `/dev/contracts/public/items/{contract_id}/`  Alternate route: `/legacy/contracts/public/items/{contract_id}/`  Alternate route: `/v1/contracts/public/items/{contract_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get public contract items
     * @param {number} contractId ID of a contract
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public getContractsPublicItemsContractId(contractId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options?: any) {
        return ContractsApiFp(this.configuration).getContractsPublicItemsContractId(contractId, datasource, ifNoneMatch, page, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a paginated list of all public contracts in the given region  --- Alternate route: `/dev/contracts/public/{region_id}/`  Alternate route: `/legacy/contracts/public/{region_id}/`  Alternate route: `/v1/contracts/public/{region_id}/`  --- This route is cached for up to 1800 seconds
     * @summary Get public contracts
     * @param {number} regionId An EVE region id
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public getContractsPublicRegionId(regionId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options?: any) {
        return ContractsApiFp(this.configuration).getContractsPublicRegionId(regionId, datasource, ifNoneMatch, page, options)(this.fetch, this.basePath);
    }

    /**
     * Returns contracts available to a corporation, only if the corporation is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is \"in_progress\".  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/`  --- This route is cached for up to 300 seconds
     * @summary Get corporation contracts
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public getCorporationsCorporationIdContracts(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return ContractsApiFp(this.configuration).getCorporationsCorporationIdContracts(corporationId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * Lists bids on a particular auction contract  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/{contract_id}/bids/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/{contract_id}/bids/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/{contract_id}/bids/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation contract bids
     * @param {number} contractId ID of a contract
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public getCorporationsCorporationIdContractsContractIdBids(contractId: number, corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return ContractsApiFp(this.configuration).getCorporationsCorporationIdContractsContractIdBids(contractId, corporationId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * Lists items of a particular contract  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/{contract_id}/items/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/{contract_id}/items/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/{contract_id}/items/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation contract items
     * @param {number} contractId ID of a contract
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public getCorporationsCorporationIdContractsContractIdItems(contractId: number, corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return ContractsApiFp(this.configuration).getCorporationsCorporationIdContractsContractIdItems(contractId, corporationId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

}

/**
 * CorporationApi - fetch parameter creator
 * @export
 */
export const CorporationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Public information about a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/`  Alternate route: `/v5/corporations/{corporation_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation information
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationId(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationId.');
            }
            const localVarPath = `/corporations/{corporation_id}/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all the alliances a corporation has been a member of  --- Alternate route: `/dev/corporations/{corporation_id}/alliancehistory/`  Alternate route: `/v3/corporations/{corporation_id}/alliancehistory/`  --- This route is cached for up to 3600 seconds
         * @summary Get alliance history
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdAlliancehistory(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdAlliancehistory.');
            }
            const localVarPath = `/corporations/{corporation_id}/alliancehistory/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of blueprints the corporation owns  --- Alternate route: `/dev/corporations/{corporation_id}/blueprints/`  Alternate route: `/v3/corporations/{corporation_id}/blueprints/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation blueprints
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdBlueprints(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdBlueprints.');
            }
            const localVarPath = `/corporations/{corporation_id}/blueprints/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-corporations.read_blueprints.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns logs recorded in the past seven days from all audit log secure containers (ALSC) owned by a given corporation  --- Alternate route: `/dev/corporations/{corporation_id}/containers/logs/`  Alternate route: `/v3/corporations/{corporation_id}/containers/logs/`  --- This route is cached for up to 600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get all corporation ALSC logs
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdContainersLogs(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdContainersLogs.');
            }
            const localVarPath = `/corporations/{corporation_id}/containers/logs/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-corporations.read_container_logs.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return corporation hangar and wallet division names, only show if a division is not using the default name  --- Alternate route: `/dev/corporations/{corporation_id}/divisions/`  Alternate route: `/v2/corporations/{corporation_id}/divisions/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation divisions
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdDivisions(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdDivisions.');
            }
            const localVarPath = `/corporations/{corporation_id}/divisions/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-corporations.read_divisions.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a corporation's facilities  --- Alternate route: `/dev/corporations/{corporation_id}/facilities/`  Alternate route: `/v2/corporations/{corporation_id}/facilities/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Factory_Manager 
         * @summary Get corporation facilities
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdFacilities(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdFacilities.');
            }
            const localVarPath = `/corporations/{corporation_id}/facilities/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-corporations.read_facilities.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the icon urls for a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/icons/`  Alternate route: `/v2/corporations/{corporation_id}/icons/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation icon
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdIcons(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdIcons.');
            }
            const localVarPath = `/corporations/{corporation_id}/icons/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a corporation's medals  --- Alternate route: `/dev/corporations/{corporation_id}/medals/`  Alternate route: `/v2/corporations/{corporation_id}/medals/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation medals
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdMedals(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdMedals.');
            }
            const localVarPath = `/corporations/{corporation_id}/medals/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-corporations.read_medals.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns medals issued by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/medals/issued/`  Alternate route: `/v2/corporations/{corporation_id}/medals/issued/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation issued medals
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdMedalsIssued(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdMedalsIssued.');
            }
            const localVarPath = `/corporations/{corporation_id}/medals/issued/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-corporations.read_medals.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the current member list of a corporation, the token's character need to be a member of the corporation.  --- Alternate route: `/dev/corporations/{corporation_id}/members/`  Alternate route: `/v4/corporations/{corporation_id}/members/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation members
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdMembers(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdMembers.');
            }
            const localVarPath = `/corporations/{corporation_id}/members/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-corporations.read_corporation_membership.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a corporation's member limit, not including CEO himself  --- Alternate route: `/dev/corporations/{corporation_id}/members/limit/`  Alternate route: `/v2/corporations/{corporation_id}/members/limit/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation member limit
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdMembersLimit(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdMembersLimit.');
            }
            const localVarPath = `/corporations/{corporation_id}/members/limit/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-corporations.track_members.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a corporation's members' titles  --- Alternate route: `/dev/corporations/{corporation_id}/members/titles/`  Alternate route: `/v2/corporations/{corporation_id}/members/titles/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation's members' titles
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdMembersTitles(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdMembersTitles.');
            }
            const localVarPath = `/corporations/{corporation_id}/members/titles/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-corporations.read_titles.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns additional information about a corporation's members which helps tracking their activities  --- Alternate route: `/dev/corporations/{corporation_id}/membertracking/`  Alternate route: `/v2/corporations/{corporation_id}/membertracking/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Track corporation members
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdMembertracking(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdMembertracking.');
            }
            const localVarPath = `/corporations/{corporation_id}/membertracking/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-corporations.track_members.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the roles of all members if the character has the personnel manager role or any grantable role.  --- Alternate route: `/dev/corporations/{corporation_id}/roles/`  Alternate route: `/v2/corporations/{corporation_id}/roles/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation member roles
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdRoles(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdRoles.');
            }
            const localVarPath = `/corporations/{corporation_id}/roles/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-corporations.read_corporation_membership.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return how roles have changed for a coporation's members, up to a month  --- Alternate route: `/dev/corporations/{corporation_id}/roles/history/`  Alternate route: `/v2/corporations/{corporation_id}/roles/history/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation member roles history
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdRolesHistory(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdRolesHistory.');
            }
            const localVarPath = `/corporations/{corporation_id}/roles/history/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-corporations.read_corporation_membership.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the current shareholders of a corporation.  --- Alternate route: `/dev/corporations/{corporation_id}/shareholders/`  Alternate route: `/legacy/corporations/{corporation_id}/shareholders/`  Alternate route: `/v1/corporations/{corporation_id}/shareholders/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation shareholders
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdShareholders(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdShareholders.');
            }
            const localVarPath = `/corporations/{corporation_id}/shareholders/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-wallet.read_corporation_wallets.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return corporation standings from agents, NPC corporations, and factions  --- Alternate route: `/dev/corporations/{corporation_id}/standings/`  Alternate route: `/v2/corporations/{corporation_id}/standings/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation standings
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdStandings(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdStandings.');
            }
            const localVarPath = `/corporations/{corporation_id}/standings/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-corporations.read_standings.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list of corporation starbases (POSes)  --- Alternate route: `/dev/corporations/{corporation_id}/starbases/`  Alternate route: `/v2/corporations/{corporation_id}/starbases/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation starbases (POSes)
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdStarbases(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdStarbases.');
            }
            const localVarPath = `/corporations/{corporation_id}/starbases/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-corporations.read_starbases.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns various settings and fuels of a starbase (POS)  --- Alternate route: `/dev/corporations/{corporation_id}/starbases/{starbase_id}/`  Alternate route: `/v2/corporations/{corporation_id}/starbases/{starbase_id}/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get starbase (POS) detail
         * @param {number} corporationId An EVE corporation ID
         * @param {number} starbaseId An EVE starbase (POS) ID
         * @param {number} systemId The solar system this starbase (POS) is located in,
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdStarbasesStarbaseId(corporationId: number, starbaseId: number, systemId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdStarbasesStarbaseId.');
            }
            // verify required parameter 'starbaseId' is not null or undefined
            if (starbaseId === null || starbaseId === undefined) {
                throw new RequiredError('starbaseId','Required parameter starbaseId was null or undefined when calling getCorporationsCorporationIdStarbasesStarbaseId.');
            }
            // verify required parameter 'systemId' is not null or undefined
            if (systemId === null || systemId === undefined) {
                throw new RequiredError('systemId','Required parameter systemId was null or undefined when calling getCorporationsCorporationIdStarbasesStarbaseId.');
            }
            const localVarPath = `/corporations/{corporation_id}/starbases/{starbase_id}/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)))
                .replace(`{${"starbase_id"}}`, encodeURIComponent(String(starbaseId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-corporations.read_starbases.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (systemId !== undefined) {
                localVarQueryParameter['system_id'] = systemId;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of corporation structures. This route's version includes the changes to structures detailed in this blog: https://www.eveonline.com/article/upwell-2.0-structures-changes-coming-on-february-13th  --- Alternate route: `/dev/corporations/{corporation_id}/structures/`  Alternate route: `/v4/corporations/{corporation_id}/structures/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Station_Manager 
         * @summary Get corporation structures
         * @param {number} corporationId An EVE corporation ID
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdStructures(corporationId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdStructures.');
            }
            const localVarPath = `/corporations/{corporation_id}/structures/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-corporations.read_structures.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a corporation's titles  --- Alternate route: `/dev/corporations/{corporation_id}/titles/`  Alternate route: `/v2/corporations/{corporation_id}/titles/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation titles
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdTitles(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdTitles.');
            }
            const localVarPath = `/corporations/{corporation_id}/titles/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-corporations.read_titles.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of npc corporations  --- Alternate route: `/dev/corporations/npccorps/`  Alternate route: `/v2/corporations/npccorps/`  --- This route expires daily at 11:05
         * @summary Get npc corporations
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsNpccorps(datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            const localVarPath = `/corporations/npccorps/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CorporationApi - functional programming interface
 * @export
 */
export const CorporationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Public information about a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/`  Alternate route: `/v5/corporations/{corporation_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation information
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationId(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCorporationsCorporationIdOk> {
            const localVarFetchArgs = CorporationApiFetchParamCreator(configuration).getCorporationsCorporationId(corporationId, datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of all the alliances a corporation has been a member of  --- Alternate route: `/dev/corporations/{corporation_id}/alliancehistory/`  Alternate route: `/v3/corporations/{corporation_id}/alliancehistory/`  --- This route is cached for up to 3600 seconds
         * @summary Get alliance history
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdAlliancehistory(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationsCorporationIdAlliancehistory200Ok>> {
            const localVarFetchArgs = CorporationApiFetchParamCreator(configuration).getCorporationsCorporationIdAlliancehistory(corporationId, datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of blueprints the corporation owns  --- Alternate route: `/dev/corporations/{corporation_id}/blueprints/`  Alternate route: `/v3/corporations/{corporation_id}/blueprints/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation blueprints
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdBlueprints(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationsCorporationIdBlueprints200Ok>> {
            const localVarFetchArgs = CorporationApiFetchParamCreator(configuration).getCorporationsCorporationIdBlueprints(corporationId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns logs recorded in the past seven days from all audit log secure containers (ALSC) owned by a given corporation  --- Alternate route: `/dev/corporations/{corporation_id}/containers/logs/`  Alternate route: `/v3/corporations/{corporation_id}/containers/logs/`  --- This route is cached for up to 600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get all corporation ALSC logs
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdContainersLogs(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationsCorporationIdContainersLogs200Ok>> {
            const localVarFetchArgs = CorporationApiFetchParamCreator(configuration).getCorporationsCorporationIdContainersLogs(corporationId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return corporation hangar and wallet division names, only show if a division is not using the default name  --- Alternate route: `/dev/corporations/{corporation_id}/divisions/`  Alternate route: `/v2/corporations/{corporation_id}/divisions/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation divisions
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdDivisions(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCorporationsCorporationIdDivisionsOk> {
            const localVarFetchArgs = CorporationApiFetchParamCreator(configuration).getCorporationsCorporationIdDivisions(corporationId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a corporation's facilities  --- Alternate route: `/dev/corporations/{corporation_id}/facilities/`  Alternate route: `/v2/corporations/{corporation_id}/facilities/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Factory_Manager 
         * @summary Get corporation facilities
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdFacilities(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationsCorporationIdFacilities200Ok>> {
            const localVarFetchArgs = CorporationApiFetchParamCreator(configuration).getCorporationsCorporationIdFacilities(corporationId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the icon urls for a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/icons/`  Alternate route: `/v2/corporations/{corporation_id}/icons/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation icon
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdIcons(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCorporationsCorporationIdIconsOk> {
            const localVarFetchArgs = CorporationApiFetchParamCreator(configuration).getCorporationsCorporationIdIcons(corporationId, datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a corporation's medals  --- Alternate route: `/dev/corporations/{corporation_id}/medals/`  Alternate route: `/v2/corporations/{corporation_id}/medals/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation medals
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdMedals(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationsCorporationIdMedals200Ok>> {
            const localVarFetchArgs = CorporationApiFetchParamCreator(configuration).getCorporationsCorporationIdMedals(corporationId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns medals issued by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/medals/issued/`  Alternate route: `/v2/corporations/{corporation_id}/medals/issued/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation issued medals
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdMedalsIssued(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationsCorporationIdMedalsIssued200Ok>> {
            const localVarFetchArgs = CorporationApiFetchParamCreator(configuration).getCorporationsCorporationIdMedalsIssued(corporationId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return the current member list of a corporation, the token's character need to be a member of the corporation.  --- Alternate route: `/dev/corporations/{corporation_id}/members/`  Alternate route: `/v4/corporations/{corporation_id}/members/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation members
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdMembers(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = CorporationApiFetchParamCreator(configuration).getCorporationsCorporationIdMembers(corporationId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a corporation's member limit, not including CEO himself  --- Alternate route: `/dev/corporations/{corporation_id}/members/limit/`  Alternate route: `/v2/corporations/{corporation_id}/members/limit/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation member limit
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdMembersLimit(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = CorporationApiFetchParamCreator(configuration).getCorporationsCorporationIdMembersLimit(corporationId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a corporation's members' titles  --- Alternate route: `/dev/corporations/{corporation_id}/members/titles/`  Alternate route: `/v2/corporations/{corporation_id}/members/titles/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation's members' titles
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdMembersTitles(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationsCorporationIdMembersTitles200Ok>> {
            const localVarFetchArgs = CorporationApiFetchParamCreator(configuration).getCorporationsCorporationIdMembersTitles(corporationId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns additional information about a corporation's members which helps tracking their activities  --- Alternate route: `/dev/corporations/{corporation_id}/membertracking/`  Alternate route: `/v2/corporations/{corporation_id}/membertracking/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Track corporation members
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdMembertracking(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationsCorporationIdMembertracking200Ok>> {
            const localVarFetchArgs = CorporationApiFetchParamCreator(configuration).getCorporationsCorporationIdMembertracking(corporationId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return the roles of all members if the character has the personnel manager role or any grantable role.  --- Alternate route: `/dev/corporations/{corporation_id}/roles/`  Alternate route: `/v2/corporations/{corporation_id}/roles/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation member roles
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdRoles(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationsCorporationIdRoles200Ok>> {
            const localVarFetchArgs = CorporationApiFetchParamCreator(configuration).getCorporationsCorporationIdRoles(corporationId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return how roles have changed for a coporation's members, up to a month  --- Alternate route: `/dev/corporations/{corporation_id}/roles/history/`  Alternate route: `/v2/corporations/{corporation_id}/roles/history/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation member roles history
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdRolesHistory(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationsCorporationIdRolesHistory200Ok>> {
            const localVarFetchArgs = CorporationApiFetchParamCreator(configuration).getCorporationsCorporationIdRolesHistory(corporationId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return the current shareholders of a corporation.  --- Alternate route: `/dev/corporations/{corporation_id}/shareholders/`  Alternate route: `/legacy/corporations/{corporation_id}/shareholders/`  Alternate route: `/v1/corporations/{corporation_id}/shareholders/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation shareholders
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdShareholders(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationsCorporationIdShareholders200Ok>> {
            const localVarFetchArgs = CorporationApiFetchParamCreator(configuration).getCorporationsCorporationIdShareholders(corporationId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return corporation standings from agents, NPC corporations, and factions  --- Alternate route: `/dev/corporations/{corporation_id}/standings/`  Alternate route: `/v2/corporations/{corporation_id}/standings/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation standings
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdStandings(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationsCorporationIdStandings200Ok>> {
            const localVarFetchArgs = CorporationApiFetchParamCreator(configuration).getCorporationsCorporationIdStandings(corporationId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns list of corporation starbases (POSes)  --- Alternate route: `/dev/corporations/{corporation_id}/starbases/`  Alternate route: `/v2/corporations/{corporation_id}/starbases/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation starbases (POSes)
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdStarbases(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationsCorporationIdStarbases200Ok>> {
            const localVarFetchArgs = CorporationApiFetchParamCreator(configuration).getCorporationsCorporationIdStarbases(corporationId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns various settings and fuels of a starbase (POS)  --- Alternate route: `/dev/corporations/{corporation_id}/starbases/{starbase_id}/`  Alternate route: `/v2/corporations/{corporation_id}/starbases/{starbase_id}/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get starbase (POS) detail
         * @param {number} corporationId An EVE corporation ID
         * @param {number} starbaseId An EVE starbase (POS) ID
         * @param {number} systemId The solar system this starbase (POS) is located in,
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdStarbasesStarbaseId(corporationId: number, starbaseId: number, systemId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCorporationsCorporationIdStarbasesStarbaseIdOk> {
            const localVarFetchArgs = CorporationApiFetchParamCreator(configuration).getCorporationsCorporationIdStarbasesStarbaseId(corporationId, starbaseId, systemId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of corporation structures. This route's version includes the changes to structures detailed in this blog: https://www.eveonline.com/article/upwell-2.0-structures-changes-coming-on-february-13th  --- Alternate route: `/dev/corporations/{corporation_id}/structures/`  Alternate route: `/v4/corporations/{corporation_id}/structures/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Station_Manager 
         * @summary Get corporation structures
         * @param {number} corporationId An EVE corporation ID
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdStructures(corporationId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationsCorporationIdStructures200Ok>> {
            const localVarFetchArgs = CorporationApiFetchParamCreator(configuration).getCorporationsCorporationIdStructures(corporationId, acceptLanguage, datasource, ifNoneMatch, language, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a corporation's titles  --- Alternate route: `/dev/corporations/{corporation_id}/titles/`  Alternate route: `/v2/corporations/{corporation_id}/titles/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation titles
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdTitles(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationsCorporationIdTitles200Ok>> {
            const localVarFetchArgs = CorporationApiFetchParamCreator(configuration).getCorporationsCorporationIdTitles(corporationId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of npc corporations  --- Alternate route: `/dev/corporations/npccorps/`  Alternate route: `/v2/corporations/npccorps/`  --- This route expires daily at 11:05
         * @summary Get npc corporations
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsNpccorps(datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = CorporationApiFetchParamCreator(configuration).getCorporationsNpccorps(datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CorporationApi - factory interface
 * @export
 */
export const CorporationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Public information about a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/`  Alternate route: `/v5/corporations/{corporation_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation information
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationId(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return CorporationApiFp(configuration).getCorporationsCorporationId(corporationId, datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Get a list of all the alliances a corporation has been a member of  --- Alternate route: `/dev/corporations/{corporation_id}/alliancehistory/`  Alternate route: `/v3/corporations/{corporation_id}/alliancehistory/`  --- This route is cached for up to 3600 seconds
         * @summary Get alliance history
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdAlliancehistory(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return CorporationApiFp(configuration).getCorporationsCorporationIdAlliancehistory(corporationId, datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Returns a list of blueprints the corporation owns  --- Alternate route: `/dev/corporations/{corporation_id}/blueprints/`  Alternate route: `/v3/corporations/{corporation_id}/blueprints/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation blueprints
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdBlueprints(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return CorporationApiFp(configuration).getCorporationsCorporationIdBlueprints(corporationId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
        /**
         * Returns logs recorded in the past seven days from all audit log secure containers (ALSC) owned by a given corporation  --- Alternate route: `/dev/corporations/{corporation_id}/containers/logs/`  Alternate route: `/v3/corporations/{corporation_id}/containers/logs/`  --- This route is cached for up to 600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get all corporation ALSC logs
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdContainersLogs(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return CorporationApiFp(configuration).getCorporationsCorporationIdContainersLogs(corporationId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
        /**
         * Return corporation hangar and wallet division names, only show if a division is not using the default name  --- Alternate route: `/dev/corporations/{corporation_id}/divisions/`  Alternate route: `/v2/corporations/{corporation_id}/divisions/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation divisions
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdDivisions(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return CorporationApiFp(configuration).getCorporationsCorporationIdDivisions(corporationId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Return a corporation's facilities  --- Alternate route: `/dev/corporations/{corporation_id}/facilities/`  Alternate route: `/v2/corporations/{corporation_id}/facilities/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Factory_Manager 
         * @summary Get corporation facilities
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdFacilities(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return CorporationApiFp(configuration).getCorporationsCorporationIdFacilities(corporationId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Get the icon urls for a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/icons/`  Alternate route: `/v2/corporations/{corporation_id}/icons/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation icon
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdIcons(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return CorporationApiFp(configuration).getCorporationsCorporationIdIcons(corporationId, datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Returns a corporation's medals  --- Alternate route: `/dev/corporations/{corporation_id}/medals/`  Alternate route: `/v2/corporations/{corporation_id}/medals/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation medals
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdMedals(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return CorporationApiFp(configuration).getCorporationsCorporationIdMedals(corporationId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
        /**
         * Returns medals issued by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/medals/issued/`  Alternate route: `/v2/corporations/{corporation_id}/medals/issued/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation issued medals
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdMedalsIssued(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return CorporationApiFp(configuration).getCorporationsCorporationIdMedalsIssued(corporationId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
        /**
         * Return the current member list of a corporation, the token's character need to be a member of the corporation.  --- Alternate route: `/dev/corporations/{corporation_id}/members/`  Alternate route: `/v4/corporations/{corporation_id}/members/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation members
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdMembers(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return CorporationApiFp(configuration).getCorporationsCorporationIdMembers(corporationId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Return a corporation's member limit, not including CEO himself  --- Alternate route: `/dev/corporations/{corporation_id}/members/limit/`  Alternate route: `/v2/corporations/{corporation_id}/members/limit/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation member limit
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdMembersLimit(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return CorporationApiFp(configuration).getCorporationsCorporationIdMembersLimit(corporationId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Returns a corporation's members' titles  --- Alternate route: `/dev/corporations/{corporation_id}/members/titles/`  Alternate route: `/v2/corporations/{corporation_id}/members/titles/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation's members' titles
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdMembersTitles(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return CorporationApiFp(configuration).getCorporationsCorporationIdMembersTitles(corporationId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Returns additional information about a corporation's members which helps tracking their activities  --- Alternate route: `/dev/corporations/{corporation_id}/membertracking/`  Alternate route: `/v2/corporations/{corporation_id}/membertracking/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Track corporation members
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdMembertracking(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return CorporationApiFp(configuration).getCorporationsCorporationIdMembertracking(corporationId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Return the roles of all members if the character has the personnel manager role or any grantable role.  --- Alternate route: `/dev/corporations/{corporation_id}/roles/`  Alternate route: `/v2/corporations/{corporation_id}/roles/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation member roles
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdRoles(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return CorporationApiFp(configuration).getCorporationsCorporationIdRoles(corporationId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Return how roles have changed for a coporation's members, up to a month  --- Alternate route: `/dev/corporations/{corporation_id}/roles/history/`  Alternate route: `/v2/corporations/{corporation_id}/roles/history/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation member roles history
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdRolesHistory(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return CorporationApiFp(configuration).getCorporationsCorporationIdRolesHistory(corporationId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
        /**
         * Return the current shareholders of a corporation.  --- Alternate route: `/dev/corporations/{corporation_id}/shareholders/`  Alternate route: `/legacy/corporations/{corporation_id}/shareholders/`  Alternate route: `/v1/corporations/{corporation_id}/shareholders/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation shareholders
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdShareholders(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return CorporationApiFp(configuration).getCorporationsCorporationIdShareholders(corporationId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
        /**
         * Return corporation standings from agents, NPC corporations, and factions  --- Alternate route: `/dev/corporations/{corporation_id}/standings/`  Alternate route: `/v2/corporations/{corporation_id}/standings/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation standings
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdStandings(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return CorporationApiFp(configuration).getCorporationsCorporationIdStandings(corporationId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
        /**
         * Returns list of corporation starbases (POSes)  --- Alternate route: `/dev/corporations/{corporation_id}/starbases/`  Alternate route: `/v2/corporations/{corporation_id}/starbases/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation starbases (POSes)
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdStarbases(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return CorporationApiFp(configuration).getCorporationsCorporationIdStarbases(corporationId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
        /**
         * Returns various settings and fuels of a starbase (POS)  --- Alternate route: `/dev/corporations/{corporation_id}/starbases/{starbase_id}/`  Alternate route: `/v2/corporations/{corporation_id}/starbases/{starbase_id}/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get starbase (POS) detail
         * @param {number} corporationId An EVE corporation ID
         * @param {number} starbaseId An EVE starbase (POS) ID
         * @param {number} systemId The solar system this starbase (POS) is located in,
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdStarbasesStarbaseId(corporationId: number, starbaseId: number, systemId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return CorporationApiFp(configuration).getCorporationsCorporationIdStarbasesStarbaseId(corporationId, starbaseId, systemId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Get a list of corporation structures. This route's version includes the changes to structures detailed in this blog: https://www.eveonline.com/article/upwell-2.0-structures-changes-coming-on-february-13th  --- Alternate route: `/dev/corporations/{corporation_id}/structures/`  Alternate route: `/v4/corporations/{corporation_id}/structures/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Station_Manager 
         * @summary Get corporation structures
         * @param {number} corporationId An EVE corporation ID
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdStructures(corporationId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', page?: number, token?: string, options?: any) {
            return CorporationApiFp(configuration).getCorporationsCorporationIdStructures(corporationId, acceptLanguage, datasource, ifNoneMatch, language, page, token, options)(fetch, basePath);
        },
        /**
         * Returns a corporation's titles  --- Alternate route: `/dev/corporations/{corporation_id}/titles/`  Alternate route: `/v2/corporations/{corporation_id}/titles/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation titles
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdTitles(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return CorporationApiFp(configuration).getCorporationsCorporationIdTitles(corporationId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Get a list of npc corporations  --- Alternate route: `/dev/corporations/npccorps/`  Alternate route: `/v2/corporations/npccorps/`  --- This route expires daily at 11:05
         * @summary Get npc corporations
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsNpccorps(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return CorporationApiFp(configuration).getCorporationsNpccorps(datasource, ifNoneMatch, options)(fetch, basePath);
        },
    };
};

/**
 * CorporationApi - object-oriented interface
 * @export
 * @class CorporationApi
 * @extends {BaseAPI}
 */
export class CorporationApi extends BaseAPI {
    /**
     * Public information about a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/`  Alternate route: `/v5/corporations/{corporation_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation information
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporationApi
     */
    public getCorporationsCorporationId(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationId(corporationId, datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of all the alliances a corporation has been a member of  --- Alternate route: `/dev/corporations/{corporation_id}/alliancehistory/`  Alternate route: `/v3/corporations/{corporation_id}/alliancehistory/`  --- This route is cached for up to 3600 seconds
     * @summary Get alliance history
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporationApi
     */
    public getCorporationsCorporationIdAlliancehistory(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdAlliancehistory(corporationId, datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a list of blueprints the corporation owns  --- Alternate route: `/dev/corporations/{corporation_id}/blueprints/`  Alternate route: `/v3/corporations/{corporation_id}/blueprints/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation blueprints
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporationApi
     */
    public getCorporationsCorporationIdBlueprints(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdBlueprints(corporationId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * Returns logs recorded in the past seven days from all audit log secure containers (ALSC) owned by a given corporation  --- Alternate route: `/dev/corporations/{corporation_id}/containers/logs/`  Alternate route: `/v3/corporations/{corporation_id}/containers/logs/`  --- This route is cached for up to 600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get all corporation ALSC logs
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporationApi
     */
    public getCorporationsCorporationIdContainersLogs(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdContainersLogs(corporationId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return corporation hangar and wallet division names, only show if a division is not using the default name  --- Alternate route: `/dev/corporations/{corporation_id}/divisions/`  Alternate route: `/v2/corporations/{corporation_id}/divisions/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation divisions
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporationApi
     */
    public getCorporationsCorporationIdDivisions(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdDivisions(corporationId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return a corporation's facilities  --- Alternate route: `/dev/corporations/{corporation_id}/facilities/`  Alternate route: `/v2/corporations/{corporation_id}/facilities/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Factory_Manager 
     * @summary Get corporation facilities
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporationApi
     */
    public getCorporationsCorporationIdFacilities(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdFacilities(corporationId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Get the icon urls for a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/icons/`  Alternate route: `/v2/corporations/{corporation_id}/icons/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation icon
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporationApi
     */
    public getCorporationsCorporationIdIcons(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdIcons(corporationId, datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a corporation's medals  --- Alternate route: `/dev/corporations/{corporation_id}/medals/`  Alternate route: `/v2/corporations/{corporation_id}/medals/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation medals
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporationApi
     */
    public getCorporationsCorporationIdMedals(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdMedals(corporationId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * Returns medals issued by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/medals/issued/`  Alternate route: `/v2/corporations/{corporation_id}/medals/issued/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation issued medals
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporationApi
     */
    public getCorporationsCorporationIdMedalsIssued(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdMedalsIssued(corporationId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return the current member list of a corporation, the token's character need to be a member of the corporation.  --- Alternate route: `/dev/corporations/{corporation_id}/members/`  Alternate route: `/v4/corporations/{corporation_id}/members/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation members
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporationApi
     */
    public getCorporationsCorporationIdMembers(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdMembers(corporationId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return a corporation's member limit, not including CEO himself  --- Alternate route: `/dev/corporations/{corporation_id}/members/limit/`  Alternate route: `/v2/corporations/{corporation_id}/members/limit/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation member limit
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporationApi
     */
    public getCorporationsCorporationIdMembersLimit(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdMembersLimit(corporationId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a corporation's members' titles  --- Alternate route: `/dev/corporations/{corporation_id}/members/titles/`  Alternate route: `/v2/corporations/{corporation_id}/members/titles/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation's members' titles
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporationApi
     */
    public getCorporationsCorporationIdMembersTitles(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdMembersTitles(corporationId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Returns additional information about a corporation's members which helps tracking their activities  --- Alternate route: `/dev/corporations/{corporation_id}/membertracking/`  Alternate route: `/v2/corporations/{corporation_id}/membertracking/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Track corporation members
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporationApi
     */
    public getCorporationsCorporationIdMembertracking(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdMembertracking(corporationId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return the roles of all members if the character has the personnel manager role or any grantable role.  --- Alternate route: `/dev/corporations/{corporation_id}/roles/`  Alternate route: `/v2/corporations/{corporation_id}/roles/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation member roles
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporationApi
     */
    public getCorporationsCorporationIdRoles(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdRoles(corporationId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return how roles have changed for a coporation's members, up to a month  --- Alternate route: `/dev/corporations/{corporation_id}/roles/history/`  Alternate route: `/v2/corporations/{corporation_id}/roles/history/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation member roles history
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporationApi
     */
    public getCorporationsCorporationIdRolesHistory(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdRolesHistory(corporationId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return the current shareholders of a corporation.  --- Alternate route: `/dev/corporations/{corporation_id}/shareholders/`  Alternate route: `/legacy/corporations/{corporation_id}/shareholders/`  Alternate route: `/v1/corporations/{corporation_id}/shareholders/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation shareholders
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporationApi
     */
    public getCorporationsCorporationIdShareholders(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdShareholders(corporationId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return corporation standings from agents, NPC corporations, and factions  --- Alternate route: `/dev/corporations/{corporation_id}/standings/`  Alternate route: `/v2/corporations/{corporation_id}/standings/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation standings
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporationApi
     */
    public getCorporationsCorporationIdStandings(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdStandings(corporationId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * Returns list of corporation starbases (POSes)  --- Alternate route: `/dev/corporations/{corporation_id}/starbases/`  Alternate route: `/v2/corporations/{corporation_id}/starbases/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation starbases (POSes)
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporationApi
     */
    public getCorporationsCorporationIdStarbases(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdStarbases(corporationId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * Returns various settings and fuels of a starbase (POS)  --- Alternate route: `/dev/corporations/{corporation_id}/starbases/{starbase_id}/`  Alternate route: `/v2/corporations/{corporation_id}/starbases/{starbase_id}/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get starbase (POS) detail
     * @param {number} corporationId An EVE corporation ID
     * @param {number} starbaseId An EVE starbase (POS) ID
     * @param {number} systemId The solar system this starbase (POS) is located in,
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporationApi
     */
    public getCorporationsCorporationIdStarbasesStarbaseId(corporationId: number, starbaseId: number, systemId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdStarbasesStarbaseId(corporationId, starbaseId, systemId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of corporation structures. This route's version includes the changes to structures detailed in this blog: https://www.eveonline.com/article/upwell-2.0-structures-changes-coming-on-february-13th  --- Alternate route: `/dev/corporations/{corporation_id}/structures/`  Alternate route: `/v4/corporations/{corporation_id}/structures/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Station_Manager 
     * @summary Get corporation structures
     * @param {number} corporationId An EVE corporation ID
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporationApi
     */
    public getCorporationsCorporationIdStructures(corporationId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', page?: number, token?: string, options?: any) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdStructures(corporationId, acceptLanguage, datasource, ifNoneMatch, language, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a corporation's titles  --- Alternate route: `/dev/corporations/{corporation_id}/titles/`  Alternate route: `/v2/corporations/{corporation_id}/titles/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation titles
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporationApi
     */
    public getCorporationsCorporationIdTitles(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdTitles(corporationId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of npc corporations  --- Alternate route: `/dev/corporations/npccorps/`  Alternate route: `/v2/corporations/npccorps/`  --- This route expires daily at 11:05
     * @summary Get npc corporations
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporationApi
     */
    public getCorporationsNpccorps(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return CorporationApiFp(this.configuration).getCorporationsNpccorps(datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

}

/**
 * DogmaApi - fetch parameter creator
 * @export
 */
export const DogmaApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of dogma attribute ids  --- Alternate route: `/dev/dogma/attributes/`  Alternate route: `/legacy/dogma/attributes/`  Alternate route: `/v1/dogma/attributes/`  --- This route expires daily at 11:05
         * @summary Get attributes
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDogmaAttributes(datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            const localVarPath = `/dogma/attributes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on a dogma attribute  --- Alternate route: `/dev/dogma/attributes/{attribute_id}/`  Alternate route: `/legacy/dogma/attributes/{attribute_id}/`  Alternate route: `/v1/dogma/attributes/{attribute_id}/`  --- This route expires daily at 11:05
         * @summary Get attribute information
         * @param {number} attributeId A dogma attribute ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDogmaAttributesAttributeId(attributeId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'attributeId' is not null or undefined
            if (attributeId === null || attributeId === undefined) {
                throw new RequiredError('attributeId','Required parameter attributeId was null or undefined when calling getDogmaAttributesAttributeId.');
            }
            const localVarPath = `/dogma/attributes/{attribute_id}/`
                .replace(`{${"attribute_id"}}`, encodeURIComponent(String(attributeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns info about a dynamic item resulting from mutation with a mutaplasmid.  --- Alternate route: `/dev/dogma/dynamic/items/{type_id}/{item_id}/`  Alternate route: `/legacy/dogma/dynamic/items/{type_id}/{item_id}/`  Alternate route: `/v1/dogma/dynamic/items/{type_id}/{item_id}/`  --- This route expires daily at 11:05
         * @summary Get dynamic item information
         * @param {number} itemId item_id integer
         * @param {number} typeId type_id integer
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDogmaDynamicItemsTypeIdItemId(itemId: number, typeId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getDogmaDynamicItemsTypeIdItemId.');
            }
            // verify required parameter 'typeId' is not null or undefined
            if (typeId === null || typeId === undefined) {
                throw new RequiredError('typeId','Required parameter typeId was null or undefined when calling getDogmaDynamicItemsTypeIdItemId.');
            }
            const localVarPath = `/dogma/dynamic/items/{type_id}/{item_id}/`
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"type_id"}}`, encodeURIComponent(String(typeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of dogma effect ids  --- Alternate route: `/dev/dogma/effects/`  Alternate route: `/legacy/dogma/effects/`  Alternate route: `/v1/dogma/effects/`  --- This route expires daily at 11:05
         * @summary Get effects
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDogmaEffects(datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            const localVarPath = `/dogma/effects/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on a dogma effect  --- Alternate route: `/dev/dogma/effects/{effect_id}/`  Alternate route: `/v2/dogma/effects/{effect_id}/`  --- This route expires daily at 11:05
         * @summary Get effect information
         * @param {number} effectId A dogma effect ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDogmaEffectsEffectId(effectId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'effectId' is not null or undefined
            if (effectId === null || effectId === undefined) {
                throw new RequiredError('effectId','Required parameter effectId was null or undefined when calling getDogmaEffectsEffectId.');
            }
            const localVarPath = `/dogma/effects/{effect_id}/`
                .replace(`{${"effect_id"}}`, encodeURIComponent(String(effectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DogmaApi - functional programming interface
 * @export
 */
export const DogmaApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get a list of dogma attribute ids  --- Alternate route: `/dev/dogma/attributes/`  Alternate route: `/legacy/dogma/attributes/`  Alternate route: `/v1/dogma/attributes/`  --- This route expires daily at 11:05
         * @summary Get attributes
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDogmaAttributes(datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DogmaApiFetchParamCreator(configuration).getDogmaAttributes(datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information on a dogma attribute  --- Alternate route: `/dev/dogma/attributes/{attribute_id}/`  Alternate route: `/legacy/dogma/attributes/{attribute_id}/`  Alternate route: `/v1/dogma/attributes/{attribute_id}/`  --- This route expires daily at 11:05
         * @summary Get attribute information
         * @param {number} attributeId A dogma attribute ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDogmaAttributesAttributeId(attributeId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetDogmaAttributesAttributeIdOk> {
            const localVarFetchArgs = DogmaApiFetchParamCreator(configuration).getDogmaAttributesAttributeId(attributeId, datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns info about a dynamic item resulting from mutation with a mutaplasmid.  --- Alternate route: `/dev/dogma/dynamic/items/{type_id}/{item_id}/`  Alternate route: `/legacy/dogma/dynamic/items/{type_id}/{item_id}/`  Alternate route: `/v1/dogma/dynamic/items/{type_id}/{item_id}/`  --- This route expires daily at 11:05
         * @summary Get dynamic item information
         * @param {number} itemId item_id integer
         * @param {number} typeId type_id integer
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDogmaDynamicItemsTypeIdItemId(itemId: number, typeId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetDogmaDynamicItemsTypeIdItemIdOk> {
            const localVarFetchArgs = DogmaApiFetchParamCreator(configuration).getDogmaDynamicItemsTypeIdItemId(itemId, typeId, datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of dogma effect ids  --- Alternate route: `/dev/dogma/effects/`  Alternate route: `/legacy/dogma/effects/`  Alternate route: `/v1/dogma/effects/`  --- This route expires daily at 11:05
         * @summary Get effects
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDogmaEffects(datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DogmaApiFetchParamCreator(configuration).getDogmaEffects(datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information on a dogma effect  --- Alternate route: `/dev/dogma/effects/{effect_id}/`  Alternate route: `/v2/dogma/effects/{effect_id}/`  --- This route expires daily at 11:05
         * @summary Get effect information
         * @param {number} effectId A dogma effect ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDogmaEffectsEffectId(effectId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetDogmaEffectsEffectIdOk> {
            const localVarFetchArgs = DogmaApiFetchParamCreator(configuration).getDogmaEffectsEffectId(effectId, datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DogmaApi - factory interface
 * @export
 */
export const DogmaApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get a list of dogma attribute ids  --- Alternate route: `/dev/dogma/attributes/`  Alternate route: `/legacy/dogma/attributes/`  Alternate route: `/v1/dogma/attributes/`  --- This route expires daily at 11:05
         * @summary Get attributes
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDogmaAttributes(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return DogmaApiFp(configuration).getDogmaAttributes(datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Get information on a dogma attribute  --- Alternate route: `/dev/dogma/attributes/{attribute_id}/`  Alternate route: `/legacy/dogma/attributes/{attribute_id}/`  Alternate route: `/v1/dogma/attributes/{attribute_id}/`  --- This route expires daily at 11:05
         * @summary Get attribute information
         * @param {number} attributeId A dogma attribute ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDogmaAttributesAttributeId(attributeId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return DogmaApiFp(configuration).getDogmaAttributesAttributeId(attributeId, datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Returns info about a dynamic item resulting from mutation with a mutaplasmid.  --- Alternate route: `/dev/dogma/dynamic/items/{type_id}/{item_id}/`  Alternate route: `/legacy/dogma/dynamic/items/{type_id}/{item_id}/`  Alternate route: `/v1/dogma/dynamic/items/{type_id}/{item_id}/`  --- This route expires daily at 11:05
         * @summary Get dynamic item information
         * @param {number} itemId item_id integer
         * @param {number} typeId type_id integer
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDogmaDynamicItemsTypeIdItemId(itemId: number, typeId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return DogmaApiFp(configuration).getDogmaDynamicItemsTypeIdItemId(itemId, typeId, datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Get a list of dogma effect ids  --- Alternate route: `/dev/dogma/effects/`  Alternate route: `/legacy/dogma/effects/`  Alternate route: `/v1/dogma/effects/`  --- This route expires daily at 11:05
         * @summary Get effects
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDogmaEffects(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return DogmaApiFp(configuration).getDogmaEffects(datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Get information on a dogma effect  --- Alternate route: `/dev/dogma/effects/{effect_id}/`  Alternate route: `/v2/dogma/effects/{effect_id}/`  --- This route expires daily at 11:05
         * @summary Get effect information
         * @param {number} effectId A dogma effect ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDogmaEffectsEffectId(effectId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return DogmaApiFp(configuration).getDogmaEffectsEffectId(effectId, datasource, ifNoneMatch, options)(fetch, basePath);
        },
    };
};

/**
 * DogmaApi - object-oriented interface
 * @export
 * @class DogmaApi
 * @extends {BaseAPI}
 */
export class DogmaApi extends BaseAPI {
    /**
     * Get a list of dogma attribute ids  --- Alternate route: `/dev/dogma/attributes/`  Alternate route: `/legacy/dogma/attributes/`  Alternate route: `/v1/dogma/attributes/`  --- This route expires daily at 11:05
     * @summary Get attributes
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DogmaApi
     */
    public getDogmaAttributes(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return DogmaApiFp(this.configuration).getDogmaAttributes(datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Get information on a dogma attribute  --- Alternate route: `/dev/dogma/attributes/{attribute_id}/`  Alternate route: `/legacy/dogma/attributes/{attribute_id}/`  Alternate route: `/v1/dogma/attributes/{attribute_id}/`  --- This route expires daily at 11:05
     * @summary Get attribute information
     * @param {number} attributeId A dogma attribute ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DogmaApi
     */
    public getDogmaAttributesAttributeId(attributeId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return DogmaApiFp(this.configuration).getDogmaAttributesAttributeId(attributeId, datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Returns info about a dynamic item resulting from mutation with a mutaplasmid.  --- Alternate route: `/dev/dogma/dynamic/items/{type_id}/{item_id}/`  Alternate route: `/legacy/dogma/dynamic/items/{type_id}/{item_id}/`  Alternate route: `/v1/dogma/dynamic/items/{type_id}/{item_id}/`  --- This route expires daily at 11:05
     * @summary Get dynamic item information
     * @param {number} itemId item_id integer
     * @param {number} typeId type_id integer
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DogmaApi
     */
    public getDogmaDynamicItemsTypeIdItemId(itemId: number, typeId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return DogmaApiFp(this.configuration).getDogmaDynamicItemsTypeIdItemId(itemId, typeId, datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of dogma effect ids  --- Alternate route: `/dev/dogma/effects/`  Alternate route: `/legacy/dogma/effects/`  Alternate route: `/v1/dogma/effects/`  --- This route expires daily at 11:05
     * @summary Get effects
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DogmaApi
     */
    public getDogmaEffects(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return DogmaApiFp(this.configuration).getDogmaEffects(datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Get information on a dogma effect  --- Alternate route: `/dev/dogma/effects/{effect_id}/`  Alternate route: `/v2/dogma/effects/{effect_id}/`  --- This route expires daily at 11:05
     * @summary Get effect information
     * @param {number} effectId A dogma effect ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DogmaApi
     */
    public getDogmaEffectsEffectId(effectId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return DogmaApiFp(this.configuration).getDogmaEffectsEffectId(effectId, datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

}

/**
 * FactionWarfareApi - fetch parameter creator
 * @export
 */
export const FactionWarfareApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Statistical overview of a character involved in faction warfare  --- Alternate route: `/dev/characters/{character_id}/fw/stats/`  Alternate route: `/legacy/characters/{character_id}/fw/stats/`  Alternate route: `/v1/characters/{character_id}/fw/stats/`  Alternate route: `/v2/characters/{character_id}/fw/stats/`  --- This route expires daily at 11:05
         * @summary Overview of a character involved in faction warfare
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdFwStats(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdFwStats.');
            }
            const localVarPath = `/characters/{character_id}/fw/stats/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-characters.read_fw_stats.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Statistics about a corporation involved in faction warfare  --- Alternate route: `/dev/corporations/{corporation_id}/fw/stats/`  Alternate route: `/legacy/corporations/{corporation_id}/fw/stats/`  Alternate route: `/v1/corporations/{corporation_id}/fw/stats/`  Alternate route: `/v2/corporations/{corporation_id}/fw/stats/`  --- This route expires daily at 11:05
         * @summary Overview of a corporation involved in faction warfare
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdFwStats(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdFwStats.');
            }
            const localVarPath = `/corporations/{corporation_id}/fw/stats/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-corporations.read_fw_stats.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Top 4 leaderboard of factions for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/`  Alternate route: `/legacy/fw/leaderboards/`  Alternate route: `/v1/fw/leaderboards/`  Alternate route: `/v2/fw/leaderboards/`  --- This route expires daily at 11:05
         * @summary List of the top factions in faction warfare
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFwLeaderboards(datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            const localVarPath = `/fw/leaderboards/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Top 100 leaderboard of pilots for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/characters/`  Alternate route: `/legacy/fw/leaderboards/characters/`  Alternate route: `/v1/fw/leaderboards/characters/`  Alternate route: `/v2/fw/leaderboards/characters/`  --- This route expires daily at 11:05
         * @summary List of the top pilots in faction warfare
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFwLeaderboardsCharacters(datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            const localVarPath = `/fw/leaderboards/characters/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Top 10 leaderboard of corporations for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/corporations/`  Alternate route: `/legacy/fw/leaderboards/corporations/`  Alternate route: `/v1/fw/leaderboards/corporations/`  Alternate route: `/v2/fw/leaderboards/corporations/`  --- This route expires daily at 11:05
         * @summary List of the top corporations in faction warfare
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFwLeaderboardsCorporations(datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            const localVarPath = `/fw/leaderboards/corporations/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Statistical overviews of factions involved in faction warfare  --- Alternate route: `/dev/fw/stats/`  Alternate route: `/legacy/fw/stats/`  Alternate route: `/v1/fw/stats/`  Alternate route: `/v2/fw/stats/`  --- This route expires daily at 11:05
         * @summary An overview of statistics about factions involved in faction warfare
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFwStats(datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            const localVarPath = `/fw/stats/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * An overview of the current ownership of faction warfare solar systems  --- Alternate route: `/dev/fw/systems/`  Alternate route: `/legacy/fw/systems/`  Alternate route: `/v2/fw/systems/`  Alternate route: `/v3/fw/systems/`  --- This route is cached for up to 1800 seconds
         * @summary Ownership of faction warfare systems
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFwSystems(datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            const localVarPath = `/fw/systems/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Data about which NPC factions are at war  --- Alternate route: `/dev/fw/wars/`  Alternate route: `/legacy/fw/wars/`  Alternate route: `/v1/fw/wars/`  Alternate route: `/v2/fw/wars/`  --- This route expires daily at 11:05
         * @summary Data about which NPC factions are at war
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFwWars(datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            const localVarPath = `/fw/wars/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FactionWarfareApi - functional programming interface
 * @export
 */
export const FactionWarfareApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Statistical overview of a character involved in faction warfare  --- Alternate route: `/dev/characters/{character_id}/fw/stats/`  Alternate route: `/legacy/characters/{character_id}/fw/stats/`  Alternate route: `/v1/characters/{character_id}/fw/stats/`  Alternate route: `/v2/characters/{character_id}/fw/stats/`  --- This route expires daily at 11:05
         * @summary Overview of a character involved in faction warfare
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdFwStats(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCharactersCharacterIdFwStatsOk> {
            const localVarFetchArgs = FactionWarfareApiFetchParamCreator(configuration).getCharactersCharacterIdFwStats(characterId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Statistics about a corporation involved in faction warfare  --- Alternate route: `/dev/corporations/{corporation_id}/fw/stats/`  Alternate route: `/legacy/corporations/{corporation_id}/fw/stats/`  Alternate route: `/v1/corporations/{corporation_id}/fw/stats/`  Alternate route: `/v2/corporations/{corporation_id}/fw/stats/`  --- This route expires daily at 11:05
         * @summary Overview of a corporation involved in faction warfare
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdFwStats(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCorporationsCorporationIdFwStatsOk> {
            const localVarFetchArgs = FactionWarfareApiFetchParamCreator(configuration).getCorporationsCorporationIdFwStats(corporationId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Top 4 leaderboard of factions for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/`  Alternate route: `/legacy/fw/leaderboards/`  Alternate route: `/v1/fw/leaderboards/`  Alternate route: `/v2/fw/leaderboards/`  --- This route expires daily at 11:05
         * @summary List of the top factions in faction warfare
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFwLeaderboards(datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetFwLeaderboardsOk> {
            const localVarFetchArgs = FactionWarfareApiFetchParamCreator(configuration).getFwLeaderboards(datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Top 100 leaderboard of pilots for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/characters/`  Alternate route: `/legacy/fw/leaderboards/characters/`  Alternate route: `/v1/fw/leaderboards/characters/`  Alternate route: `/v2/fw/leaderboards/characters/`  --- This route expires daily at 11:05
         * @summary List of the top pilots in faction warfare
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFwLeaderboardsCharacters(datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetFwLeaderboardsCharactersOk> {
            const localVarFetchArgs = FactionWarfareApiFetchParamCreator(configuration).getFwLeaderboardsCharacters(datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Top 10 leaderboard of corporations for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/corporations/`  Alternate route: `/legacy/fw/leaderboards/corporations/`  Alternate route: `/v1/fw/leaderboards/corporations/`  Alternate route: `/v2/fw/leaderboards/corporations/`  --- This route expires daily at 11:05
         * @summary List of the top corporations in faction warfare
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFwLeaderboardsCorporations(datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetFwLeaderboardsCorporationsOk> {
            const localVarFetchArgs = FactionWarfareApiFetchParamCreator(configuration).getFwLeaderboardsCorporations(datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Statistical overviews of factions involved in faction warfare  --- Alternate route: `/dev/fw/stats/`  Alternate route: `/legacy/fw/stats/`  Alternate route: `/v1/fw/stats/`  Alternate route: `/v2/fw/stats/`  --- This route expires daily at 11:05
         * @summary An overview of statistics about factions involved in faction warfare
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFwStats(datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetFwStats200Ok>> {
            const localVarFetchArgs = FactionWarfareApiFetchParamCreator(configuration).getFwStats(datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * An overview of the current ownership of faction warfare solar systems  --- Alternate route: `/dev/fw/systems/`  Alternate route: `/legacy/fw/systems/`  Alternate route: `/v2/fw/systems/`  Alternate route: `/v3/fw/systems/`  --- This route is cached for up to 1800 seconds
         * @summary Ownership of faction warfare systems
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFwSystems(datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetFwSystems200Ok>> {
            const localVarFetchArgs = FactionWarfareApiFetchParamCreator(configuration).getFwSystems(datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Data about which NPC factions are at war  --- Alternate route: `/dev/fw/wars/`  Alternate route: `/legacy/fw/wars/`  Alternate route: `/v1/fw/wars/`  Alternate route: `/v2/fw/wars/`  --- This route expires daily at 11:05
         * @summary Data about which NPC factions are at war
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFwWars(datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetFwWars200Ok>> {
            const localVarFetchArgs = FactionWarfareApiFetchParamCreator(configuration).getFwWars(datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FactionWarfareApi - factory interface
 * @export
 */
export const FactionWarfareApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Statistical overview of a character involved in faction warfare  --- Alternate route: `/dev/characters/{character_id}/fw/stats/`  Alternate route: `/legacy/characters/{character_id}/fw/stats/`  Alternate route: `/v1/characters/{character_id}/fw/stats/`  Alternate route: `/v2/characters/{character_id}/fw/stats/`  --- This route expires daily at 11:05
         * @summary Overview of a character involved in faction warfare
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdFwStats(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return FactionWarfareApiFp(configuration).getCharactersCharacterIdFwStats(characterId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Statistics about a corporation involved in faction warfare  --- Alternate route: `/dev/corporations/{corporation_id}/fw/stats/`  Alternate route: `/legacy/corporations/{corporation_id}/fw/stats/`  Alternate route: `/v1/corporations/{corporation_id}/fw/stats/`  Alternate route: `/v2/corporations/{corporation_id}/fw/stats/`  --- This route expires daily at 11:05
         * @summary Overview of a corporation involved in faction warfare
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdFwStats(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return FactionWarfareApiFp(configuration).getCorporationsCorporationIdFwStats(corporationId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Top 4 leaderboard of factions for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/`  Alternate route: `/legacy/fw/leaderboards/`  Alternate route: `/v1/fw/leaderboards/`  Alternate route: `/v2/fw/leaderboards/`  --- This route expires daily at 11:05
         * @summary List of the top factions in faction warfare
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFwLeaderboards(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return FactionWarfareApiFp(configuration).getFwLeaderboards(datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Top 100 leaderboard of pilots for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/characters/`  Alternate route: `/legacy/fw/leaderboards/characters/`  Alternate route: `/v1/fw/leaderboards/characters/`  Alternate route: `/v2/fw/leaderboards/characters/`  --- This route expires daily at 11:05
         * @summary List of the top pilots in faction warfare
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFwLeaderboardsCharacters(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return FactionWarfareApiFp(configuration).getFwLeaderboardsCharacters(datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Top 10 leaderboard of corporations for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/corporations/`  Alternate route: `/legacy/fw/leaderboards/corporations/`  Alternate route: `/v1/fw/leaderboards/corporations/`  Alternate route: `/v2/fw/leaderboards/corporations/`  --- This route expires daily at 11:05
         * @summary List of the top corporations in faction warfare
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFwLeaderboardsCorporations(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return FactionWarfareApiFp(configuration).getFwLeaderboardsCorporations(datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Statistical overviews of factions involved in faction warfare  --- Alternate route: `/dev/fw/stats/`  Alternate route: `/legacy/fw/stats/`  Alternate route: `/v1/fw/stats/`  Alternate route: `/v2/fw/stats/`  --- This route expires daily at 11:05
         * @summary An overview of statistics about factions involved in faction warfare
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFwStats(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return FactionWarfareApiFp(configuration).getFwStats(datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * An overview of the current ownership of faction warfare solar systems  --- Alternate route: `/dev/fw/systems/`  Alternate route: `/legacy/fw/systems/`  Alternate route: `/v2/fw/systems/`  Alternate route: `/v3/fw/systems/`  --- This route is cached for up to 1800 seconds
         * @summary Ownership of faction warfare systems
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFwSystems(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return FactionWarfareApiFp(configuration).getFwSystems(datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Data about which NPC factions are at war  --- Alternate route: `/dev/fw/wars/`  Alternate route: `/legacy/fw/wars/`  Alternate route: `/v1/fw/wars/`  Alternate route: `/v2/fw/wars/`  --- This route expires daily at 11:05
         * @summary Data about which NPC factions are at war
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFwWars(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return FactionWarfareApiFp(configuration).getFwWars(datasource, ifNoneMatch, options)(fetch, basePath);
        },
    };
};

/**
 * FactionWarfareApi - object-oriented interface
 * @export
 * @class FactionWarfareApi
 * @extends {BaseAPI}
 */
export class FactionWarfareApi extends BaseAPI {
    /**
     * Statistical overview of a character involved in faction warfare  --- Alternate route: `/dev/characters/{character_id}/fw/stats/`  Alternate route: `/legacy/characters/{character_id}/fw/stats/`  Alternate route: `/v1/characters/{character_id}/fw/stats/`  Alternate route: `/v2/characters/{character_id}/fw/stats/`  --- This route expires daily at 11:05
     * @summary Overview of a character involved in faction warfare
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactionWarfareApi
     */
    public getCharactersCharacterIdFwStats(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return FactionWarfareApiFp(this.configuration).getCharactersCharacterIdFwStats(characterId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Statistics about a corporation involved in faction warfare  --- Alternate route: `/dev/corporations/{corporation_id}/fw/stats/`  Alternate route: `/legacy/corporations/{corporation_id}/fw/stats/`  Alternate route: `/v1/corporations/{corporation_id}/fw/stats/`  Alternate route: `/v2/corporations/{corporation_id}/fw/stats/`  --- This route expires daily at 11:05
     * @summary Overview of a corporation involved in faction warfare
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactionWarfareApi
     */
    public getCorporationsCorporationIdFwStats(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return FactionWarfareApiFp(this.configuration).getCorporationsCorporationIdFwStats(corporationId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Top 4 leaderboard of factions for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/`  Alternate route: `/legacy/fw/leaderboards/`  Alternate route: `/v1/fw/leaderboards/`  Alternate route: `/v2/fw/leaderboards/`  --- This route expires daily at 11:05
     * @summary List of the top factions in faction warfare
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactionWarfareApi
     */
    public getFwLeaderboards(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return FactionWarfareApiFp(this.configuration).getFwLeaderboards(datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Top 100 leaderboard of pilots for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/characters/`  Alternate route: `/legacy/fw/leaderboards/characters/`  Alternate route: `/v1/fw/leaderboards/characters/`  Alternate route: `/v2/fw/leaderboards/characters/`  --- This route expires daily at 11:05
     * @summary List of the top pilots in faction warfare
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactionWarfareApi
     */
    public getFwLeaderboardsCharacters(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return FactionWarfareApiFp(this.configuration).getFwLeaderboardsCharacters(datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Top 10 leaderboard of corporations for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/corporations/`  Alternate route: `/legacy/fw/leaderboards/corporations/`  Alternate route: `/v1/fw/leaderboards/corporations/`  Alternate route: `/v2/fw/leaderboards/corporations/`  --- This route expires daily at 11:05
     * @summary List of the top corporations in faction warfare
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactionWarfareApi
     */
    public getFwLeaderboardsCorporations(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return FactionWarfareApiFp(this.configuration).getFwLeaderboardsCorporations(datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Statistical overviews of factions involved in faction warfare  --- Alternate route: `/dev/fw/stats/`  Alternate route: `/legacy/fw/stats/`  Alternate route: `/v1/fw/stats/`  Alternate route: `/v2/fw/stats/`  --- This route expires daily at 11:05
     * @summary An overview of statistics about factions involved in faction warfare
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactionWarfareApi
     */
    public getFwStats(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return FactionWarfareApiFp(this.configuration).getFwStats(datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * An overview of the current ownership of faction warfare solar systems  --- Alternate route: `/dev/fw/systems/`  Alternate route: `/legacy/fw/systems/`  Alternate route: `/v2/fw/systems/`  Alternate route: `/v3/fw/systems/`  --- This route is cached for up to 1800 seconds
     * @summary Ownership of faction warfare systems
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactionWarfareApi
     */
    public getFwSystems(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return FactionWarfareApiFp(this.configuration).getFwSystems(datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Data about which NPC factions are at war  --- Alternate route: `/dev/fw/wars/`  Alternate route: `/legacy/fw/wars/`  Alternate route: `/v1/fw/wars/`  Alternate route: `/v2/fw/wars/`  --- This route expires daily at 11:05
     * @summary Data about which NPC factions are at war
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactionWarfareApi
     */
    public getFwWars(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return FactionWarfareApiFp(this.configuration).getFwWars(datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

}

/**
 * FittingsApi - fetch parameter creator
 * @export
 */
export const FittingsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a fitting from a character  --- Alternate route: `/dev/characters/{character_id}/fittings/{fitting_id}/`  Alternate route: `/legacy/characters/{character_id}/fittings/{fitting_id}/`  Alternate route: `/v1/characters/{character_id}/fittings/{fitting_id}/` 
         * @summary Delete fitting
         * @param {number} characterId An EVE character ID
         * @param {number} fittingId ID for a fitting of this character
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharactersCharacterIdFittingsFittingId(characterId: number, fittingId: number, datasource?: 'tranquility', token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling deleteCharactersCharacterIdFittingsFittingId.');
            }
            // verify required parameter 'fittingId' is not null or undefined
            if (fittingId === null || fittingId === undefined) {
                throw new RequiredError('fittingId','Required parameter fittingId was null or undefined when calling deleteCharactersCharacterIdFittingsFittingId.');
            }
            const localVarPath = `/characters/{character_id}/fittings/{fitting_id}/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)))
                .replace(`{${"fitting_id"}}`, encodeURIComponent(String(fittingId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-fittings.write_fittings.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return fittings of a character  --- Alternate route: `/dev/characters/{character_id}/fittings/`  Alternate route: `/v2/characters/{character_id}/fittings/`  --- This route is cached for up to 300 seconds
         * @summary Get fittings
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdFittings(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdFittings.');
            }
            const localVarPath = `/characters/{character_id}/fittings/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-fittings.read_fittings.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save a new fitting for a character  --- Alternate route: `/dev/characters/{character_id}/fittings/`  Alternate route: `/v2/characters/{character_id}/fittings/` 
         * @summary Create fitting
         * @param {number} characterId An EVE character ID
         * @param {PostCharactersCharacterIdFittingsFitting} fitting Details about the new fitting
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdFittings(characterId: number, fitting: PostCharactersCharacterIdFittingsFitting, datasource?: 'tranquility', token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling postCharactersCharacterIdFittings.');
            }
            // verify required parameter 'fitting' is not null or undefined
            if (fitting === null || fitting === undefined) {
                throw new RequiredError('fitting','Required parameter fitting was null or undefined when calling postCharactersCharacterIdFittings.');
            }
            const localVarPath = `/characters/{character_id}/fittings/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-fittings.write_fittings.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PostCharactersCharacterIdFittingsFitting" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(fitting || {}) : (fitting || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FittingsApi - functional programming interface
 * @export
 */
export const FittingsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a fitting from a character  --- Alternate route: `/dev/characters/{character_id}/fittings/{fitting_id}/`  Alternate route: `/legacy/characters/{character_id}/fittings/{fitting_id}/`  Alternate route: `/v1/characters/{character_id}/fittings/{fitting_id}/` 
         * @summary Delete fitting
         * @param {number} characterId An EVE character ID
         * @param {number} fittingId ID for a fitting of this character
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharactersCharacterIdFittingsFittingId(characterId: number, fittingId: number, datasource?: 'tranquility', token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FittingsApiFetchParamCreator(configuration).deleteCharactersCharacterIdFittingsFittingId(characterId, fittingId, datasource, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return fittings of a character  --- Alternate route: `/dev/characters/{character_id}/fittings/`  Alternate route: `/v2/characters/{character_id}/fittings/`  --- This route is cached for up to 300 seconds
         * @summary Get fittings
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdFittings(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCharactersCharacterIdFittings200Ok>> {
            const localVarFetchArgs = FittingsApiFetchParamCreator(configuration).getCharactersCharacterIdFittings(characterId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Save a new fitting for a character  --- Alternate route: `/dev/characters/{character_id}/fittings/`  Alternate route: `/v2/characters/{character_id}/fittings/` 
         * @summary Create fitting
         * @param {number} characterId An EVE character ID
         * @param {PostCharactersCharacterIdFittingsFitting} fitting Details about the new fitting
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdFittings(characterId: number, fitting: PostCharactersCharacterIdFittingsFitting, datasource?: 'tranquility', token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PostCharactersCharacterIdFittingsCreated> {
            const localVarFetchArgs = FittingsApiFetchParamCreator(configuration).postCharactersCharacterIdFittings(characterId, fitting, datasource, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FittingsApi - factory interface
 * @export
 */
export const FittingsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete a fitting from a character  --- Alternate route: `/dev/characters/{character_id}/fittings/{fitting_id}/`  Alternate route: `/legacy/characters/{character_id}/fittings/{fitting_id}/`  Alternate route: `/v1/characters/{character_id}/fittings/{fitting_id}/` 
         * @summary Delete fitting
         * @param {number} characterId An EVE character ID
         * @param {number} fittingId ID for a fitting of this character
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharactersCharacterIdFittingsFittingId(characterId: number, fittingId: number, datasource?: 'tranquility', token?: string, options?: any) {
            return FittingsApiFp(configuration).deleteCharactersCharacterIdFittingsFittingId(characterId, fittingId, datasource, token, options)(fetch, basePath);
        },
        /**
         * Return fittings of a character  --- Alternate route: `/dev/characters/{character_id}/fittings/`  Alternate route: `/v2/characters/{character_id}/fittings/`  --- This route is cached for up to 300 seconds
         * @summary Get fittings
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdFittings(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return FittingsApiFp(configuration).getCharactersCharacterIdFittings(characterId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Save a new fitting for a character  --- Alternate route: `/dev/characters/{character_id}/fittings/`  Alternate route: `/v2/characters/{character_id}/fittings/` 
         * @summary Create fitting
         * @param {number} characterId An EVE character ID
         * @param {PostCharactersCharacterIdFittingsFitting} fitting Details about the new fitting
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdFittings(characterId: number, fitting: PostCharactersCharacterIdFittingsFitting, datasource?: 'tranquility', token?: string, options?: any) {
            return FittingsApiFp(configuration).postCharactersCharacterIdFittings(characterId, fitting, datasource, token, options)(fetch, basePath);
        },
    };
};

/**
 * FittingsApi - object-oriented interface
 * @export
 * @class FittingsApi
 * @extends {BaseAPI}
 */
export class FittingsApi extends BaseAPI {
    /**
     * Delete a fitting from a character  --- Alternate route: `/dev/characters/{character_id}/fittings/{fitting_id}/`  Alternate route: `/legacy/characters/{character_id}/fittings/{fitting_id}/`  Alternate route: `/v1/characters/{character_id}/fittings/{fitting_id}/` 
     * @summary Delete fitting
     * @param {number} characterId An EVE character ID
     * @param {number} fittingId ID for a fitting of this character
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FittingsApi
     */
    public deleteCharactersCharacterIdFittingsFittingId(characterId: number, fittingId: number, datasource?: 'tranquility', token?: string, options?: any) {
        return FittingsApiFp(this.configuration).deleteCharactersCharacterIdFittingsFittingId(characterId, fittingId, datasource, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return fittings of a character  --- Alternate route: `/dev/characters/{character_id}/fittings/`  Alternate route: `/v2/characters/{character_id}/fittings/`  --- This route is cached for up to 300 seconds
     * @summary Get fittings
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FittingsApi
     */
    public getCharactersCharacterIdFittings(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return FittingsApiFp(this.configuration).getCharactersCharacterIdFittings(characterId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Save a new fitting for a character  --- Alternate route: `/dev/characters/{character_id}/fittings/`  Alternate route: `/v2/characters/{character_id}/fittings/` 
     * @summary Create fitting
     * @param {number} characterId An EVE character ID
     * @param {PostCharactersCharacterIdFittingsFitting} fitting Details about the new fitting
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FittingsApi
     */
    public postCharactersCharacterIdFittings(characterId: number, fitting: PostCharactersCharacterIdFittingsFitting, datasource?: 'tranquility', token?: string, options?: any) {
        return FittingsApiFp(this.configuration).postCharactersCharacterIdFittings(characterId, fitting, datasource, token, options)(this.fetch, this.basePath);
    }

}

/**
 * FleetsApi - fetch parameter creator
 * @export
 */
export const FleetsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Kick a fleet member  --- Alternate route: `/dev/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/v1/fleets/{fleet_id}/members/{member_id}/` 
         * @summary Kick fleet member
         * @param {number} fleetId ID for a fleet
         * @param {number} memberId The character ID of a member in this fleet
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFleetsFleetIdMembersMemberId(fleetId: number, memberId: number, datasource?: 'tranquility', token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'fleetId' is not null or undefined
            if (fleetId === null || fleetId === undefined) {
                throw new RequiredError('fleetId','Required parameter fleetId was null or undefined when calling deleteFleetsFleetIdMembersMemberId.');
            }
            // verify required parameter 'memberId' is not null or undefined
            if (memberId === null || memberId === undefined) {
                throw new RequiredError('memberId','Required parameter memberId was null or undefined when calling deleteFleetsFleetIdMembersMemberId.');
            }
            const localVarPath = `/fleets/{fleet_id}/members/{member_id}/`
                .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)))
                .replace(`{${"member_id"}}`, encodeURIComponent(String(memberId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-fleets.write_fleet.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a fleet squad, only empty squads can be deleted  --- Alternate route: `/dev/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/v1/fleets/{fleet_id}/squads/{squad_id}/` 
         * @summary Delete fleet squad
         * @param {number} fleetId ID for a fleet
         * @param {number} squadId The squad to delete
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFleetsFleetIdSquadsSquadId(fleetId: number, squadId: number, datasource?: 'tranquility', token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'fleetId' is not null or undefined
            if (fleetId === null || fleetId === undefined) {
                throw new RequiredError('fleetId','Required parameter fleetId was null or undefined when calling deleteFleetsFleetIdSquadsSquadId.');
            }
            // verify required parameter 'squadId' is not null or undefined
            if (squadId === null || squadId === undefined) {
                throw new RequiredError('squadId','Required parameter squadId was null or undefined when calling deleteFleetsFleetIdSquadsSquadId.');
            }
            const localVarPath = `/fleets/{fleet_id}/squads/{squad_id}/`
                .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)))
                .replace(`{${"squad_id"}}`, encodeURIComponent(String(squadId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-fleets.write_fleet.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a fleet wing, only empty wings can be deleted. The wing may contain squads, but the squads must be empty  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/` 
         * @summary Delete fleet wing
         * @param {number} fleetId ID for a fleet
         * @param {number} wingId The wing to delete
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFleetsFleetIdWingsWingId(fleetId: number, wingId: number, datasource?: 'tranquility', token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'fleetId' is not null or undefined
            if (fleetId === null || fleetId === undefined) {
                throw new RequiredError('fleetId','Required parameter fleetId was null or undefined when calling deleteFleetsFleetIdWingsWingId.');
            }
            // verify required parameter 'wingId' is not null or undefined
            if (wingId === null || wingId === undefined) {
                throw new RequiredError('wingId','Required parameter wingId was null or undefined when calling deleteFleetsFleetIdWingsWingId.');
            }
            const localVarPath = `/fleets/{fleet_id}/wings/{wing_id}/`
                .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)))
                .replace(`{${"wing_id"}}`, encodeURIComponent(String(wingId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-fleets.write_fleet.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the fleet ID the character is in, if any.  --- Alternate route: `/legacy/characters/{character_id}/fleet/`  Alternate route: `/v1/characters/{character_id}/fleet/`  --- This route is cached for up to 60 seconds  --- Warning: This route has an upgrade available  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/characters/{character_id}/fleet/)
         * @summary Get character fleet info
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdFleet(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdFleet.');
            }
            const localVarPath = `/characters/{character_id}/fleet/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-fleets.read_fleet.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return details about a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/`  Alternate route: `/v1/fleets/{fleet_id}/`  --- This route is cached for up to 5 seconds
         * @summary Get fleet information
         * @param {number} fleetId ID for a fleet
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFleetsFleetId(fleetId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'fleetId' is not null or undefined
            if (fleetId === null || fleetId === undefined) {
                throw new RequiredError('fleetId','Required parameter fleetId was null or undefined when calling getFleetsFleetId.');
            }
            const localVarPath = `/fleets/{fleet_id}/`
                .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-fleets.read_fleet.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return information about fleet members  --- Alternate route: `/dev/fleets/{fleet_id}/members/`  Alternate route: `/legacy/fleets/{fleet_id}/members/`  Alternate route: `/v1/fleets/{fleet_id}/members/`  --- This route is cached for up to 5 seconds
         * @summary Get fleet members
         * @param {number} fleetId ID for a fleet
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFleetsFleetIdMembers(fleetId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'fleetId' is not null or undefined
            if (fleetId === null || fleetId === undefined) {
                throw new RequiredError('fleetId','Required parameter fleetId was null or undefined when calling getFleetsFleetIdMembers.');
            }
            const localVarPath = `/fleets/{fleet_id}/members/`
                .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-fleets.read_fleet.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return information about wings in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/`  Alternate route: `/v1/fleets/{fleet_id}/wings/`  --- This route is cached for up to 5 seconds
         * @summary Get fleet wings
         * @param {number} fleetId ID for a fleet
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFleetsFleetIdWings(fleetId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'fleetId' is not null or undefined
            if (fleetId === null || fleetId === undefined) {
                throw new RequiredError('fleetId','Required parameter fleetId was null or undefined when calling getFleetsFleetIdWings.');
            }
            const localVarPath = `/fleets/{fleet_id}/wings/`
                .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-fleets.read_fleet.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invite a character into the fleet. If a character has a CSPA charge set it is not possible to invite them to the fleet using ESI  --- Alternate route: `/dev/fleets/{fleet_id}/members/`  Alternate route: `/legacy/fleets/{fleet_id}/members/`  Alternate route: `/v1/fleets/{fleet_id}/members/` 
         * @summary Create fleet invitation
         * @param {number} fleetId ID for a fleet
         * @param {PostFleetsFleetIdMembersInvitation} invitation Details of the invitation
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFleetsFleetIdMembers(fleetId: number, invitation: PostFleetsFleetIdMembersInvitation, datasource?: 'tranquility', token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'fleetId' is not null or undefined
            if (fleetId === null || fleetId === undefined) {
                throw new RequiredError('fleetId','Required parameter fleetId was null or undefined when calling postFleetsFleetIdMembers.');
            }
            // verify required parameter 'invitation' is not null or undefined
            if (invitation === null || invitation === undefined) {
                throw new RequiredError('invitation','Required parameter invitation was null or undefined when calling postFleetsFleetIdMembers.');
            }
            const localVarPath = `/fleets/{fleet_id}/members/`
                .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-fleets.write_fleet.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PostFleetsFleetIdMembersInvitation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(invitation || {}) : (invitation || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new wing in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/`  Alternate route: `/v1/fleets/{fleet_id}/wings/` 
         * @summary Create fleet wing
         * @param {number} fleetId ID for a fleet
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFleetsFleetIdWings(fleetId: number, datasource?: 'tranquility', token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'fleetId' is not null or undefined
            if (fleetId === null || fleetId === undefined) {
                throw new RequiredError('fleetId','Required parameter fleetId was null or undefined when calling postFleetsFleetIdWings.');
            }
            const localVarPath = `/fleets/{fleet_id}/wings/`
                .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-fleets.write_fleet.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new squad in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/squads/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/squads/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/squads/` 
         * @summary Create fleet squad
         * @param {number} fleetId ID for a fleet
         * @param {number} wingId The wing_id to create squad in
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFleetsFleetIdWingsWingIdSquads(fleetId: number, wingId: number, datasource?: 'tranquility', token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'fleetId' is not null or undefined
            if (fleetId === null || fleetId === undefined) {
                throw new RequiredError('fleetId','Required parameter fleetId was null or undefined when calling postFleetsFleetIdWingsWingIdSquads.');
            }
            // verify required parameter 'wingId' is not null or undefined
            if (wingId === null || wingId === undefined) {
                throw new RequiredError('wingId','Required parameter wingId was null or undefined when calling postFleetsFleetIdWingsWingIdSquads.');
            }
            const localVarPath = `/fleets/{fleet_id}/wings/{wing_id}/squads/`
                .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)))
                .replace(`{${"wing_id"}}`, encodeURIComponent(String(wingId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-fleets.write_fleet.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update settings about a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/`  Alternate route: `/v1/fleets/{fleet_id}/` 
         * @summary Update fleet
         * @param {number} fleetId ID for a fleet
         * @param {PutFleetsFleetIdNewSettings} newSettings What to update for this fleet
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFleetsFleetId(fleetId: number, newSettings: PutFleetsFleetIdNewSettings, datasource?: 'tranquility', token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'fleetId' is not null or undefined
            if (fleetId === null || fleetId === undefined) {
                throw new RequiredError('fleetId','Required parameter fleetId was null or undefined when calling putFleetsFleetId.');
            }
            // verify required parameter 'newSettings' is not null or undefined
            if (newSettings === null || newSettings === undefined) {
                throw new RequiredError('newSettings','Required parameter newSettings was null or undefined when calling putFleetsFleetId.');
            }
            const localVarPath = `/fleets/{fleet_id}/`
                .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-fleets.write_fleet.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PutFleetsFleetIdNewSettings" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(newSettings || {}) : (newSettings || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Move a fleet member around  --- Alternate route: `/dev/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/v1/fleets/{fleet_id}/members/{member_id}/` 
         * @summary Move fleet member
         * @param {number} fleetId ID for a fleet
         * @param {number} memberId The character ID of a member in this fleet
         * @param {PutFleetsFleetIdMembersMemberIdMovement} movement Details of the invitation
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFleetsFleetIdMembersMemberId(fleetId: number, memberId: number, movement: PutFleetsFleetIdMembersMemberIdMovement, datasource?: 'tranquility', token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'fleetId' is not null or undefined
            if (fleetId === null || fleetId === undefined) {
                throw new RequiredError('fleetId','Required parameter fleetId was null or undefined when calling putFleetsFleetIdMembersMemberId.');
            }
            // verify required parameter 'memberId' is not null or undefined
            if (memberId === null || memberId === undefined) {
                throw new RequiredError('memberId','Required parameter memberId was null or undefined when calling putFleetsFleetIdMembersMemberId.');
            }
            // verify required parameter 'movement' is not null or undefined
            if (movement === null || movement === undefined) {
                throw new RequiredError('movement','Required parameter movement was null or undefined when calling putFleetsFleetIdMembersMemberId.');
            }
            const localVarPath = `/fleets/{fleet_id}/members/{member_id}/`
                .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)))
                .replace(`{${"member_id"}}`, encodeURIComponent(String(memberId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-fleets.write_fleet.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PutFleetsFleetIdMembersMemberIdMovement" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(movement || {}) : (movement || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rename a fleet squad  --- Alternate route: `/dev/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/v1/fleets/{fleet_id}/squads/{squad_id}/` 
         * @summary Rename fleet squad
         * @param {number} fleetId ID for a fleet
         * @param {PutFleetsFleetIdSquadsSquadIdNaming} naming New name of the squad
         * @param {number} squadId The squad to rename
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFleetsFleetIdSquadsSquadId(fleetId: number, naming: PutFleetsFleetIdSquadsSquadIdNaming, squadId: number, datasource?: 'tranquility', token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'fleetId' is not null or undefined
            if (fleetId === null || fleetId === undefined) {
                throw new RequiredError('fleetId','Required parameter fleetId was null or undefined when calling putFleetsFleetIdSquadsSquadId.');
            }
            // verify required parameter 'naming' is not null or undefined
            if (naming === null || naming === undefined) {
                throw new RequiredError('naming','Required parameter naming was null or undefined when calling putFleetsFleetIdSquadsSquadId.');
            }
            // verify required parameter 'squadId' is not null or undefined
            if (squadId === null || squadId === undefined) {
                throw new RequiredError('squadId','Required parameter squadId was null or undefined when calling putFleetsFleetIdSquadsSquadId.');
            }
            const localVarPath = `/fleets/{fleet_id}/squads/{squad_id}/`
                .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)))
                .replace(`{${"squad_id"}}`, encodeURIComponent(String(squadId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-fleets.write_fleet.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PutFleetsFleetIdSquadsSquadIdNaming" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(naming || {}) : (naming || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rename a fleet wing  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/` 
         * @summary Rename fleet wing
         * @param {number} fleetId ID for a fleet
         * @param {PutFleetsFleetIdWingsWingIdNaming} naming New name of the wing
         * @param {number} wingId The wing to rename
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFleetsFleetIdWingsWingId(fleetId: number, naming: PutFleetsFleetIdWingsWingIdNaming, wingId: number, datasource?: 'tranquility', token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'fleetId' is not null or undefined
            if (fleetId === null || fleetId === undefined) {
                throw new RequiredError('fleetId','Required parameter fleetId was null or undefined when calling putFleetsFleetIdWingsWingId.');
            }
            // verify required parameter 'naming' is not null or undefined
            if (naming === null || naming === undefined) {
                throw new RequiredError('naming','Required parameter naming was null or undefined when calling putFleetsFleetIdWingsWingId.');
            }
            // verify required parameter 'wingId' is not null or undefined
            if (wingId === null || wingId === undefined) {
                throw new RequiredError('wingId','Required parameter wingId was null or undefined when calling putFleetsFleetIdWingsWingId.');
            }
            const localVarPath = `/fleets/{fleet_id}/wings/{wing_id}/`
                .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)))
                .replace(`{${"wing_id"}}`, encodeURIComponent(String(wingId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-fleets.write_fleet.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PutFleetsFleetIdWingsWingIdNaming" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(naming || {}) : (naming || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FleetsApi - functional programming interface
 * @export
 */
export const FleetsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Kick a fleet member  --- Alternate route: `/dev/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/v1/fleets/{fleet_id}/members/{member_id}/` 
         * @summary Kick fleet member
         * @param {number} fleetId ID for a fleet
         * @param {number} memberId The character ID of a member in this fleet
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFleetsFleetIdMembersMemberId(fleetId: number, memberId: number, datasource?: 'tranquility', token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FleetsApiFetchParamCreator(configuration).deleteFleetsFleetIdMembersMemberId(fleetId, memberId, datasource, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a fleet squad, only empty squads can be deleted  --- Alternate route: `/dev/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/v1/fleets/{fleet_id}/squads/{squad_id}/` 
         * @summary Delete fleet squad
         * @param {number} fleetId ID for a fleet
         * @param {number} squadId The squad to delete
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFleetsFleetIdSquadsSquadId(fleetId: number, squadId: number, datasource?: 'tranquility', token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FleetsApiFetchParamCreator(configuration).deleteFleetsFleetIdSquadsSquadId(fleetId, squadId, datasource, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a fleet wing, only empty wings can be deleted. The wing may contain squads, but the squads must be empty  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/` 
         * @summary Delete fleet wing
         * @param {number} fleetId ID for a fleet
         * @param {number} wingId The wing to delete
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFleetsFleetIdWingsWingId(fleetId: number, wingId: number, datasource?: 'tranquility', token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FleetsApiFetchParamCreator(configuration).deleteFleetsFleetIdWingsWingId(fleetId, wingId, datasource, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return the fleet ID the character is in, if any.  --- Alternate route: `/legacy/characters/{character_id}/fleet/`  Alternate route: `/v1/characters/{character_id}/fleet/`  --- This route is cached for up to 60 seconds  --- Warning: This route has an upgrade available  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/characters/{character_id}/fleet/)
         * @summary Get character fleet info
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdFleet(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCharactersCharacterIdFleetOk> {
            const localVarFetchArgs = FleetsApiFetchParamCreator(configuration).getCharactersCharacterIdFleet(characterId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return details about a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/`  Alternate route: `/v1/fleets/{fleet_id}/`  --- This route is cached for up to 5 seconds
         * @summary Get fleet information
         * @param {number} fleetId ID for a fleet
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFleetsFleetId(fleetId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetFleetsFleetIdOk> {
            const localVarFetchArgs = FleetsApiFetchParamCreator(configuration).getFleetsFleetId(fleetId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return information about fleet members  --- Alternate route: `/dev/fleets/{fleet_id}/members/`  Alternate route: `/legacy/fleets/{fleet_id}/members/`  Alternate route: `/v1/fleets/{fleet_id}/members/`  --- This route is cached for up to 5 seconds
         * @summary Get fleet members
         * @param {number} fleetId ID for a fleet
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFleetsFleetIdMembers(fleetId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetFleetsFleetIdMembers200Ok>> {
            const localVarFetchArgs = FleetsApiFetchParamCreator(configuration).getFleetsFleetIdMembers(fleetId, acceptLanguage, datasource, ifNoneMatch, language, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return information about wings in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/`  Alternate route: `/v1/fleets/{fleet_id}/wings/`  --- This route is cached for up to 5 seconds
         * @summary Get fleet wings
         * @param {number} fleetId ID for a fleet
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFleetsFleetIdWings(fleetId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetFleetsFleetIdWings200Ok>> {
            const localVarFetchArgs = FleetsApiFetchParamCreator(configuration).getFleetsFleetIdWings(fleetId, acceptLanguage, datasource, ifNoneMatch, language, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Invite a character into the fleet. If a character has a CSPA charge set it is not possible to invite them to the fleet using ESI  --- Alternate route: `/dev/fleets/{fleet_id}/members/`  Alternate route: `/legacy/fleets/{fleet_id}/members/`  Alternate route: `/v1/fleets/{fleet_id}/members/` 
         * @summary Create fleet invitation
         * @param {number} fleetId ID for a fleet
         * @param {PostFleetsFleetIdMembersInvitation} invitation Details of the invitation
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFleetsFleetIdMembers(fleetId: number, invitation: PostFleetsFleetIdMembersInvitation, datasource?: 'tranquility', token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FleetsApiFetchParamCreator(configuration).postFleetsFleetIdMembers(fleetId, invitation, datasource, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new wing in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/`  Alternate route: `/v1/fleets/{fleet_id}/wings/` 
         * @summary Create fleet wing
         * @param {number} fleetId ID for a fleet
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFleetsFleetIdWings(fleetId: number, datasource?: 'tranquility', token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PostFleetsFleetIdWingsCreated> {
            const localVarFetchArgs = FleetsApiFetchParamCreator(configuration).postFleetsFleetIdWings(fleetId, datasource, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new squad in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/squads/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/squads/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/squads/` 
         * @summary Create fleet squad
         * @param {number} fleetId ID for a fleet
         * @param {number} wingId The wing_id to create squad in
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFleetsFleetIdWingsWingIdSquads(fleetId: number, wingId: number, datasource?: 'tranquility', token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PostFleetsFleetIdWingsWingIdSquadsCreated> {
            const localVarFetchArgs = FleetsApiFetchParamCreator(configuration).postFleetsFleetIdWingsWingIdSquads(fleetId, wingId, datasource, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update settings about a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/`  Alternate route: `/v1/fleets/{fleet_id}/` 
         * @summary Update fleet
         * @param {number} fleetId ID for a fleet
         * @param {PutFleetsFleetIdNewSettings} newSettings What to update for this fleet
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFleetsFleetId(fleetId: number, newSettings: PutFleetsFleetIdNewSettings, datasource?: 'tranquility', token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FleetsApiFetchParamCreator(configuration).putFleetsFleetId(fleetId, newSettings, datasource, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Move a fleet member around  --- Alternate route: `/dev/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/v1/fleets/{fleet_id}/members/{member_id}/` 
         * @summary Move fleet member
         * @param {number} fleetId ID for a fleet
         * @param {number} memberId The character ID of a member in this fleet
         * @param {PutFleetsFleetIdMembersMemberIdMovement} movement Details of the invitation
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFleetsFleetIdMembersMemberId(fleetId: number, memberId: number, movement: PutFleetsFleetIdMembersMemberIdMovement, datasource?: 'tranquility', token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FleetsApiFetchParamCreator(configuration).putFleetsFleetIdMembersMemberId(fleetId, memberId, movement, datasource, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Rename a fleet squad  --- Alternate route: `/dev/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/v1/fleets/{fleet_id}/squads/{squad_id}/` 
         * @summary Rename fleet squad
         * @param {number} fleetId ID for a fleet
         * @param {PutFleetsFleetIdSquadsSquadIdNaming} naming New name of the squad
         * @param {number} squadId The squad to rename
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFleetsFleetIdSquadsSquadId(fleetId: number, naming: PutFleetsFleetIdSquadsSquadIdNaming, squadId: number, datasource?: 'tranquility', token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FleetsApiFetchParamCreator(configuration).putFleetsFleetIdSquadsSquadId(fleetId, naming, squadId, datasource, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Rename a fleet wing  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/` 
         * @summary Rename fleet wing
         * @param {number} fleetId ID for a fleet
         * @param {PutFleetsFleetIdWingsWingIdNaming} naming New name of the wing
         * @param {number} wingId The wing to rename
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFleetsFleetIdWingsWingId(fleetId: number, naming: PutFleetsFleetIdWingsWingIdNaming, wingId: number, datasource?: 'tranquility', token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FleetsApiFetchParamCreator(configuration).putFleetsFleetIdWingsWingId(fleetId, naming, wingId, datasource, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FleetsApi - factory interface
 * @export
 */
export const FleetsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Kick a fleet member  --- Alternate route: `/dev/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/v1/fleets/{fleet_id}/members/{member_id}/` 
         * @summary Kick fleet member
         * @param {number} fleetId ID for a fleet
         * @param {number} memberId The character ID of a member in this fleet
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFleetsFleetIdMembersMemberId(fleetId: number, memberId: number, datasource?: 'tranquility', token?: string, options?: any) {
            return FleetsApiFp(configuration).deleteFleetsFleetIdMembersMemberId(fleetId, memberId, datasource, token, options)(fetch, basePath);
        },
        /**
         * Delete a fleet squad, only empty squads can be deleted  --- Alternate route: `/dev/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/v1/fleets/{fleet_id}/squads/{squad_id}/` 
         * @summary Delete fleet squad
         * @param {number} fleetId ID for a fleet
         * @param {number} squadId The squad to delete
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFleetsFleetIdSquadsSquadId(fleetId: number, squadId: number, datasource?: 'tranquility', token?: string, options?: any) {
            return FleetsApiFp(configuration).deleteFleetsFleetIdSquadsSquadId(fleetId, squadId, datasource, token, options)(fetch, basePath);
        },
        /**
         * Delete a fleet wing, only empty wings can be deleted. The wing may contain squads, but the squads must be empty  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/` 
         * @summary Delete fleet wing
         * @param {number} fleetId ID for a fleet
         * @param {number} wingId The wing to delete
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFleetsFleetIdWingsWingId(fleetId: number, wingId: number, datasource?: 'tranquility', token?: string, options?: any) {
            return FleetsApiFp(configuration).deleteFleetsFleetIdWingsWingId(fleetId, wingId, datasource, token, options)(fetch, basePath);
        },
        /**
         * Return the fleet ID the character is in, if any.  --- Alternate route: `/legacy/characters/{character_id}/fleet/`  Alternate route: `/v1/characters/{character_id}/fleet/`  --- This route is cached for up to 60 seconds  --- Warning: This route has an upgrade available  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/characters/{character_id}/fleet/)
         * @summary Get character fleet info
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdFleet(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return FleetsApiFp(configuration).getCharactersCharacterIdFleet(characterId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Return details about a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/`  Alternate route: `/v1/fleets/{fleet_id}/`  --- This route is cached for up to 5 seconds
         * @summary Get fleet information
         * @param {number} fleetId ID for a fleet
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFleetsFleetId(fleetId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return FleetsApiFp(configuration).getFleetsFleetId(fleetId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Return information about fleet members  --- Alternate route: `/dev/fleets/{fleet_id}/members/`  Alternate route: `/legacy/fleets/{fleet_id}/members/`  Alternate route: `/v1/fleets/{fleet_id}/members/`  --- This route is cached for up to 5 seconds
         * @summary Get fleet members
         * @param {number} fleetId ID for a fleet
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFleetsFleetIdMembers(fleetId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', token?: string, options?: any) {
            return FleetsApiFp(configuration).getFleetsFleetIdMembers(fleetId, acceptLanguage, datasource, ifNoneMatch, language, token, options)(fetch, basePath);
        },
        /**
         * Return information about wings in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/`  Alternate route: `/v1/fleets/{fleet_id}/wings/`  --- This route is cached for up to 5 seconds
         * @summary Get fleet wings
         * @param {number} fleetId ID for a fleet
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFleetsFleetIdWings(fleetId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', token?: string, options?: any) {
            return FleetsApiFp(configuration).getFleetsFleetIdWings(fleetId, acceptLanguage, datasource, ifNoneMatch, language, token, options)(fetch, basePath);
        },
        /**
         * Invite a character into the fleet. If a character has a CSPA charge set it is not possible to invite them to the fleet using ESI  --- Alternate route: `/dev/fleets/{fleet_id}/members/`  Alternate route: `/legacy/fleets/{fleet_id}/members/`  Alternate route: `/v1/fleets/{fleet_id}/members/` 
         * @summary Create fleet invitation
         * @param {number} fleetId ID for a fleet
         * @param {PostFleetsFleetIdMembersInvitation} invitation Details of the invitation
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFleetsFleetIdMembers(fleetId: number, invitation: PostFleetsFleetIdMembersInvitation, datasource?: 'tranquility', token?: string, options?: any) {
            return FleetsApiFp(configuration).postFleetsFleetIdMembers(fleetId, invitation, datasource, token, options)(fetch, basePath);
        },
        /**
         * Create a new wing in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/`  Alternate route: `/v1/fleets/{fleet_id}/wings/` 
         * @summary Create fleet wing
         * @param {number} fleetId ID for a fleet
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFleetsFleetIdWings(fleetId: number, datasource?: 'tranquility', token?: string, options?: any) {
            return FleetsApiFp(configuration).postFleetsFleetIdWings(fleetId, datasource, token, options)(fetch, basePath);
        },
        /**
         * Create a new squad in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/squads/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/squads/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/squads/` 
         * @summary Create fleet squad
         * @param {number} fleetId ID for a fleet
         * @param {number} wingId The wing_id to create squad in
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFleetsFleetIdWingsWingIdSquads(fleetId: number, wingId: number, datasource?: 'tranquility', token?: string, options?: any) {
            return FleetsApiFp(configuration).postFleetsFleetIdWingsWingIdSquads(fleetId, wingId, datasource, token, options)(fetch, basePath);
        },
        /**
         * Update settings about a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/`  Alternate route: `/v1/fleets/{fleet_id}/` 
         * @summary Update fleet
         * @param {number} fleetId ID for a fleet
         * @param {PutFleetsFleetIdNewSettings} newSettings What to update for this fleet
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFleetsFleetId(fleetId: number, newSettings: PutFleetsFleetIdNewSettings, datasource?: 'tranquility', token?: string, options?: any) {
            return FleetsApiFp(configuration).putFleetsFleetId(fleetId, newSettings, datasource, token, options)(fetch, basePath);
        },
        /**
         * Move a fleet member around  --- Alternate route: `/dev/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/v1/fleets/{fleet_id}/members/{member_id}/` 
         * @summary Move fleet member
         * @param {number} fleetId ID for a fleet
         * @param {number} memberId The character ID of a member in this fleet
         * @param {PutFleetsFleetIdMembersMemberIdMovement} movement Details of the invitation
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFleetsFleetIdMembersMemberId(fleetId: number, memberId: number, movement: PutFleetsFleetIdMembersMemberIdMovement, datasource?: 'tranquility', token?: string, options?: any) {
            return FleetsApiFp(configuration).putFleetsFleetIdMembersMemberId(fleetId, memberId, movement, datasource, token, options)(fetch, basePath);
        },
        /**
         * Rename a fleet squad  --- Alternate route: `/dev/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/v1/fleets/{fleet_id}/squads/{squad_id}/` 
         * @summary Rename fleet squad
         * @param {number} fleetId ID for a fleet
         * @param {PutFleetsFleetIdSquadsSquadIdNaming} naming New name of the squad
         * @param {number} squadId The squad to rename
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFleetsFleetIdSquadsSquadId(fleetId: number, naming: PutFleetsFleetIdSquadsSquadIdNaming, squadId: number, datasource?: 'tranquility', token?: string, options?: any) {
            return FleetsApiFp(configuration).putFleetsFleetIdSquadsSquadId(fleetId, naming, squadId, datasource, token, options)(fetch, basePath);
        },
        /**
         * Rename a fleet wing  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/` 
         * @summary Rename fleet wing
         * @param {number} fleetId ID for a fleet
         * @param {PutFleetsFleetIdWingsWingIdNaming} naming New name of the wing
         * @param {number} wingId The wing to rename
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFleetsFleetIdWingsWingId(fleetId: number, naming: PutFleetsFleetIdWingsWingIdNaming, wingId: number, datasource?: 'tranquility', token?: string, options?: any) {
            return FleetsApiFp(configuration).putFleetsFleetIdWingsWingId(fleetId, naming, wingId, datasource, token, options)(fetch, basePath);
        },
    };
};

/**
 * FleetsApi - object-oriented interface
 * @export
 * @class FleetsApi
 * @extends {BaseAPI}
 */
export class FleetsApi extends BaseAPI {
    /**
     * Kick a fleet member  --- Alternate route: `/dev/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/v1/fleets/{fleet_id}/members/{member_id}/` 
     * @summary Kick fleet member
     * @param {number} fleetId ID for a fleet
     * @param {number} memberId The character ID of a member in this fleet
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetsApi
     */
    public deleteFleetsFleetIdMembersMemberId(fleetId: number, memberId: number, datasource?: 'tranquility', token?: string, options?: any) {
        return FleetsApiFp(this.configuration).deleteFleetsFleetIdMembersMemberId(fleetId, memberId, datasource, token, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a fleet squad, only empty squads can be deleted  --- Alternate route: `/dev/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/v1/fleets/{fleet_id}/squads/{squad_id}/` 
     * @summary Delete fleet squad
     * @param {number} fleetId ID for a fleet
     * @param {number} squadId The squad to delete
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetsApi
     */
    public deleteFleetsFleetIdSquadsSquadId(fleetId: number, squadId: number, datasource?: 'tranquility', token?: string, options?: any) {
        return FleetsApiFp(this.configuration).deleteFleetsFleetIdSquadsSquadId(fleetId, squadId, datasource, token, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a fleet wing, only empty wings can be deleted. The wing may contain squads, but the squads must be empty  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/` 
     * @summary Delete fleet wing
     * @param {number} fleetId ID for a fleet
     * @param {number} wingId The wing to delete
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetsApi
     */
    public deleteFleetsFleetIdWingsWingId(fleetId: number, wingId: number, datasource?: 'tranquility', token?: string, options?: any) {
        return FleetsApiFp(this.configuration).deleteFleetsFleetIdWingsWingId(fleetId, wingId, datasource, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return the fleet ID the character is in, if any.  --- Alternate route: `/legacy/characters/{character_id}/fleet/`  Alternate route: `/v1/characters/{character_id}/fleet/`  --- This route is cached for up to 60 seconds  --- Warning: This route has an upgrade available  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/characters/{character_id}/fleet/)
     * @summary Get character fleet info
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetsApi
     */
    public getCharactersCharacterIdFleet(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return FleetsApiFp(this.configuration).getCharactersCharacterIdFleet(characterId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return details about a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/`  Alternate route: `/v1/fleets/{fleet_id}/`  --- This route is cached for up to 5 seconds
     * @summary Get fleet information
     * @param {number} fleetId ID for a fleet
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetsApi
     */
    public getFleetsFleetId(fleetId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return FleetsApiFp(this.configuration).getFleetsFleetId(fleetId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return information about fleet members  --- Alternate route: `/dev/fleets/{fleet_id}/members/`  Alternate route: `/legacy/fleets/{fleet_id}/members/`  Alternate route: `/v1/fleets/{fleet_id}/members/`  --- This route is cached for up to 5 seconds
     * @summary Get fleet members
     * @param {number} fleetId ID for a fleet
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetsApi
     */
    public getFleetsFleetIdMembers(fleetId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', token?: string, options?: any) {
        return FleetsApiFp(this.configuration).getFleetsFleetIdMembers(fleetId, acceptLanguage, datasource, ifNoneMatch, language, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return information about wings in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/`  Alternate route: `/v1/fleets/{fleet_id}/wings/`  --- This route is cached for up to 5 seconds
     * @summary Get fleet wings
     * @param {number} fleetId ID for a fleet
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetsApi
     */
    public getFleetsFleetIdWings(fleetId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', token?: string, options?: any) {
        return FleetsApiFp(this.configuration).getFleetsFleetIdWings(fleetId, acceptLanguage, datasource, ifNoneMatch, language, token, options)(this.fetch, this.basePath);
    }

    /**
     * Invite a character into the fleet. If a character has a CSPA charge set it is not possible to invite them to the fleet using ESI  --- Alternate route: `/dev/fleets/{fleet_id}/members/`  Alternate route: `/legacy/fleets/{fleet_id}/members/`  Alternate route: `/v1/fleets/{fleet_id}/members/` 
     * @summary Create fleet invitation
     * @param {number} fleetId ID for a fleet
     * @param {PostFleetsFleetIdMembersInvitation} invitation Details of the invitation
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetsApi
     */
    public postFleetsFleetIdMembers(fleetId: number, invitation: PostFleetsFleetIdMembersInvitation, datasource?: 'tranquility', token?: string, options?: any) {
        return FleetsApiFp(this.configuration).postFleetsFleetIdMembers(fleetId, invitation, datasource, token, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new wing in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/`  Alternate route: `/v1/fleets/{fleet_id}/wings/` 
     * @summary Create fleet wing
     * @param {number} fleetId ID for a fleet
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetsApi
     */
    public postFleetsFleetIdWings(fleetId: number, datasource?: 'tranquility', token?: string, options?: any) {
        return FleetsApiFp(this.configuration).postFleetsFleetIdWings(fleetId, datasource, token, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new squad in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/squads/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/squads/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/squads/` 
     * @summary Create fleet squad
     * @param {number} fleetId ID for a fleet
     * @param {number} wingId The wing_id to create squad in
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetsApi
     */
    public postFleetsFleetIdWingsWingIdSquads(fleetId: number, wingId: number, datasource?: 'tranquility', token?: string, options?: any) {
        return FleetsApiFp(this.configuration).postFleetsFleetIdWingsWingIdSquads(fleetId, wingId, datasource, token, options)(this.fetch, this.basePath);
    }

    /**
     * Update settings about a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/`  Alternate route: `/v1/fleets/{fleet_id}/` 
     * @summary Update fleet
     * @param {number} fleetId ID for a fleet
     * @param {PutFleetsFleetIdNewSettings} newSettings What to update for this fleet
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetsApi
     */
    public putFleetsFleetId(fleetId: number, newSettings: PutFleetsFleetIdNewSettings, datasource?: 'tranquility', token?: string, options?: any) {
        return FleetsApiFp(this.configuration).putFleetsFleetId(fleetId, newSettings, datasource, token, options)(this.fetch, this.basePath);
    }

    /**
     * Move a fleet member around  --- Alternate route: `/dev/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/v1/fleets/{fleet_id}/members/{member_id}/` 
     * @summary Move fleet member
     * @param {number} fleetId ID for a fleet
     * @param {number} memberId The character ID of a member in this fleet
     * @param {PutFleetsFleetIdMembersMemberIdMovement} movement Details of the invitation
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetsApi
     */
    public putFleetsFleetIdMembersMemberId(fleetId: number, memberId: number, movement: PutFleetsFleetIdMembersMemberIdMovement, datasource?: 'tranquility', token?: string, options?: any) {
        return FleetsApiFp(this.configuration).putFleetsFleetIdMembersMemberId(fleetId, memberId, movement, datasource, token, options)(this.fetch, this.basePath);
    }

    /**
     * Rename a fleet squad  --- Alternate route: `/dev/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/v1/fleets/{fleet_id}/squads/{squad_id}/` 
     * @summary Rename fleet squad
     * @param {number} fleetId ID for a fleet
     * @param {PutFleetsFleetIdSquadsSquadIdNaming} naming New name of the squad
     * @param {number} squadId The squad to rename
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetsApi
     */
    public putFleetsFleetIdSquadsSquadId(fleetId: number, naming: PutFleetsFleetIdSquadsSquadIdNaming, squadId: number, datasource?: 'tranquility', token?: string, options?: any) {
        return FleetsApiFp(this.configuration).putFleetsFleetIdSquadsSquadId(fleetId, naming, squadId, datasource, token, options)(this.fetch, this.basePath);
    }

    /**
     * Rename a fleet wing  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/` 
     * @summary Rename fleet wing
     * @param {number} fleetId ID for a fleet
     * @param {PutFleetsFleetIdWingsWingIdNaming} naming New name of the wing
     * @param {number} wingId The wing to rename
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FleetsApi
     */
    public putFleetsFleetIdWingsWingId(fleetId: number, naming: PutFleetsFleetIdWingsWingIdNaming, wingId: number, datasource?: 'tranquility', token?: string, options?: any) {
        return FleetsApiFp(this.configuration).putFleetsFleetIdWingsWingId(fleetId, naming, wingId, datasource, token, options)(this.fetch, this.basePath);
    }

}

/**
 * IncursionsApi - fetch parameter creator
 * @export
 */
export const IncursionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return a list of current incursions  --- Alternate route: `/dev/incursions/`  Alternate route: `/legacy/incursions/`  Alternate route: `/v1/incursions/`  --- This route is cached for up to 300 seconds
         * @summary List incursions
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncursions(datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            const localVarPath = `/incursions/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IncursionsApi - functional programming interface
 * @export
 */
export const IncursionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Return a list of current incursions  --- Alternate route: `/dev/incursions/`  Alternate route: `/legacy/incursions/`  Alternate route: `/v1/incursions/`  --- This route is cached for up to 300 seconds
         * @summary List incursions
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncursions(datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetIncursions200Ok>> {
            const localVarFetchArgs = IncursionsApiFetchParamCreator(configuration).getIncursions(datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * IncursionsApi - factory interface
 * @export
 */
export const IncursionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Return a list of current incursions  --- Alternate route: `/dev/incursions/`  Alternate route: `/legacy/incursions/`  Alternate route: `/v1/incursions/`  --- This route is cached for up to 300 seconds
         * @summary List incursions
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncursions(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return IncursionsApiFp(configuration).getIncursions(datasource, ifNoneMatch, options)(fetch, basePath);
        },
    };
};

/**
 * IncursionsApi - object-oriented interface
 * @export
 * @class IncursionsApi
 * @extends {BaseAPI}
 */
export class IncursionsApi extends BaseAPI {
    /**
     * Return a list of current incursions  --- Alternate route: `/dev/incursions/`  Alternate route: `/legacy/incursions/`  Alternate route: `/v1/incursions/`  --- This route is cached for up to 300 seconds
     * @summary List incursions
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncursionsApi
     */
    public getIncursions(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return IncursionsApiFp(this.configuration).getIncursions(datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

}

/**
 * IndustryApi - fetch parameter creator
 * @export
 */
export const IndustryApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List industry jobs placed by a character  --- Alternate route: `/dev/characters/{character_id}/industry/jobs/`  Alternate route: `/legacy/characters/{character_id}/industry/jobs/`  Alternate route: `/v1/characters/{character_id}/industry/jobs/`  --- This route is cached for up to 300 seconds
         * @summary List character industry jobs
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {boolean} [includeCompleted] Whether to retrieve completed character industry jobs. Only includes jobs from the past 90 days
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdIndustryJobs(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, includeCompleted?: boolean, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdIndustryJobs.');
            }
            const localVarPath = `/characters/{character_id}/industry/jobs/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-industry.read_character_jobs.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (includeCompleted !== undefined) {
                localVarQueryParameter['include_completed'] = includeCompleted;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Paginated record of all mining done by a character for the past 30 days   --- Alternate route: `/dev/characters/{character_id}/mining/`  Alternate route: `/legacy/characters/{character_id}/mining/`  Alternate route: `/v1/characters/{character_id}/mining/`  --- This route is cached for up to 600 seconds
         * @summary Character mining ledger
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdMining(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdMining.');
            }
            const localVarPath = `/characters/{character_id}/mining/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-industry.read_character_mining.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Extraction timers for all moon chunks being extracted by refineries belonging to a corporation.   --- Alternate route: `/dev/corporation/{corporation_id}/mining/extractions/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/extractions/`  Alternate route: `/v1/corporation/{corporation_id}/mining/extractions/`  --- This route is cached for up to 1800 seconds  --- Requires one of the following EVE corporation role(s): Station_Manager 
         * @summary Moon extraction timers
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationCorporationIdMiningExtractions(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationCorporationIdMiningExtractions.');
            }
            const localVarPath = `/corporation/{corporation_id}/mining/extractions/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-industry.read_corporation_mining.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Paginated list of all entities capable of observing and recording mining for a corporation   --- Alternate route: `/dev/corporation/{corporation_id}/mining/observers/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/observers/`  Alternate route: `/v1/corporation/{corporation_id}/mining/observers/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant 
         * @summary Corporation mining observers
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationCorporationIdMiningObservers(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationCorporationIdMiningObservers.');
            }
            const localVarPath = `/corporation/{corporation_id}/mining/observers/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-industry.read_corporation_mining.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Paginated record of all mining seen by an observer   --- Alternate route: `/dev/corporation/{corporation_id}/mining/observers/{observer_id}/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/observers/{observer_id}/`  Alternate route: `/v1/corporation/{corporation_id}/mining/observers/{observer_id}/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant 
         * @summary Observed corporation mining
         * @param {number} corporationId An EVE corporation ID
         * @param {number} observerId A mining observer id
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationCorporationIdMiningObserversObserverId(corporationId: number, observerId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationCorporationIdMiningObserversObserverId.');
            }
            // verify required parameter 'observerId' is not null or undefined
            if (observerId === null || observerId === undefined) {
                throw new RequiredError('observerId','Required parameter observerId was null or undefined when calling getCorporationCorporationIdMiningObserversObserverId.');
            }
            const localVarPath = `/corporation/{corporation_id}/mining/observers/{observer_id}/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)))
                .replace(`{${"observer_id"}}`, encodeURIComponent(String(observerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-industry.read_corporation_mining.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List industry jobs run by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/industry/jobs/`  Alternate route: `/legacy/corporations/{corporation_id}/industry/jobs/`  Alternate route: `/v1/corporations/{corporation_id}/industry/jobs/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Factory_Manager 
         * @summary List corporation industry jobs
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {boolean} [includeCompleted] Whether to retrieve completed corporation industry jobs. Only includes jobs from the past 90 days
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdIndustryJobs(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, includeCompleted?: boolean, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdIndustryJobs.');
            }
            const localVarPath = `/corporations/{corporation_id}/industry/jobs/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-industry.read_corporation_jobs.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (includeCompleted !== undefined) {
                localVarQueryParameter['include_completed'] = includeCompleted;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of industry facilities  --- Alternate route: `/dev/industry/facilities/`  Alternate route: `/legacy/industry/facilities/`  Alternate route: `/v1/industry/facilities/`  --- This route is cached for up to 3600 seconds
         * @summary List industry facilities
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndustryFacilities(datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            const localVarPath = `/industry/facilities/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return cost indices for solar systems  --- Alternate route: `/dev/industry/systems/`  Alternate route: `/legacy/industry/systems/`  Alternate route: `/v1/industry/systems/`  --- This route is cached for up to 3600 seconds
         * @summary List solar system cost indices
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndustrySystems(datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            const localVarPath = `/industry/systems/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IndustryApi - functional programming interface
 * @export
 */
export const IndustryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List industry jobs placed by a character  --- Alternate route: `/dev/characters/{character_id}/industry/jobs/`  Alternate route: `/legacy/characters/{character_id}/industry/jobs/`  Alternate route: `/v1/characters/{character_id}/industry/jobs/`  --- This route is cached for up to 300 seconds
         * @summary List character industry jobs
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {boolean} [includeCompleted] Whether to retrieve completed character industry jobs. Only includes jobs from the past 90 days
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdIndustryJobs(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, includeCompleted?: boolean, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCharactersCharacterIdIndustryJobs200Ok>> {
            const localVarFetchArgs = IndustryApiFetchParamCreator(configuration).getCharactersCharacterIdIndustryJobs(characterId, datasource, ifNoneMatch, includeCompleted, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Paginated record of all mining done by a character for the past 30 days   --- Alternate route: `/dev/characters/{character_id}/mining/`  Alternate route: `/legacy/characters/{character_id}/mining/`  Alternate route: `/v1/characters/{character_id}/mining/`  --- This route is cached for up to 600 seconds
         * @summary Character mining ledger
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdMining(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCharactersCharacterIdMining200Ok>> {
            const localVarFetchArgs = IndustryApiFetchParamCreator(configuration).getCharactersCharacterIdMining(characterId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Extraction timers for all moon chunks being extracted by refineries belonging to a corporation.   --- Alternate route: `/dev/corporation/{corporation_id}/mining/extractions/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/extractions/`  Alternate route: `/v1/corporation/{corporation_id}/mining/extractions/`  --- This route is cached for up to 1800 seconds  --- Requires one of the following EVE corporation role(s): Station_Manager 
         * @summary Moon extraction timers
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationCorporationIdMiningExtractions(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationCorporationIdMiningExtractions200Ok>> {
            const localVarFetchArgs = IndustryApiFetchParamCreator(configuration).getCorporationCorporationIdMiningExtractions(corporationId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Paginated list of all entities capable of observing and recording mining for a corporation   --- Alternate route: `/dev/corporation/{corporation_id}/mining/observers/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/observers/`  Alternate route: `/v1/corporation/{corporation_id}/mining/observers/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant 
         * @summary Corporation mining observers
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationCorporationIdMiningObservers(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationCorporationIdMiningObservers200Ok>> {
            const localVarFetchArgs = IndustryApiFetchParamCreator(configuration).getCorporationCorporationIdMiningObservers(corporationId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Paginated record of all mining seen by an observer   --- Alternate route: `/dev/corporation/{corporation_id}/mining/observers/{observer_id}/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/observers/{observer_id}/`  Alternate route: `/v1/corporation/{corporation_id}/mining/observers/{observer_id}/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant 
         * @summary Observed corporation mining
         * @param {number} corporationId An EVE corporation ID
         * @param {number} observerId A mining observer id
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationCorporationIdMiningObserversObserverId(corporationId: number, observerId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationCorporationIdMiningObserversObserverId200Ok>> {
            const localVarFetchArgs = IndustryApiFetchParamCreator(configuration).getCorporationCorporationIdMiningObserversObserverId(corporationId, observerId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List industry jobs run by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/industry/jobs/`  Alternate route: `/legacy/corporations/{corporation_id}/industry/jobs/`  Alternate route: `/v1/corporations/{corporation_id}/industry/jobs/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Factory_Manager 
         * @summary List corporation industry jobs
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {boolean} [includeCompleted] Whether to retrieve completed corporation industry jobs. Only includes jobs from the past 90 days
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdIndustryJobs(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, includeCompleted?: boolean, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationsCorporationIdIndustryJobs200Ok>> {
            const localVarFetchArgs = IndustryApiFetchParamCreator(configuration).getCorporationsCorporationIdIndustryJobs(corporationId, datasource, ifNoneMatch, includeCompleted, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a list of industry facilities  --- Alternate route: `/dev/industry/facilities/`  Alternate route: `/legacy/industry/facilities/`  Alternate route: `/v1/industry/facilities/`  --- This route is cached for up to 3600 seconds
         * @summary List industry facilities
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndustryFacilities(datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetIndustryFacilities200Ok>> {
            const localVarFetchArgs = IndustryApiFetchParamCreator(configuration).getIndustryFacilities(datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return cost indices for solar systems  --- Alternate route: `/dev/industry/systems/`  Alternate route: `/legacy/industry/systems/`  Alternate route: `/v1/industry/systems/`  --- This route is cached for up to 3600 seconds
         * @summary List solar system cost indices
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndustrySystems(datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetIndustrySystems200Ok>> {
            const localVarFetchArgs = IndustryApiFetchParamCreator(configuration).getIndustrySystems(datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * IndustryApi - factory interface
 * @export
 */
export const IndustryApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * List industry jobs placed by a character  --- Alternate route: `/dev/characters/{character_id}/industry/jobs/`  Alternate route: `/legacy/characters/{character_id}/industry/jobs/`  Alternate route: `/v1/characters/{character_id}/industry/jobs/`  --- This route is cached for up to 300 seconds
         * @summary List character industry jobs
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {boolean} [includeCompleted] Whether to retrieve completed character industry jobs. Only includes jobs from the past 90 days
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdIndustryJobs(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, includeCompleted?: boolean, token?: string, options?: any) {
            return IndustryApiFp(configuration).getCharactersCharacterIdIndustryJobs(characterId, datasource, ifNoneMatch, includeCompleted, token, options)(fetch, basePath);
        },
        /**
         * Paginated record of all mining done by a character for the past 30 days   --- Alternate route: `/dev/characters/{character_id}/mining/`  Alternate route: `/legacy/characters/{character_id}/mining/`  Alternate route: `/v1/characters/{character_id}/mining/`  --- This route is cached for up to 600 seconds
         * @summary Character mining ledger
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdMining(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return IndustryApiFp(configuration).getCharactersCharacterIdMining(characterId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
        /**
         * Extraction timers for all moon chunks being extracted by refineries belonging to a corporation.   --- Alternate route: `/dev/corporation/{corporation_id}/mining/extractions/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/extractions/`  Alternate route: `/v1/corporation/{corporation_id}/mining/extractions/`  --- This route is cached for up to 1800 seconds  --- Requires one of the following EVE corporation role(s): Station_Manager 
         * @summary Moon extraction timers
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationCorporationIdMiningExtractions(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return IndustryApiFp(configuration).getCorporationCorporationIdMiningExtractions(corporationId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
        /**
         * Paginated list of all entities capable of observing and recording mining for a corporation   --- Alternate route: `/dev/corporation/{corporation_id}/mining/observers/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/observers/`  Alternate route: `/v1/corporation/{corporation_id}/mining/observers/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant 
         * @summary Corporation mining observers
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationCorporationIdMiningObservers(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return IndustryApiFp(configuration).getCorporationCorporationIdMiningObservers(corporationId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
        /**
         * Paginated record of all mining seen by an observer   --- Alternate route: `/dev/corporation/{corporation_id}/mining/observers/{observer_id}/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/observers/{observer_id}/`  Alternate route: `/v1/corporation/{corporation_id}/mining/observers/{observer_id}/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant 
         * @summary Observed corporation mining
         * @param {number} corporationId An EVE corporation ID
         * @param {number} observerId A mining observer id
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationCorporationIdMiningObserversObserverId(corporationId: number, observerId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return IndustryApiFp(configuration).getCorporationCorporationIdMiningObserversObserverId(corporationId, observerId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
        /**
         * List industry jobs run by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/industry/jobs/`  Alternate route: `/legacy/corporations/{corporation_id}/industry/jobs/`  Alternate route: `/v1/corporations/{corporation_id}/industry/jobs/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Factory_Manager 
         * @summary List corporation industry jobs
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {boolean} [includeCompleted] Whether to retrieve completed corporation industry jobs. Only includes jobs from the past 90 days
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdIndustryJobs(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, includeCompleted?: boolean, page?: number, token?: string, options?: any) {
            return IndustryApiFp(configuration).getCorporationsCorporationIdIndustryJobs(corporationId, datasource, ifNoneMatch, includeCompleted, page, token, options)(fetch, basePath);
        },
        /**
         * Return a list of industry facilities  --- Alternate route: `/dev/industry/facilities/`  Alternate route: `/legacy/industry/facilities/`  Alternate route: `/v1/industry/facilities/`  --- This route is cached for up to 3600 seconds
         * @summary List industry facilities
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndustryFacilities(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return IndustryApiFp(configuration).getIndustryFacilities(datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Return cost indices for solar systems  --- Alternate route: `/dev/industry/systems/`  Alternate route: `/legacy/industry/systems/`  Alternate route: `/v1/industry/systems/`  --- This route is cached for up to 3600 seconds
         * @summary List solar system cost indices
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndustrySystems(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return IndustryApiFp(configuration).getIndustrySystems(datasource, ifNoneMatch, options)(fetch, basePath);
        },
    };
};

/**
 * IndustryApi - object-oriented interface
 * @export
 * @class IndustryApi
 * @extends {BaseAPI}
 */
export class IndustryApi extends BaseAPI {
    /**
     * List industry jobs placed by a character  --- Alternate route: `/dev/characters/{character_id}/industry/jobs/`  Alternate route: `/legacy/characters/{character_id}/industry/jobs/`  Alternate route: `/v1/characters/{character_id}/industry/jobs/`  --- This route is cached for up to 300 seconds
     * @summary List character industry jobs
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {boolean} [includeCompleted] Whether to retrieve completed character industry jobs. Only includes jobs from the past 90 days
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndustryApi
     */
    public getCharactersCharacterIdIndustryJobs(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, includeCompleted?: boolean, token?: string, options?: any) {
        return IndustryApiFp(this.configuration).getCharactersCharacterIdIndustryJobs(characterId, datasource, ifNoneMatch, includeCompleted, token, options)(this.fetch, this.basePath);
    }

    /**
     * Paginated record of all mining done by a character for the past 30 days   --- Alternate route: `/dev/characters/{character_id}/mining/`  Alternate route: `/legacy/characters/{character_id}/mining/`  Alternate route: `/v1/characters/{character_id}/mining/`  --- This route is cached for up to 600 seconds
     * @summary Character mining ledger
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndustryApi
     */
    public getCharactersCharacterIdMining(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return IndustryApiFp(this.configuration).getCharactersCharacterIdMining(characterId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * Extraction timers for all moon chunks being extracted by refineries belonging to a corporation.   --- Alternate route: `/dev/corporation/{corporation_id}/mining/extractions/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/extractions/`  Alternate route: `/v1/corporation/{corporation_id}/mining/extractions/`  --- This route is cached for up to 1800 seconds  --- Requires one of the following EVE corporation role(s): Station_Manager 
     * @summary Moon extraction timers
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndustryApi
     */
    public getCorporationCorporationIdMiningExtractions(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return IndustryApiFp(this.configuration).getCorporationCorporationIdMiningExtractions(corporationId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * Paginated list of all entities capable of observing and recording mining for a corporation   --- Alternate route: `/dev/corporation/{corporation_id}/mining/observers/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/observers/`  Alternate route: `/v1/corporation/{corporation_id}/mining/observers/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant 
     * @summary Corporation mining observers
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndustryApi
     */
    public getCorporationCorporationIdMiningObservers(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return IndustryApiFp(this.configuration).getCorporationCorporationIdMiningObservers(corporationId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * Paginated record of all mining seen by an observer   --- Alternate route: `/dev/corporation/{corporation_id}/mining/observers/{observer_id}/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/observers/{observer_id}/`  Alternate route: `/v1/corporation/{corporation_id}/mining/observers/{observer_id}/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant 
     * @summary Observed corporation mining
     * @param {number} corporationId An EVE corporation ID
     * @param {number} observerId A mining observer id
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndustryApi
     */
    public getCorporationCorporationIdMiningObserversObserverId(corporationId: number, observerId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return IndustryApiFp(this.configuration).getCorporationCorporationIdMiningObserversObserverId(corporationId, observerId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * List industry jobs run by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/industry/jobs/`  Alternate route: `/legacy/corporations/{corporation_id}/industry/jobs/`  Alternate route: `/v1/corporations/{corporation_id}/industry/jobs/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Factory_Manager 
     * @summary List corporation industry jobs
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {boolean} [includeCompleted] Whether to retrieve completed corporation industry jobs. Only includes jobs from the past 90 days
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndustryApi
     */
    public getCorporationsCorporationIdIndustryJobs(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, includeCompleted?: boolean, page?: number, token?: string, options?: any) {
        return IndustryApiFp(this.configuration).getCorporationsCorporationIdIndustryJobs(corporationId, datasource, ifNoneMatch, includeCompleted, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return a list of industry facilities  --- Alternate route: `/dev/industry/facilities/`  Alternate route: `/legacy/industry/facilities/`  Alternate route: `/v1/industry/facilities/`  --- This route is cached for up to 3600 seconds
     * @summary List industry facilities
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndustryApi
     */
    public getIndustryFacilities(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return IndustryApiFp(this.configuration).getIndustryFacilities(datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Return cost indices for solar systems  --- Alternate route: `/dev/industry/systems/`  Alternate route: `/legacy/industry/systems/`  Alternate route: `/v1/industry/systems/`  --- This route is cached for up to 3600 seconds
     * @summary List solar system cost indices
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndustryApi
     */
    public getIndustrySystems(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return IndustryApiFp(this.configuration).getIndustrySystems(datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

}

/**
 * InsuranceApi - fetch parameter creator
 * @export
 */
export const InsuranceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return available insurance levels for all ship types  --- Alternate route: `/dev/insurance/prices/`  Alternate route: `/legacy/insurance/prices/`  Alternate route: `/v1/insurance/prices/`  --- This route is cached for up to 3600 seconds
         * @summary List insurance levels
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInsurancePrices(acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options: any = {}): FetchArgs {
            const localVarPath = `/insurance/prices/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InsuranceApi - functional programming interface
 * @export
 */
export const InsuranceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Return available insurance levels for all ship types  --- Alternate route: `/dev/insurance/prices/`  Alternate route: `/legacy/insurance/prices/`  Alternate route: `/v1/insurance/prices/`  --- This route is cached for up to 3600 seconds
         * @summary List insurance levels
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInsurancePrices(acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetInsurancePrices200Ok>> {
            const localVarFetchArgs = InsuranceApiFetchParamCreator(configuration).getInsurancePrices(acceptLanguage, datasource, ifNoneMatch, language, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * InsuranceApi - factory interface
 * @export
 */
export const InsuranceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Return available insurance levels for all ship types  --- Alternate route: `/dev/insurance/prices/`  Alternate route: `/legacy/insurance/prices/`  Alternate route: `/v1/insurance/prices/`  --- This route is cached for up to 3600 seconds
         * @summary List insurance levels
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInsurancePrices(acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any) {
            return InsuranceApiFp(configuration).getInsurancePrices(acceptLanguage, datasource, ifNoneMatch, language, options)(fetch, basePath);
        },
    };
};

/**
 * InsuranceApi - object-oriented interface
 * @export
 * @class InsuranceApi
 * @extends {BaseAPI}
 */
export class InsuranceApi extends BaseAPI {
    /**
     * Return available insurance levels for all ship types  --- Alternate route: `/dev/insurance/prices/`  Alternate route: `/legacy/insurance/prices/`  Alternate route: `/v1/insurance/prices/`  --- This route is cached for up to 3600 seconds
     * @summary List insurance levels
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsuranceApi
     */
    public getInsurancePrices(acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any) {
        return InsuranceApiFp(this.configuration).getInsurancePrices(acceptLanguage, datasource, ifNoneMatch, language, options)(this.fetch, this.basePath);
    }

}

/**
 * KillmailsApi - fetch parameter creator
 * @export
 */
export const KillmailsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return a list of a character's kills and losses going back 90 days  --- Alternate route: `/dev/characters/{character_id}/killmails/recent/`  Alternate route: `/legacy/characters/{character_id}/killmails/recent/`  Alternate route: `/v1/characters/{character_id}/killmails/recent/`  --- This route is cached for up to 300 seconds
         * @summary Get a character's recent kills and losses
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdKillmailsRecent(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdKillmailsRecent.');
            }
            const localVarPath = `/characters/{character_id}/killmails/recent/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-killmails.read_killmails.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of a corporation's kills and losses going back 90 days  --- Alternate route: `/dev/corporations/{corporation_id}/killmails/recent/`  Alternate route: `/legacy/corporations/{corporation_id}/killmails/recent/`  Alternate route: `/v1/corporations/{corporation_id}/killmails/recent/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get a corporation's recent kills and losses
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdKillmailsRecent(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdKillmailsRecent.');
            }
            const localVarPath = `/corporations/{corporation_id}/killmails/recent/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-killmails.read_corporation_killmails.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a single killmail from its ID and hash  --- Alternate route: `/dev/killmails/{killmail_id}/{killmail_hash}/`  Alternate route: `/legacy/killmails/{killmail_id}/{killmail_hash}/`  Alternate route: `/v1/killmails/{killmail_id}/{killmail_hash}/`  --- This route is cached for up to 30758400 seconds
         * @summary Get a single killmail
         * @param {string} killmailHash The killmail hash for verification
         * @param {number} killmailId The killmail ID to be queried
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKillmailsKillmailIdKillmailHash(killmailHash: string, killmailId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'killmailHash' is not null or undefined
            if (killmailHash === null || killmailHash === undefined) {
                throw new RequiredError('killmailHash','Required parameter killmailHash was null or undefined when calling getKillmailsKillmailIdKillmailHash.');
            }
            // verify required parameter 'killmailId' is not null or undefined
            if (killmailId === null || killmailId === undefined) {
                throw new RequiredError('killmailId','Required parameter killmailId was null or undefined when calling getKillmailsKillmailIdKillmailHash.');
            }
            const localVarPath = `/killmails/{killmail_id}/{killmail_hash}/`
                .replace(`{${"killmail_hash"}}`, encodeURIComponent(String(killmailHash)))
                .replace(`{${"killmail_id"}}`, encodeURIComponent(String(killmailId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KillmailsApi - functional programming interface
 * @export
 */
export const KillmailsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Return a list of a character's kills and losses going back 90 days  --- Alternate route: `/dev/characters/{character_id}/killmails/recent/`  Alternate route: `/legacy/characters/{character_id}/killmails/recent/`  Alternate route: `/v1/characters/{character_id}/killmails/recent/`  --- This route is cached for up to 300 seconds
         * @summary Get a character's recent kills and losses
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdKillmailsRecent(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCharactersCharacterIdKillmailsRecent200Ok>> {
            const localVarFetchArgs = KillmailsApiFetchParamCreator(configuration).getCharactersCharacterIdKillmailsRecent(characterId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of a corporation's kills and losses going back 90 days  --- Alternate route: `/dev/corporations/{corporation_id}/killmails/recent/`  Alternate route: `/legacy/corporations/{corporation_id}/killmails/recent/`  Alternate route: `/v1/corporations/{corporation_id}/killmails/recent/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get a corporation's recent kills and losses
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdKillmailsRecent(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationsCorporationIdKillmailsRecent200Ok>> {
            const localVarFetchArgs = KillmailsApiFetchParamCreator(configuration).getCorporationsCorporationIdKillmailsRecent(corporationId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a single killmail from its ID and hash  --- Alternate route: `/dev/killmails/{killmail_id}/{killmail_hash}/`  Alternate route: `/legacy/killmails/{killmail_id}/{killmail_hash}/`  Alternate route: `/v1/killmails/{killmail_id}/{killmail_hash}/`  --- This route is cached for up to 30758400 seconds
         * @summary Get a single killmail
         * @param {string} killmailHash The killmail hash for verification
         * @param {number} killmailId The killmail ID to be queried
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKillmailsKillmailIdKillmailHash(killmailHash: string, killmailId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetKillmailsKillmailIdKillmailHashOk> {
            const localVarFetchArgs = KillmailsApiFetchParamCreator(configuration).getKillmailsKillmailIdKillmailHash(killmailHash, killmailId, datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * KillmailsApi - factory interface
 * @export
 */
export const KillmailsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Return a list of a character's kills and losses going back 90 days  --- Alternate route: `/dev/characters/{character_id}/killmails/recent/`  Alternate route: `/legacy/characters/{character_id}/killmails/recent/`  Alternate route: `/v1/characters/{character_id}/killmails/recent/`  --- This route is cached for up to 300 seconds
         * @summary Get a character's recent kills and losses
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdKillmailsRecent(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return KillmailsApiFp(configuration).getCharactersCharacterIdKillmailsRecent(characterId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
        /**
         * Get a list of a corporation's kills and losses going back 90 days  --- Alternate route: `/dev/corporations/{corporation_id}/killmails/recent/`  Alternate route: `/legacy/corporations/{corporation_id}/killmails/recent/`  Alternate route: `/v1/corporations/{corporation_id}/killmails/recent/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get a corporation's recent kills and losses
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdKillmailsRecent(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return KillmailsApiFp(configuration).getCorporationsCorporationIdKillmailsRecent(corporationId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
        /**
         * Return a single killmail from its ID and hash  --- Alternate route: `/dev/killmails/{killmail_id}/{killmail_hash}/`  Alternate route: `/legacy/killmails/{killmail_id}/{killmail_hash}/`  Alternate route: `/v1/killmails/{killmail_id}/{killmail_hash}/`  --- This route is cached for up to 30758400 seconds
         * @summary Get a single killmail
         * @param {string} killmailHash The killmail hash for verification
         * @param {number} killmailId The killmail ID to be queried
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKillmailsKillmailIdKillmailHash(killmailHash: string, killmailId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return KillmailsApiFp(configuration).getKillmailsKillmailIdKillmailHash(killmailHash, killmailId, datasource, ifNoneMatch, options)(fetch, basePath);
        },
    };
};

/**
 * KillmailsApi - object-oriented interface
 * @export
 * @class KillmailsApi
 * @extends {BaseAPI}
 */
export class KillmailsApi extends BaseAPI {
    /**
     * Return a list of a character's kills and losses going back 90 days  --- Alternate route: `/dev/characters/{character_id}/killmails/recent/`  Alternate route: `/legacy/characters/{character_id}/killmails/recent/`  Alternate route: `/v1/characters/{character_id}/killmails/recent/`  --- This route is cached for up to 300 seconds
     * @summary Get a character's recent kills and losses
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KillmailsApi
     */
    public getCharactersCharacterIdKillmailsRecent(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return KillmailsApiFp(this.configuration).getCharactersCharacterIdKillmailsRecent(characterId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of a corporation's kills and losses going back 90 days  --- Alternate route: `/dev/corporations/{corporation_id}/killmails/recent/`  Alternate route: `/legacy/corporations/{corporation_id}/killmails/recent/`  Alternate route: `/v1/corporations/{corporation_id}/killmails/recent/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get a corporation's recent kills and losses
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KillmailsApi
     */
    public getCorporationsCorporationIdKillmailsRecent(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return KillmailsApiFp(this.configuration).getCorporationsCorporationIdKillmailsRecent(corporationId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return a single killmail from its ID and hash  --- Alternate route: `/dev/killmails/{killmail_id}/{killmail_hash}/`  Alternate route: `/legacy/killmails/{killmail_id}/{killmail_hash}/`  Alternate route: `/v1/killmails/{killmail_id}/{killmail_hash}/`  --- This route is cached for up to 30758400 seconds
     * @summary Get a single killmail
     * @param {string} killmailHash The killmail hash for verification
     * @param {number} killmailId The killmail ID to be queried
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KillmailsApi
     */
    public getKillmailsKillmailIdKillmailHash(killmailHash: string, killmailId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return KillmailsApiFp(this.configuration).getKillmailsKillmailIdKillmailHash(killmailHash, killmailId, datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

}

/**
 * LocationApi - fetch parameter creator
 * @export
 */
export const LocationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Information about the characters current location. Returns the current solar system id, and also the current station or structure ID if applicable  --- Alternate route: `/dev/characters/{character_id}/location/`  Alternate route: `/legacy/characters/{character_id}/location/`  Alternate route: `/v1/characters/{character_id}/location/`  Alternate route: `/v2/characters/{character_id}/location/`  --- This route is cached for up to 5 seconds
         * @summary Get character location
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdLocation(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdLocation.');
            }
            const localVarPath = `/characters/{character_id}/location/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-location.read_location.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks if the character is currently online  --- Alternate route: `/dev/characters/{character_id}/online/`  Alternate route: `/v2/characters/{character_id}/online/`  Alternate route: `/v3/characters/{character_id}/online/`  --- This route is cached for up to 60 seconds
         * @summary Get character online
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdOnline(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdOnline.');
            }
            const localVarPath = `/characters/{character_id}/online/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-location.read_online.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current ship type, name and id  --- Alternate route: `/dev/characters/{character_id}/ship/`  Alternate route: `/legacy/characters/{character_id}/ship/`  Alternate route: `/v1/characters/{character_id}/ship/`  Alternate route: `/v2/characters/{character_id}/ship/`  --- This route is cached for up to 5 seconds
         * @summary Get current ship
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdShip(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdShip.');
            }
            const localVarPath = `/characters/{character_id}/ship/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-location.read_ship_type.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocationApi - functional programming interface
 * @export
 */
export const LocationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Information about the characters current location. Returns the current solar system id, and also the current station or structure ID if applicable  --- Alternate route: `/dev/characters/{character_id}/location/`  Alternate route: `/legacy/characters/{character_id}/location/`  Alternate route: `/v1/characters/{character_id}/location/`  Alternate route: `/v2/characters/{character_id}/location/`  --- This route is cached for up to 5 seconds
         * @summary Get character location
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdLocation(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCharactersCharacterIdLocationOk> {
            const localVarFetchArgs = LocationApiFetchParamCreator(configuration).getCharactersCharacterIdLocation(characterId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Checks if the character is currently online  --- Alternate route: `/dev/characters/{character_id}/online/`  Alternate route: `/v2/characters/{character_id}/online/`  Alternate route: `/v3/characters/{character_id}/online/`  --- This route is cached for up to 60 seconds
         * @summary Get character online
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdOnline(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCharactersCharacterIdOnlineOk> {
            const localVarFetchArgs = LocationApiFetchParamCreator(configuration).getCharactersCharacterIdOnline(characterId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the current ship type, name and id  --- Alternate route: `/dev/characters/{character_id}/ship/`  Alternate route: `/legacy/characters/{character_id}/ship/`  Alternate route: `/v1/characters/{character_id}/ship/`  Alternate route: `/v2/characters/{character_id}/ship/`  --- This route is cached for up to 5 seconds
         * @summary Get current ship
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdShip(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCharactersCharacterIdShipOk> {
            const localVarFetchArgs = LocationApiFetchParamCreator(configuration).getCharactersCharacterIdShip(characterId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LocationApi - factory interface
 * @export
 */
export const LocationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Information about the characters current location. Returns the current solar system id, and also the current station or structure ID if applicable  --- Alternate route: `/dev/characters/{character_id}/location/`  Alternate route: `/legacy/characters/{character_id}/location/`  Alternate route: `/v1/characters/{character_id}/location/`  Alternate route: `/v2/characters/{character_id}/location/`  --- This route is cached for up to 5 seconds
         * @summary Get character location
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdLocation(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return LocationApiFp(configuration).getCharactersCharacterIdLocation(characterId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Checks if the character is currently online  --- Alternate route: `/dev/characters/{character_id}/online/`  Alternate route: `/v2/characters/{character_id}/online/`  Alternate route: `/v3/characters/{character_id}/online/`  --- This route is cached for up to 60 seconds
         * @summary Get character online
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdOnline(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return LocationApiFp(configuration).getCharactersCharacterIdOnline(characterId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Get the current ship type, name and id  --- Alternate route: `/dev/characters/{character_id}/ship/`  Alternate route: `/legacy/characters/{character_id}/ship/`  Alternate route: `/v1/characters/{character_id}/ship/`  Alternate route: `/v2/characters/{character_id}/ship/`  --- This route is cached for up to 5 seconds
         * @summary Get current ship
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdShip(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return LocationApiFp(configuration).getCharactersCharacterIdShip(characterId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
    };
};

/**
 * LocationApi - object-oriented interface
 * @export
 * @class LocationApi
 * @extends {BaseAPI}
 */
export class LocationApi extends BaseAPI {
    /**
     * Information about the characters current location. Returns the current solar system id, and also the current station or structure ID if applicable  --- Alternate route: `/dev/characters/{character_id}/location/`  Alternate route: `/legacy/characters/{character_id}/location/`  Alternate route: `/v1/characters/{character_id}/location/`  Alternate route: `/v2/characters/{character_id}/location/`  --- This route is cached for up to 5 seconds
     * @summary Get character location
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public getCharactersCharacterIdLocation(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return LocationApiFp(this.configuration).getCharactersCharacterIdLocation(characterId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Checks if the character is currently online  --- Alternate route: `/dev/characters/{character_id}/online/`  Alternate route: `/v2/characters/{character_id}/online/`  Alternate route: `/v3/characters/{character_id}/online/`  --- This route is cached for up to 60 seconds
     * @summary Get character online
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public getCharactersCharacterIdOnline(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return LocationApiFp(this.configuration).getCharactersCharacterIdOnline(characterId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Get the current ship type, name and id  --- Alternate route: `/dev/characters/{character_id}/ship/`  Alternate route: `/legacy/characters/{character_id}/ship/`  Alternate route: `/v1/characters/{character_id}/ship/`  Alternate route: `/v2/characters/{character_id}/ship/`  --- This route is cached for up to 5 seconds
     * @summary Get current ship
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public getCharactersCharacterIdShip(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return LocationApiFp(this.configuration).getCharactersCharacterIdShip(characterId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

}

/**
 * LoyaltyApi - fetch parameter creator
 * @export
 */
export const LoyaltyApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return a list of loyalty points for all corporations the character has worked for  --- Alternate route: `/dev/characters/{character_id}/loyalty/points/`  Alternate route: `/legacy/characters/{character_id}/loyalty/points/`  Alternate route: `/v1/characters/{character_id}/loyalty/points/`  --- This route is cached for up to 3600 seconds
         * @summary Get loyalty points
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdLoyaltyPoints(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdLoyaltyPoints.');
            }
            const localVarPath = `/characters/{character_id}/loyalty/points/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-characters.read_loyalty.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of offers from a specific corporation's loyalty store  --- Alternate route: `/dev/loyalty/stores/{corporation_id}/offers/`  Alternate route: `/legacy/loyalty/stores/{corporation_id}/offers/`  Alternate route: `/v1/loyalty/stores/{corporation_id}/offers/`  --- This route expires daily at 11:05
         * @summary List loyalty store offers
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoyaltyStoresCorporationIdOffers(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getLoyaltyStoresCorporationIdOffers.');
            }
            const localVarPath = `/loyalty/stores/{corporation_id}/offers/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoyaltyApi - functional programming interface
 * @export
 */
export const LoyaltyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Return a list of loyalty points for all corporations the character has worked for  --- Alternate route: `/dev/characters/{character_id}/loyalty/points/`  Alternate route: `/legacy/characters/{character_id}/loyalty/points/`  Alternate route: `/v1/characters/{character_id}/loyalty/points/`  --- This route is cached for up to 3600 seconds
         * @summary Get loyalty points
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdLoyaltyPoints(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCharactersCharacterIdLoyaltyPoints200Ok>> {
            const localVarFetchArgs = LoyaltyApiFetchParamCreator(configuration).getCharactersCharacterIdLoyaltyPoints(characterId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a list of offers from a specific corporation's loyalty store  --- Alternate route: `/dev/loyalty/stores/{corporation_id}/offers/`  Alternate route: `/legacy/loyalty/stores/{corporation_id}/offers/`  Alternate route: `/v1/loyalty/stores/{corporation_id}/offers/`  --- This route expires daily at 11:05
         * @summary List loyalty store offers
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoyaltyStoresCorporationIdOffers(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetLoyaltyStoresCorporationIdOffers200Ok>> {
            const localVarFetchArgs = LoyaltyApiFetchParamCreator(configuration).getLoyaltyStoresCorporationIdOffers(corporationId, datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LoyaltyApi - factory interface
 * @export
 */
export const LoyaltyApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Return a list of loyalty points for all corporations the character has worked for  --- Alternate route: `/dev/characters/{character_id}/loyalty/points/`  Alternate route: `/legacy/characters/{character_id}/loyalty/points/`  Alternate route: `/v1/characters/{character_id}/loyalty/points/`  --- This route is cached for up to 3600 seconds
         * @summary Get loyalty points
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdLoyaltyPoints(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return LoyaltyApiFp(configuration).getCharactersCharacterIdLoyaltyPoints(characterId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Return a list of offers from a specific corporation's loyalty store  --- Alternate route: `/dev/loyalty/stores/{corporation_id}/offers/`  Alternate route: `/legacy/loyalty/stores/{corporation_id}/offers/`  Alternate route: `/v1/loyalty/stores/{corporation_id}/offers/`  --- This route expires daily at 11:05
         * @summary List loyalty store offers
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoyaltyStoresCorporationIdOffers(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return LoyaltyApiFp(configuration).getLoyaltyStoresCorporationIdOffers(corporationId, datasource, ifNoneMatch, options)(fetch, basePath);
        },
    };
};

/**
 * LoyaltyApi - object-oriented interface
 * @export
 * @class LoyaltyApi
 * @extends {BaseAPI}
 */
export class LoyaltyApi extends BaseAPI {
    /**
     * Return a list of loyalty points for all corporations the character has worked for  --- Alternate route: `/dev/characters/{character_id}/loyalty/points/`  Alternate route: `/legacy/characters/{character_id}/loyalty/points/`  Alternate route: `/v1/characters/{character_id}/loyalty/points/`  --- This route is cached for up to 3600 seconds
     * @summary Get loyalty points
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoyaltyApi
     */
    public getCharactersCharacterIdLoyaltyPoints(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return LoyaltyApiFp(this.configuration).getCharactersCharacterIdLoyaltyPoints(characterId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return a list of offers from a specific corporation's loyalty store  --- Alternate route: `/dev/loyalty/stores/{corporation_id}/offers/`  Alternate route: `/legacy/loyalty/stores/{corporation_id}/offers/`  Alternate route: `/v1/loyalty/stores/{corporation_id}/offers/`  --- This route expires daily at 11:05
     * @summary List loyalty store offers
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoyaltyApi
     */
    public getLoyaltyStoresCorporationIdOffers(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return LoyaltyApiFp(this.configuration).getLoyaltyStoresCorporationIdOffers(corporationId, datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

}

/**
 * MailApi - fetch parameter creator
 * @export
 */
export const MailApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a mail label  --- Alternate route: `/dev/characters/{character_id}/mail/labels/{label_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/labels/{label_id}/`  Alternate route: `/v1/characters/{character_id}/mail/labels/{label_id}/` 
         * @summary Delete a mail label
         * @param {number} characterId An EVE character ID
         * @param {number} labelId An EVE label id
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharactersCharacterIdMailLabelsLabelId(characterId: number, labelId: number, datasource?: 'tranquility', token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling deleteCharactersCharacterIdMailLabelsLabelId.');
            }
            // verify required parameter 'labelId' is not null or undefined
            if (labelId === null || labelId === undefined) {
                throw new RequiredError('labelId','Required parameter labelId was null or undefined when calling deleteCharactersCharacterIdMailLabelsLabelId.');
            }
            const localVarPath = `/characters/{character_id}/mail/labels/{label_id}/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)))
                .replace(`{${"label_id"}}`, encodeURIComponent(String(labelId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-mail.organize_mail.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/` 
         * @summary Delete a mail
         * @param {number} characterId An EVE character ID
         * @param {number} mailId An EVE mail ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharactersCharacterIdMailMailId(characterId: number, mailId: number, datasource?: 'tranquility', token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling deleteCharactersCharacterIdMailMailId.');
            }
            // verify required parameter 'mailId' is not null or undefined
            if (mailId === null || mailId === undefined) {
                throw new RequiredError('mailId','Required parameter mailId was null or undefined when calling deleteCharactersCharacterIdMailMailId.');
            }
            const localVarPath = `/characters/{character_id}/mail/{mail_id}/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)))
                .replace(`{${"mail_id"}}`, encodeURIComponent(String(mailId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-mail.organize_mail.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the 50 most recent mail headers belonging to the character that match the query criteria. Queries can be filtered by label, and last_mail_id can be used to paginate backwards  --- Alternate route: `/dev/characters/{character_id}/mail/`  Alternate route: `/legacy/characters/{character_id}/mail/`  Alternate route: `/v1/characters/{character_id}/mail/`  --- This route is cached for up to 30 seconds
         * @summary Return mail headers
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {Array<number>} [labels] Fetch only mails that match one or more of the given labels
         * @param {number} [lastMailId] List only mail with an ID lower than the given ID, if present
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdMail(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, labels?: Array<number>, lastMailId?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdMail.');
            }
            const localVarPath = `/characters/{character_id}/mail/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-mail.read_mail.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (labels) {
                localVarQueryParameter['labels'] = labels;
            }

            if (lastMailId !== undefined) {
                localVarQueryParameter['last_mail_id'] = lastMailId;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of the users mail labels, unread counts for each label and a total unread count.  --- Alternate route: `/dev/characters/{character_id}/mail/labels/`  Alternate route: `/v3/characters/{character_id}/mail/labels/`  --- This route is cached for up to 30 seconds
         * @summary Get mail labels and unread counts
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdMailLabels(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdMailLabels.');
            }
            const localVarPath = `/characters/{character_id}/mail/labels/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-mail.read_mail.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return all mailing lists that the character is subscribed to  --- Alternate route: `/dev/characters/{character_id}/mail/lists/`  Alternate route: `/legacy/characters/{character_id}/mail/lists/`  Alternate route: `/v1/characters/{character_id}/mail/lists/`  --- This route is cached for up to 120 seconds
         * @summary Return mailing list subscriptions
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdMailLists(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdMailLists.');
            }
            const localVarPath = `/characters/{character_id}/mail/lists/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-mail.read_mail.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the contents of an EVE mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/`  --- This route is cached for up to 30 seconds
         * @summary Return a mail
         * @param {number} characterId An EVE character ID
         * @param {number} mailId An EVE mail ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdMailMailId(characterId: number, mailId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdMailMailId.');
            }
            // verify required parameter 'mailId' is not null or undefined
            if (mailId === null || mailId === undefined) {
                throw new RequiredError('mailId','Required parameter mailId was null or undefined when calling getCharactersCharacterIdMailMailId.');
            }
            const localVarPath = `/characters/{character_id}/mail/{mail_id}/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)))
                .replace(`{${"mail_id"}}`, encodeURIComponent(String(mailId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-mail.read_mail.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create and send a new mail  --- Alternate route: `/dev/characters/{character_id}/mail/`  Alternate route: `/legacy/characters/{character_id}/mail/`  Alternate route: `/v1/characters/{character_id}/mail/` 
         * @summary Send a new mail
         * @param {number} characterId An EVE character ID
         * @param {PostCharactersCharacterIdMailMail} mail The mail to send
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdMail(characterId: number, mail: PostCharactersCharacterIdMailMail, datasource?: 'tranquility', token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling postCharactersCharacterIdMail.');
            }
            // verify required parameter 'mail' is not null or undefined
            if (mail === null || mail === undefined) {
                throw new RequiredError('mail','Required parameter mail was null or undefined when calling postCharactersCharacterIdMail.');
            }
            const localVarPath = `/characters/{character_id}/mail/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-mail.send_mail.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PostCharactersCharacterIdMailMail" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(mail || {}) : (mail || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a mail label  --- Alternate route: `/dev/characters/{character_id}/mail/labels/`  Alternate route: `/legacy/characters/{character_id}/mail/labels/`  Alternate route: `/v2/characters/{character_id}/mail/labels/` 
         * @summary Create a mail label
         * @param {number} characterId An EVE character ID
         * @param {PostCharactersCharacterIdMailLabelsLabel} label Label to create
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdMailLabels(characterId: number, label: PostCharactersCharacterIdMailLabelsLabel, datasource?: 'tranquility', token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling postCharactersCharacterIdMailLabels.');
            }
            // verify required parameter 'label' is not null or undefined
            if (label === null || label === undefined) {
                throw new RequiredError('label','Required parameter label was null or undefined when calling postCharactersCharacterIdMailLabels.');
            }
            const localVarPath = `/characters/{character_id}/mail/labels/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-mail.organize_mail.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PostCharactersCharacterIdMailLabelsLabel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(label || {}) : (label || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update metadata about a mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/` 
         * @summary Update metadata about a mail
         * @param {number} characterId An EVE character ID
         * @param {PutCharactersCharacterIdMailMailIdContents} contents Data used to update the mail
         * @param {number} mailId An EVE mail ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCharactersCharacterIdMailMailId(characterId: number, contents: PutCharactersCharacterIdMailMailIdContents, mailId: number, datasource?: 'tranquility', token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling putCharactersCharacterIdMailMailId.');
            }
            // verify required parameter 'contents' is not null or undefined
            if (contents === null || contents === undefined) {
                throw new RequiredError('contents','Required parameter contents was null or undefined when calling putCharactersCharacterIdMailMailId.');
            }
            // verify required parameter 'mailId' is not null or undefined
            if (mailId === null || mailId === undefined) {
                throw new RequiredError('mailId','Required parameter mailId was null or undefined when calling putCharactersCharacterIdMailMailId.');
            }
            const localVarPath = `/characters/{character_id}/mail/{mail_id}/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)))
                .replace(`{${"mail_id"}}`, encodeURIComponent(String(mailId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-mail.organize_mail.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PutCharactersCharacterIdMailMailIdContents" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(contents || {}) : (contents || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MailApi - functional programming interface
 * @export
 */
export const MailApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a mail label  --- Alternate route: `/dev/characters/{character_id}/mail/labels/{label_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/labels/{label_id}/`  Alternate route: `/v1/characters/{character_id}/mail/labels/{label_id}/` 
         * @summary Delete a mail label
         * @param {number} characterId An EVE character ID
         * @param {number} labelId An EVE label id
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharactersCharacterIdMailLabelsLabelId(characterId: number, labelId: number, datasource?: 'tranquility', token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = MailApiFetchParamCreator(configuration).deleteCharactersCharacterIdMailLabelsLabelId(characterId, labelId, datasource, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/` 
         * @summary Delete a mail
         * @param {number} characterId An EVE character ID
         * @param {number} mailId An EVE mail ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharactersCharacterIdMailMailId(characterId: number, mailId: number, datasource?: 'tranquility', token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = MailApiFetchParamCreator(configuration).deleteCharactersCharacterIdMailMailId(characterId, mailId, datasource, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return the 50 most recent mail headers belonging to the character that match the query criteria. Queries can be filtered by label, and last_mail_id can be used to paginate backwards  --- Alternate route: `/dev/characters/{character_id}/mail/`  Alternate route: `/legacy/characters/{character_id}/mail/`  Alternate route: `/v1/characters/{character_id}/mail/`  --- This route is cached for up to 30 seconds
         * @summary Return mail headers
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {Array<number>} [labels] Fetch only mails that match one or more of the given labels
         * @param {number} [lastMailId] List only mail with an ID lower than the given ID, if present
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdMail(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, labels?: Array<number>, lastMailId?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCharactersCharacterIdMail200Ok>> {
            const localVarFetchArgs = MailApiFetchParamCreator(configuration).getCharactersCharacterIdMail(characterId, datasource, ifNoneMatch, labels, lastMailId, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a list of the users mail labels, unread counts for each label and a total unread count.  --- Alternate route: `/dev/characters/{character_id}/mail/labels/`  Alternate route: `/v3/characters/{character_id}/mail/labels/`  --- This route is cached for up to 30 seconds
         * @summary Get mail labels and unread counts
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdMailLabels(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCharactersCharacterIdMailLabelsOk> {
            const localVarFetchArgs = MailApiFetchParamCreator(configuration).getCharactersCharacterIdMailLabels(characterId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return all mailing lists that the character is subscribed to  --- Alternate route: `/dev/characters/{character_id}/mail/lists/`  Alternate route: `/legacy/characters/{character_id}/mail/lists/`  Alternate route: `/v1/characters/{character_id}/mail/lists/`  --- This route is cached for up to 120 seconds
         * @summary Return mailing list subscriptions
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdMailLists(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCharactersCharacterIdMailLists200Ok>> {
            const localVarFetchArgs = MailApiFetchParamCreator(configuration).getCharactersCharacterIdMailLists(characterId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return the contents of an EVE mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/`  --- This route is cached for up to 30 seconds
         * @summary Return a mail
         * @param {number} characterId An EVE character ID
         * @param {number} mailId An EVE mail ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdMailMailId(characterId: number, mailId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCharactersCharacterIdMailMailIdOk> {
            const localVarFetchArgs = MailApiFetchParamCreator(configuration).getCharactersCharacterIdMailMailId(characterId, mailId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create and send a new mail  --- Alternate route: `/dev/characters/{character_id}/mail/`  Alternate route: `/legacy/characters/{character_id}/mail/`  Alternate route: `/v1/characters/{character_id}/mail/` 
         * @summary Send a new mail
         * @param {number} characterId An EVE character ID
         * @param {PostCharactersCharacterIdMailMail} mail The mail to send
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdMail(characterId: number, mail: PostCharactersCharacterIdMailMail, datasource?: 'tranquility', token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = MailApiFetchParamCreator(configuration).postCharactersCharacterIdMail(characterId, mail, datasource, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a mail label  --- Alternate route: `/dev/characters/{character_id}/mail/labels/`  Alternate route: `/legacy/characters/{character_id}/mail/labels/`  Alternate route: `/v2/characters/{character_id}/mail/labels/` 
         * @summary Create a mail label
         * @param {number} characterId An EVE character ID
         * @param {PostCharactersCharacterIdMailLabelsLabel} label Label to create
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdMailLabels(characterId: number, label: PostCharactersCharacterIdMailLabelsLabel, datasource?: 'tranquility', token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = MailApiFetchParamCreator(configuration).postCharactersCharacterIdMailLabels(characterId, label, datasource, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update metadata about a mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/` 
         * @summary Update metadata about a mail
         * @param {number} characterId An EVE character ID
         * @param {PutCharactersCharacterIdMailMailIdContents} contents Data used to update the mail
         * @param {number} mailId An EVE mail ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCharactersCharacterIdMailMailId(characterId: number, contents: PutCharactersCharacterIdMailMailIdContents, mailId: number, datasource?: 'tranquility', token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = MailApiFetchParamCreator(configuration).putCharactersCharacterIdMailMailId(characterId, contents, mailId, datasource, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MailApi - factory interface
 * @export
 */
export const MailApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete a mail label  --- Alternate route: `/dev/characters/{character_id}/mail/labels/{label_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/labels/{label_id}/`  Alternate route: `/v1/characters/{character_id}/mail/labels/{label_id}/` 
         * @summary Delete a mail label
         * @param {number} characterId An EVE character ID
         * @param {number} labelId An EVE label id
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharactersCharacterIdMailLabelsLabelId(characterId: number, labelId: number, datasource?: 'tranquility', token?: string, options?: any) {
            return MailApiFp(configuration).deleteCharactersCharacterIdMailLabelsLabelId(characterId, labelId, datasource, token, options)(fetch, basePath);
        },
        /**
         * Delete a mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/` 
         * @summary Delete a mail
         * @param {number} characterId An EVE character ID
         * @param {number} mailId An EVE mail ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharactersCharacterIdMailMailId(characterId: number, mailId: number, datasource?: 'tranquility', token?: string, options?: any) {
            return MailApiFp(configuration).deleteCharactersCharacterIdMailMailId(characterId, mailId, datasource, token, options)(fetch, basePath);
        },
        /**
         * Return the 50 most recent mail headers belonging to the character that match the query criteria. Queries can be filtered by label, and last_mail_id can be used to paginate backwards  --- Alternate route: `/dev/characters/{character_id}/mail/`  Alternate route: `/legacy/characters/{character_id}/mail/`  Alternate route: `/v1/characters/{character_id}/mail/`  --- This route is cached for up to 30 seconds
         * @summary Return mail headers
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {Array<number>} [labels] Fetch only mails that match one or more of the given labels
         * @param {number} [lastMailId] List only mail with an ID lower than the given ID, if present
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdMail(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, labels?: Array<number>, lastMailId?: number, token?: string, options?: any) {
            return MailApiFp(configuration).getCharactersCharacterIdMail(characterId, datasource, ifNoneMatch, labels, lastMailId, token, options)(fetch, basePath);
        },
        /**
         * Return a list of the users mail labels, unread counts for each label and a total unread count.  --- Alternate route: `/dev/characters/{character_id}/mail/labels/`  Alternate route: `/v3/characters/{character_id}/mail/labels/`  --- This route is cached for up to 30 seconds
         * @summary Get mail labels and unread counts
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdMailLabels(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return MailApiFp(configuration).getCharactersCharacterIdMailLabels(characterId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Return all mailing lists that the character is subscribed to  --- Alternate route: `/dev/characters/{character_id}/mail/lists/`  Alternate route: `/legacy/characters/{character_id}/mail/lists/`  Alternate route: `/v1/characters/{character_id}/mail/lists/`  --- This route is cached for up to 120 seconds
         * @summary Return mailing list subscriptions
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdMailLists(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return MailApiFp(configuration).getCharactersCharacterIdMailLists(characterId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Return the contents of an EVE mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/`  --- This route is cached for up to 30 seconds
         * @summary Return a mail
         * @param {number} characterId An EVE character ID
         * @param {number} mailId An EVE mail ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdMailMailId(characterId: number, mailId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return MailApiFp(configuration).getCharactersCharacterIdMailMailId(characterId, mailId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Create and send a new mail  --- Alternate route: `/dev/characters/{character_id}/mail/`  Alternate route: `/legacy/characters/{character_id}/mail/`  Alternate route: `/v1/characters/{character_id}/mail/` 
         * @summary Send a new mail
         * @param {number} characterId An EVE character ID
         * @param {PostCharactersCharacterIdMailMail} mail The mail to send
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdMail(characterId: number, mail: PostCharactersCharacterIdMailMail, datasource?: 'tranquility', token?: string, options?: any) {
            return MailApiFp(configuration).postCharactersCharacterIdMail(characterId, mail, datasource, token, options)(fetch, basePath);
        },
        /**
         * Create a mail label  --- Alternate route: `/dev/characters/{character_id}/mail/labels/`  Alternate route: `/legacy/characters/{character_id}/mail/labels/`  Alternate route: `/v2/characters/{character_id}/mail/labels/` 
         * @summary Create a mail label
         * @param {number} characterId An EVE character ID
         * @param {PostCharactersCharacterIdMailLabelsLabel} label Label to create
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdMailLabels(characterId: number, label: PostCharactersCharacterIdMailLabelsLabel, datasource?: 'tranquility', token?: string, options?: any) {
            return MailApiFp(configuration).postCharactersCharacterIdMailLabels(characterId, label, datasource, token, options)(fetch, basePath);
        },
        /**
         * Update metadata about a mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/` 
         * @summary Update metadata about a mail
         * @param {number} characterId An EVE character ID
         * @param {PutCharactersCharacterIdMailMailIdContents} contents Data used to update the mail
         * @param {number} mailId An EVE mail ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCharactersCharacterIdMailMailId(characterId: number, contents: PutCharactersCharacterIdMailMailIdContents, mailId: number, datasource?: 'tranquility', token?: string, options?: any) {
            return MailApiFp(configuration).putCharactersCharacterIdMailMailId(characterId, contents, mailId, datasource, token, options)(fetch, basePath);
        },
    };
};

/**
 * MailApi - object-oriented interface
 * @export
 * @class MailApi
 * @extends {BaseAPI}
 */
export class MailApi extends BaseAPI {
    /**
     * Delete a mail label  --- Alternate route: `/dev/characters/{character_id}/mail/labels/{label_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/labels/{label_id}/`  Alternate route: `/v1/characters/{character_id}/mail/labels/{label_id}/` 
     * @summary Delete a mail label
     * @param {number} characterId An EVE character ID
     * @param {number} labelId An EVE label id
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailApi
     */
    public deleteCharactersCharacterIdMailLabelsLabelId(characterId: number, labelId: number, datasource?: 'tranquility', token?: string, options?: any) {
        return MailApiFp(this.configuration).deleteCharactersCharacterIdMailLabelsLabelId(characterId, labelId, datasource, token, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/` 
     * @summary Delete a mail
     * @param {number} characterId An EVE character ID
     * @param {number} mailId An EVE mail ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailApi
     */
    public deleteCharactersCharacterIdMailMailId(characterId: number, mailId: number, datasource?: 'tranquility', token?: string, options?: any) {
        return MailApiFp(this.configuration).deleteCharactersCharacterIdMailMailId(characterId, mailId, datasource, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return the 50 most recent mail headers belonging to the character that match the query criteria. Queries can be filtered by label, and last_mail_id can be used to paginate backwards  --- Alternate route: `/dev/characters/{character_id}/mail/`  Alternate route: `/legacy/characters/{character_id}/mail/`  Alternate route: `/v1/characters/{character_id}/mail/`  --- This route is cached for up to 30 seconds
     * @summary Return mail headers
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {Array<number>} [labels] Fetch only mails that match one or more of the given labels
     * @param {number} [lastMailId] List only mail with an ID lower than the given ID, if present
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailApi
     */
    public getCharactersCharacterIdMail(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, labels?: Array<number>, lastMailId?: number, token?: string, options?: any) {
        return MailApiFp(this.configuration).getCharactersCharacterIdMail(characterId, datasource, ifNoneMatch, labels, lastMailId, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return a list of the users mail labels, unread counts for each label and a total unread count.  --- Alternate route: `/dev/characters/{character_id}/mail/labels/`  Alternate route: `/v3/characters/{character_id}/mail/labels/`  --- This route is cached for up to 30 seconds
     * @summary Get mail labels and unread counts
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailApi
     */
    public getCharactersCharacterIdMailLabels(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return MailApiFp(this.configuration).getCharactersCharacterIdMailLabels(characterId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return all mailing lists that the character is subscribed to  --- Alternate route: `/dev/characters/{character_id}/mail/lists/`  Alternate route: `/legacy/characters/{character_id}/mail/lists/`  Alternate route: `/v1/characters/{character_id}/mail/lists/`  --- This route is cached for up to 120 seconds
     * @summary Return mailing list subscriptions
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailApi
     */
    public getCharactersCharacterIdMailLists(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return MailApiFp(this.configuration).getCharactersCharacterIdMailLists(characterId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return the contents of an EVE mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/`  --- This route is cached for up to 30 seconds
     * @summary Return a mail
     * @param {number} characterId An EVE character ID
     * @param {number} mailId An EVE mail ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailApi
     */
    public getCharactersCharacterIdMailMailId(characterId: number, mailId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return MailApiFp(this.configuration).getCharactersCharacterIdMailMailId(characterId, mailId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Create and send a new mail  --- Alternate route: `/dev/characters/{character_id}/mail/`  Alternate route: `/legacy/characters/{character_id}/mail/`  Alternate route: `/v1/characters/{character_id}/mail/` 
     * @summary Send a new mail
     * @param {number} characterId An EVE character ID
     * @param {PostCharactersCharacterIdMailMail} mail The mail to send
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailApi
     */
    public postCharactersCharacterIdMail(characterId: number, mail: PostCharactersCharacterIdMailMail, datasource?: 'tranquility', token?: string, options?: any) {
        return MailApiFp(this.configuration).postCharactersCharacterIdMail(characterId, mail, datasource, token, options)(this.fetch, this.basePath);
    }

    /**
     * Create a mail label  --- Alternate route: `/dev/characters/{character_id}/mail/labels/`  Alternate route: `/legacy/characters/{character_id}/mail/labels/`  Alternate route: `/v2/characters/{character_id}/mail/labels/` 
     * @summary Create a mail label
     * @param {number} characterId An EVE character ID
     * @param {PostCharactersCharacterIdMailLabelsLabel} label Label to create
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailApi
     */
    public postCharactersCharacterIdMailLabels(characterId: number, label: PostCharactersCharacterIdMailLabelsLabel, datasource?: 'tranquility', token?: string, options?: any) {
        return MailApiFp(this.configuration).postCharactersCharacterIdMailLabels(characterId, label, datasource, token, options)(this.fetch, this.basePath);
    }

    /**
     * Update metadata about a mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/` 
     * @summary Update metadata about a mail
     * @param {number} characterId An EVE character ID
     * @param {PutCharactersCharacterIdMailMailIdContents} contents Data used to update the mail
     * @param {number} mailId An EVE mail ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailApi
     */
    public putCharactersCharacterIdMailMailId(characterId: number, contents: PutCharactersCharacterIdMailMailIdContents, mailId: number, datasource?: 'tranquility', token?: string, options?: any) {
        return MailApiFp(this.configuration).putCharactersCharacterIdMailMailId(characterId, contents, mailId, datasource, token, options)(this.fetch, this.basePath);
    }

}

/**
 * MarketApi - fetch parameter creator
 * @export
 */
export const MarketApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List open market orders placed by a character  --- Alternate route: `/dev/characters/{character_id}/orders/`  Alternate route: `/v2/characters/{character_id}/orders/`  --- This route is cached for up to 1200 seconds
         * @summary List open orders from a character
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdOrders(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdOrders.');
            }
            const localVarPath = `/characters/{character_id}/orders/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-markets.read_character_orders.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List cancelled and expired market orders placed by a character up to 90 days in the past.  --- Alternate route: `/dev/characters/{character_id}/orders/history/`  Alternate route: `/legacy/characters/{character_id}/orders/history/`  Alternate route: `/v1/characters/{character_id}/orders/history/`  --- This route is cached for up to 3600 seconds
         * @summary List historical orders by a character
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdOrdersHistory(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdOrdersHistory.');
            }
            const localVarPath = `/characters/{character_id}/orders/history/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-markets.read_character_orders.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List open market orders placed on behalf of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/orders/`  Alternate route: `/v3/corporations/{corporation_id}/orders/`  --- This route is cached for up to 1200 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Trader 
         * @summary List open orders from a corporation
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdOrders(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdOrders.');
            }
            const localVarPath = `/corporations/{corporation_id}/orders/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-markets.read_corporation_orders.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List cancelled and expired market orders placed on behalf of a corporation up to 90 days in the past.  --- Alternate route: `/dev/corporations/{corporation_id}/orders/history/`  Alternate route: `/v2/corporations/{corporation_id}/orders/history/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Trader 
         * @summary List historical orders from a corporation
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdOrdersHistory(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdOrdersHistory.');
            }
            const localVarPath = `/corporations/{corporation_id}/orders/history/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-markets.read_corporation_orders.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of item groups  --- Alternate route: `/dev/markets/groups/`  Alternate route: `/legacy/markets/groups/`  Alternate route: `/v1/markets/groups/`  --- This route expires daily at 11:05
         * @summary Get item groups
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsGroups(datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            const localVarPath = `/markets/groups/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on an item group  --- Alternate route: `/dev/markets/groups/{market_group_id}/`  Alternate route: `/legacy/markets/groups/{market_group_id}/`  Alternate route: `/v1/markets/groups/{market_group_id}/`  --- This route expires daily at 11:05
         * @summary Get item group information
         * @param {number} marketGroupId An Eve item group ID
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsGroupsMarketGroupId(marketGroupId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options: any = {}): FetchArgs {
            // verify required parameter 'marketGroupId' is not null or undefined
            if (marketGroupId === null || marketGroupId === undefined) {
                throw new RequiredError('marketGroupId','Required parameter marketGroupId was null or undefined when calling getMarketsGroupsMarketGroupId.');
            }
            const localVarPath = `/markets/groups/{market_group_id}/`
                .replace(`{${"market_group_id"}}`, encodeURIComponent(String(marketGroupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of prices  --- Alternate route: `/dev/markets/prices/`  Alternate route: `/legacy/markets/prices/`  Alternate route: `/v1/markets/prices/`  --- This route is cached for up to 3600 seconds
         * @summary List market prices
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsPrices(datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            const localVarPath = `/markets/prices/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of historical market statistics for the specified type in a region  --- Alternate route: `/dev/markets/{region_id}/history/`  Alternate route: `/legacy/markets/{region_id}/history/`  Alternate route: `/v1/markets/{region_id}/history/`  --- This route expires daily at 11:05
         * @summary List historical market statistics in a region
         * @param {number} regionId Return statistics in this region
         * @param {number} typeId Return statistics for this type
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsRegionIdHistory(regionId: number, typeId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'regionId' is not null or undefined
            if (regionId === null || regionId === undefined) {
                throw new RequiredError('regionId','Required parameter regionId was null or undefined when calling getMarketsRegionIdHistory.');
            }
            // verify required parameter 'typeId' is not null or undefined
            if (typeId === null || typeId === undefined) {
                throw new RequiredError('typeId','Required parameter typeId was null or undefined when calling getMarketsRegionIdHistory.');
            }
            const localVarPath = `/markets/{region_id}/history/`
                .replace(`{${"region_id"}}`, encodeURIComponent(String(regionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (typeId !== undefined) {
                localVarQueryParameter['type_id'] = typeId;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of orders in a region  --- Alternate route: `/dev/markets/{region_id}/orders/`  Alternate route: `/legacy/markets/{region_id}/orders/`  Alternate route: `/v1/markets/{region_id}/orders/`  --- This route is cached for up to 300 seconds
         * @summary List orders in a region
         * @param {'buy' | 'sell' | 'all'} orderType Filter buy/sell orders, return all orders by default. If you query without type_id, we always return both buy and sell orders
         * @param {number} regionId Return orders in this region
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {number} [typeId] Return orders only for this type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsRegionIdOrders(orderType: 'buy' | 'sell' | 'all', regionId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, typeId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'orderType' is not null or undefined
            if (orderType === null || orderType === undefined) {
                throw new RequiredError('orderType','Required parameter orderType was null or undefined when calling getMarketsRegionIdOrders.');
            }
            // verify required parameter 'regionId' is not null or undefined
            if (regionId === null || regionId === undefined) {
                throw new RequiredError('regionId','Required parameter regionId was null or undefined when calling getMarketsRegionIdOrders.');
            }
            const localVarPath = `/markets/{region_id}/orders/`
                .replace(`{${"region_id"}}`, encodeURIComponent(String(regionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (orderType !== undefined) {
                localVarQueryParameter['order_type'] = orderType;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (typeId !== undefined) {
                localVarQueryParameter['type_id'] = typeId;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of type IDs that have active orders in the region, for efficient market indexing.  --- Alternate route: `/dev/markets/{region_id}/types/`  Alternate route: `/legacy/markets/{region_id}/types/`  Alternate route: `/v1/markets/{region_id}/types/`  --- This route is cached for up to 600 seconds
         * @summary List type IDs relevant to a market
         * @param {number} regionId Return statistics in this region
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsRegionIdTypes(regionId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options: any = {}): FetchArgs {
            // verify required parameter 'regionId' is not null or undefined
            if (regionId === null || regionId === undefined) {
                throw new RequiredError('regionId','Required parameter regionId was null or undefined when calling getMarketsRegionIdTypes.');
            }
            const localVarPath = `/markets/{region_id}/types/`
                .replace(`{${"region_id"}}`, encodeURIComponent(String(regionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return all orders in a structure  --- Alternate route: `/dev/markets/structures/{structure_id}/`  Alternate route: `/legacy/markets/structures/{structure_id}/`  Alternate route: `/v1/markets/structures/{structure_id}/`  --- This route is cached for up to 300 seconds
         * @summary List orders in a structure
         * @param {number} structureId Return orders in this structure
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsStructuresStructureId(structureId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'structureId' is not null or undefined
            if (structureId === null || structureId === undefined) {
                throw new RequiredError('structureId','Required parameter structureId was null or undefined when calling getMarketsStructuresStructureId.');
            }
            const localVarPath = `/markets/structures/{structure_id}/`
                .replace(`{${"structure_id"}}`, encodeURIComponent(String(structureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-markets.structure_markets.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MarketApi - functional programming interface
 * @export
 */
export const MarketApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List open market orders placed by a character  --- Alternate route: `/dev/characters/{character_id}/orders/`  Alternate route: `/v2/characters/{character_id}/orders/`  --- This route is cached for up to 1200 seconds
         * @summary List open orders from a character
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdOrders(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCharactersCharacterIdOrders200Ok>> {
            const localVarFetchArgs = MarketApiFetchParamCreator(configuration).getCharactersCharacterIdOrders(characterId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List cancelled and expired market orders placed by a character up to 90 days in the past.  --- Alternate route: `/dev/characters/{character_id}/orders/history/`  Alternate route: `/legacy/characters/{character_id}/orders/history/`  Alternate route: `/v1/characters/{character_id}/orders/history/`  --- This route is cached for up to 3600 seconds
         * @summary List historical orders by a character
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdOrdersHistory(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCharactersCharacterIdOrdersHistory200Ok>> {
            const localVarFetchArgs = MarketApiFetchParamCreator(configuration).getCharactersCharacterIdOrdersHistory(characterId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List open market orders placed on behalf of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/orders/`  Alternate route: `/v3/corporations/{corporation_id}/orders/`  --- This route is cached for up to 1200 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Trader 
         * @summary List open orders from a corporation
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdOrders(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationsCorporationIdOrders200Ok>> {
            const localVarFetchArgs = MarketApiFetchParamCreator(configuration).getCorporationsCorporationIdOrders(corporationId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List cancelled and expired market orders placed on behalf of a corporation up to 90 days in the past.  --- Alternate route: `/dev/corporations/{corporation_id}/orders/history/`  Alternate route: `/v2/corporations/{corporation_id}/orders/history/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Trader 
         * @summary List historical orders from a corporation
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdOrdersHistory(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationsCorporationIdOrdersHistory200Ok>> {
            const localVarFetchArgs = MarketApiFetchParamCreator(configuration).getCorporationsCorporationIdOrdersHistory(corporationId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of item groups  --- Alternate route: `/dev/markets/groups/`  Alternate route: `/legacy/markets/groups/`  Alternate route: `/v1/markets/groups/`  --- This route expires daily at 11:05
         * @summary Get item groups
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsGroups(datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = MarketApiFetchParamCreator(configuration).getMarketsGroups(datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information on an item group  --- Alternate route: `/dev/markets/groups/{market_group_id}/`  Alternate route: `/legacy/markets/groups/{market_group_id}/`  Alternate route: `/v1/markets/groups/{market_group_id}/`  --- This route expires daily at 11:05
         * @summary Get item group information
         * @param {number} marketGroupId An Eve item group ID
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsGroupsMarketGroupId(marketGroupId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetMarketsGroupsMarketGroupIdOk> {
            const localVarFetchArgs = MarketApiFetchParamCreator(configuration).getMarketsGroupsMarketGroupId(marketGroupId, acceptLanguage, datasource, ifNoneMatch, language, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a list of prices  --- Alternate route: `/dev/markets/prices/`  Alternate route: `/legacy/markets/prices/`  Alternate route: `/v1/markets/prices/`  --- This route is cached for up to 3600 seconds
         * @summary List market prices
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsPrices(datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetMarketsPrices200Ok>> {
            const localVarFetchArgs = MarketApiFetchParamCreator(configuration).getMarketsPrices(datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a list of historical market statistics for the specified type in a region  --- Alternate route: `/dev/markets/{region_id}/history/`  Alternate route: `/legacy/markets/{region_id}/history/`  Alternate route: `/v1/markets/{region_id}/history/`  --- This route expires daily at 11:05
         * @summary List historical market statistics in a region
         * @param {number} regionId Return statistics in this region
         * @param {number} typeId Return statistics for this type
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsRegionIdHistory(regionId: number, typeId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetMarketsRegionIdHistory200Ok>> {
            const localVarFetchArgs = MarketApiFetchParamCreator(configuration).getMarketsRegionIdHistory(regionId, typeId, datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a list of orders in a region  --- Alternate route: `/dev/markets/{region_id}/orders/`  Alternate route: `/legacy/markets/{region_id}/orders/`  Alternate route: `/v1/markets/{region_id}/orders/`  --- This route is cached for up to 300 seconds
         * @summary List orders in a region
         * @param {'buy' | 'sell' | 'all'} orderType Filter buy/sell orders, return all orders by default. If you query without type_id, we always return both buy and sell orders
         * @param {number} regionId Return orders in this region
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {number} [typeId] Return orders only for this type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsRegionIdOrders(orderType: 'buy' | 'sell' | 'all', regionId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, typeId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetMarketsRegionIdOrders200Ok>> {
            const localVarFetchArgs = MarketApiFetchParamCreator(configuration).getMarketsRegionIdOrders(orderType, regionId, datasource, ifNoneMatch, page, typeId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a list of type IDs that have active orders in the region, for efficient market indexing.  --- Alternate route: `/dev/markets/{region_id}/types/`  Alternate route: `/legacy/markets/{region_id}/types/`  Alternate route: `/v1/markets/{region_id}/types/`  --- This route is cached for up to 600 seconds
         * @summary List type IDs relevant to a market
         * @param {number} regionId Return statistics in this region
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsRegionIdTypes(regionId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = MarketApiFetchParamCreator(configuration).getMarketsRegionIdTypes(regionId, datasource, ifNoneMatch, page, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return all orders in a structure  --- Alternate route: `/dev/markets/structures/{structure_id}/`  Alternate route: `/legacy/markets/structures/{structure_id}/`  Alternate route: `/v1/markets/structures/{structure_id}/`  --- This route is cached for up to 300 seconds
         * @summary List orders in a structure
         * @param {number} structureId Return orders in this structure
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsStructuresStructureId(structureId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetMarketsStructuresStructureId200Ok>> {
            const localVarFetchArgs = MarketApiFetchParamCreator(configuration).getMarketsStructuresStructureId(structureId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MarketApi - factory interface
 * @export
 */
export const MarketApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * List open market orders placed by a character  --- Alternate route: `/dev/characters/{character_id}/orders/`  Alternate route: `/v2/characters/{character_id}/orders/`  --- This route is cached for up to 1200 seconds
         * @summary List open orders from a character
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdOrders(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return MarketApiFp(configuration).getCharactersCharacterIdOrders(characterId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * List cancelled and expired market orders placed by a character up to 90 days in the past.  --- Alternate route: `/dev/characters/{character_id}/orders/history/`  Alternate route: `/legacy/characters/{character_id}/orders/history/`  Alternate route: `/v1/characters/{character_id}/orders/history/`  --- This route is cached for up to 3600 seconds
         * @summary List historical orders by a character
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdOrdersHistory(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return MarketApiFp(configuration).getCharactersCharacterIdOrdersHistory(characterId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
        /**
         * List open market orders placed on behalf of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/orders/`  Alternate route: `/v3/corporations/{corporation_id}/orders/`  --- This route is cached for up to 1200 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Trader 
         * @summary List open orders from a corporation
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdOrders(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return MarketApiFp(configuration).getCorporationsCorporationIdOrders(corporationId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
        /**
         * List cancelled and expired market orders placed on behalf of a corporation up to 90 days in the past.  --- Alternate route: `/dev/corporations/{corporation_id}/orders/history/`  Alternate route: `/v2/corporations/{corporation_id}/orders/history/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Trader 
         * @summary List historical orders from a corporation
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdOrdersHistory(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return MarketApiFp(configuration).getCorporationsCorporationIdOrdersHistory(corporationId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
        /**
         * Get a list of item groups  --- Alternate route: `/dev/markets/groups/`  Alternate route: `/legacy/markets/groups/`  Alternate route: `/v1/markets/groups/`  --- This route expires daily at 11:05
         * @summary Get item groups
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsGroups(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return MarketApiFp(configuration).getMarketsGroups(datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Get information on an item group  --- Alternate route: `/dev/markets/groups/{market_group_id}/`  Alternate route: `/legacy/markets/groups/{market_group_id}/`  Alternate route: `/v1/markets/groups/{market_group_id}/`  --- This route expires daily at 11:05
         * @summary Get item group information
         * @param {number} marketGroupId An Eve item group ID
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsGroupsMarketGroupId(marketGroupId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any) {
            return MarketApiFp(configuration).getMarketsGroupsMarketGroupId(marketGroupId, acceptLanguage, datasource, ifNoneMatch, language, options)(fetch, basePath);
        },
        /**
         * Return a list of prices  --- Alternate route: `/dev/markets/prices/`  Alternate route: `/legacy/markets/prices/`  Alternate route: `/v1/markets/prices/`  --- This route is cached for up to 3600 seconds
         * @summary List market prices
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsPrices(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return MarketApiFp(configuration).getMarketsPrices(datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Return a list of historical market statistics for the specified type in a region  --- Alternate route: `/dev/markets/{region_id}/history/`  Alternate route: `/legacy/markets/{region_id}/history/`  Alternate route: `/v1/markets/{region_id}/history/`  --- This route expires daily at 11:05
         * @summary List historical market statistics in a region
         * @param {number} regionId Return statistics in this region
         * @param {number} typeId Return statistics for this type
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsRegionIdHistory(regionId: number, typeId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return MarketApiFp(configuration).getMarketsRegionIdHistory(regionId, typeId, datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Return a list of orders in a region  --- Alternate route: `/dev/markets/{region_id}/orders/`  Alternate route: `/legacy/markets/{region_id}/orders/`  Alternate route: `/v1/markets/{region_id}/orders/`  --- This route is cached for up to 300 seconds
         * @summary List orders in a region
         * @param {'buy' | 'sell' | 'all'} orderType Filter buy/sell orders, return all orders by default. If you query without type_id, we always return both buy and sell orders
         * @param {number} regionId Return orders in this region
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {number} [typeId] Return orders only for this type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsRegionIdOrders(orderType: 'buy' | 'sell' | 'all', regionId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, typeId?: number, options?: any) {
            return MarketApiFp(configuration).getMarketsRegionIdOrders(orderType, regionId, datasource, ifNoneMatch, page, typeId, options)(fetch, basePath);
        },
        /**
         * Return a list of type IDs that have active orders in the region, for efficient market indexing.  --- Alternate route: `/dev/markets/{region_id}/types/`  Alternate route: `/legacy/markets/{region_id}/types/`  Alternate route: `/v1/markets/{region_id}/types/`  --- This route is cached for up to 600 seconds
         * @summary List type IDs relevant to a market
         * @param {number} regionId Return statistics in this region
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsRegionIdTypes(regionId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options?: any) {
            return MarketApiFp(configuration).getMarketsRegionIdTypes(regionId, datasource, ifNoneMatch, page, options)(fetch, basePath);
        },
        /**
         * Return all orders in a structure  --- Alternate route: `/dev/markets/structures/{structure_id}/`  Alternate route: `/legacy/markets/structures/{structure_id}/`  Alternate route: `/v1/markets/structures/{structure_id}/`  --- This route is cached for up to 300 seconds
         * @summary List orders in a structure
         * @param {number} structureId Return orders in this structure
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsStructuresStructureId(structureId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return MarketApiFp(configuration).getMarketsStructuresStructureId(structureId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
    };
};

/**
 * MarketApi - object-oriented interface
 * @export
 * @class MarketApi
 * @extends {BaseAPI}
 */
export class MarketApi extends BaseAPI {
    /**
     * List open market orders placed by a character  --- Alternate route: `/dev/characters/{character_id}/orders/`  Alternate route: `/v2/characters/{character_id}/orders/`  --- This route is cached for up to 1200 seconds
     * @summary List open orders from a character
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public getCharactersCharacterIdOrders(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return MarketApiFp(this.configuration).getCharactersCharacterIdOrders(characterId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * List cancelled and expired market orders placed by a character up to 90 days in the past.  --- Alternate route: `/dev/characters/{character_id}/orders/history/`  Alternate route: `/legacy/characters/{character_id}/orders/history/`  Alternate route: `/v1/characters/{character_id}/orders/history/`  --- This route is cached for up to 3600 seconds
     * @summary List historical orders by a character
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public getCharactersCharacterIdOrdersHistory(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return MarketApiFp(this.configuration).getCharactersCharacterIdOrdersHistory(characterId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * List open market orders placed on behalf of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/orders/`  Alternate route: `/v3/corporations/{corporation_id}/orders/`  --- This route is cached for up to 1200 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Trader 
     * @summary List open orders from a corporation
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public getCorporationsCorporationIdOrders(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return MarketApiFp(this.configuration).getCorporationsCorporationIdOrders(corporationId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * List cancelled and expired market orders placed on behalf of a corporation up to 90 days in the past.  --- Alternate route: `/dev/corporations/{corporation_id}/orders/history/`  Alternate route: `/v2/corporations/{corporation_id}/orders/history/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Trader 
     * @summary List historical orders from a corporation
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public getCorporationsCorporationIdOrdersHistory(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return MarketApiFp(this.configuration).getCorporationsCorporationIdOrdersHistory(corporationId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of item groups  --- Alternate route: `/dev/markets/groups/`  Alternate route: `/legacy/markets/groups/`  Alternate route: `/v1/markets/groups/`  --- This route expires daily at 11:05
     * @summary Get item groups
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public getMarketsGroups(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return MarketApiFp(this.configuration).getMarketsGroups(datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Get information on an item group  --- Alternate route: `/dev/markets/groups/{market_group_id}/`  Alternate route: `/legacy/markets/groups/{market_group_id}/`  Alternate route: `/v1/markets/groups/{market_group_id}/`  --- This route expires daily at 11:05
     * @summary Get item group information
     * @param {number} marketGroupId An Eve item group ID
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public getMarketsGroupsMarketGroupId(marketGroupId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any) {
        return MarketApiFp(this.configuration).getMarketsGroupsMarketGroupId(marketGroupId, acceptLanguage, datasource, ifNoneMatch, language, options)(this.fetch, this.basePath);
    }

    /**
     * Return a list of prices  --- Alternate route: `/dev/markets/prices/`  Alternate route: `/legacy/markets/prices/`  Alternate route: `/v1/markets/prices/`  --- This route is cached for up to 3600 seconds
     * @summary List market prices
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public getMarketsPrices(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return MarketApiFp(this.configuration).getMarketsPrices(datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Return a list of historical market statistics for the specified type in a region  --- Alternate route: `/dev/markets/{region_id}/history/`  Alternate route: `/legacy/markets/{region_id}/history/`  Alternate route: `/v1/markets/{region_id}/history/`  --- This route expires daily at 11:05
     * @summary List historical market statistics in a region
     * @param {number} regionId Return statistics in this region
     * @param {number} typeId Return statistics for this type
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public getMarketsRegionIdHistory(regionId: number, typeId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return MarketApiFp(this.configuration).getMarketsRegionIdHistory(regionId, typeId, datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Return a list of orders in a region  --- Alternate route: `/dev/markets/{region_id}/orders/`  Alternate route: `/legacy/markets/{region_id}/orders/`  Alternate route: `/v1/markets/{region_id}/orders/`  --- This route is cached for up to 300 seconds
     * @summary List orders in a region
     * @param {'buy' | 'sell' | 'all'} orderType Filter buy/sell orders, return all orders by default. If you query without type_id, we always return both buy and sell orders
     * @param {number} regionId Return orders in this region
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {number} [typeId] Return orders only for this type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public getMarketsRegionIdOrders(orderType: 'buy' | 'sell' | 'all', regionId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, typeId?: number, options?: any) {
        return MarketApiFp(this.configuration).getMarketsRegionIdOrders(orderType, regionId, datasource, ifNoneMatch, page, typeId, options)(this.fetch, this.basePath);
    }

    /**
     * Return a list of type IDs that have active orders in the region, for efficient market indexing.  --- Alternate route: `/dev/markets/{region_id}/types/`  Alternate route: `/legacy/markets/{region_id}/types/`  Alternate route: `/v1/markets/{region_id}/types/`  --- This route is cached for up to 600 seconds
     * @summary List type IDs relevant to a market
     * @param {number} regionId Return statistics in this region
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public getMarketsRegionIdTypes(regionId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options?: any) {
        return MarketApiFp(this.configuration).getMarketsRegionIdTypes(regionId, datasource, ifNoneMatch, page, options)(this.fetch, this.basePath);
    }

    /**
     * Return all orders in a structure  --- Alternate route: `/dev/markets/structures/{structure_id}/`  Alternate route: `/legacy/markets/structures/{structure_id}/`  Alternate route: `/v1/markets/structures/{structure_id}/`  --- This route is cached for up to 300 seconds
     * @summary List orders in a structure
     * @param {number} structureId Return orders in this structure
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApi
     */
    public getMarketsStructuresStructureId(structureId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return MarketApiFp(this.configuration).getMarketsStructuresStructureId(structureId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

}

/**
 * OpportunitiesApi - fetch parameter creator
 * @export
 */
export const OpportunitiesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return a list of tasks finished by a character  --- Alternate route: `/dev/characters/{character_id}/opportunities/`  Alternate route: `/legacy/characters/{character_id}/opportunities/`  Alternate route: `/v1/characters/{character_id}/opportunities/`  --- This route is cached for up to 3600 seconds
         * @summary Get a character's completed tasks
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdOpportunities(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdOpportunities.');
            }
            const localVarPath = `/characters/{character_id}/opportunities/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-characters.read_opportunities.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of opportunities groups  --- Alternate route: `/dev/opportunities/groups/`  Alternate route: `/legacy/opportunities/groups/`  Alternate route: `/v1/opportunities/groups/`  --- This route expires daily at 11:05
         * @summary Get opportunities groups
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpportunitiesGroups(datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            const localVarPath = `/opportunities/groups/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return information of an opportunities group  --- Alternate route: `/dev/opportunities/groups/{group_id}/`  Alternate route: `/legacy/opportunities/groups/{group_id}/`  Alternate route: `/v1/opportunities/groups/{group_id}/`  --- This route expires daily at 11:05
         * @summary Get opportunities group
         * @param {number} groupId ID of an opportunities group
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpportunitiesGroupsGroupId(groupId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options: any = {}): FetchArgs {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling getOpportunitiesGroupsGroupId.');
            }
            const localVarPath = `/opportunities/groups/{group_id}/`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of opportunities tasks  --- Alternate route: `/dev/opportunities/tasks/`  Alternate route: `/legacy/opportunities/tasks/`  Alternate route: `/v1/opportunities/tasks/`  --- This route expires daily at 11:05
         * @summary Get opportunities tasks
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpportunitiesTasks(datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            const localVarPath = `/opportunities/tasks/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return information of an opportunities task  --- Alternate route: `/dev/opportunities/tasks/{task_id}/`  Alternate route: `/legacy/opportunities/tasks/{task_id}/`  Alternate route: `/v1/opportunities/tasks/{task_id}/`  --- This route expires daily at 11:05
         * @summary Get opportunities task
         * @param {number} taskId ID of an opportunities task
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpportunitiesTasksTaskId(taskId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling getOpportunitiesTasksTaskId.');
            }
            const localVarPath = `/opportunities/tasks/{task_id}/`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OpportunitiesApi - functional programming interface
 * @export
 */
export const OpportunitiesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Return a list of tasks finished by a character  --- Alternate route: `/dev/characters/{character_id}/opportunities/`  Alternate route: `/legacy/characters/{character_id}/opportunities/`  Alternate route: `/v1/characters/{character_id}/opportunities/`  --- This route is cached for up to 3600 seconds
         * @summary Get a character's completed tasks
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdOpportunities(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCharactersCharacterIdOpportunities200Ok>> {
            const localVarFetchArgs = OpportunitiesApiFetchParamCreator(configuration).getCharactersCharacterIdOpportunities(characterId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a list of opportunities groups  --- Alternate route: `/dev/opportunities/groups/`  Alternate route: `/legacy/opportunities/groups/`  Alternate route: `/v1/opportunities/groups/`  --- This route expires daily at 11:05
         * @summary Get opportunities groups
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpportunitiesGroups(datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = OpportunitiesApiFetchParamCreator(configuration).getOpportunitiesGroups(datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return information of an opportunities group  --- Alternate route: `/dev/opportunities/groups/{group_id}/`  Alternate route: `/legacy/opportunities/groups/{group_id}/`  Alternate route: `/v1/opportunities/groups/{group_id}/`  --- This route expires daily at 11:05
         * @summary Get opportunities group
         * @param {number} groupId ID of an opportunities group
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpportunitiesGroupsGroupId(groupId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetOpportunitiesGroupsGroupIdOk> {
            const localVarFetchArgs = OpportunitiesApiFetchParamCreator(configuration).getOpportunitiesGroupsGroupId(groupId, acceptLanguage, datasource, ifNoneMatch, language, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a list of opportunities tasks  --- Alternate route: `/dev/opportunities/tasks/`  Alternate route: `/legacy/opportunities/tasks/`  Alternate route: `/v1/opportunities/tasks/`  --- This route expires daily at 11:05
         * @summary Get opportunities tasks
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpportunitiesTasks(datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = OpportunitiesApiFetchParamCreator(configuration).getOpportunitiesTasks(datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return information of an opportunities task  --- Alternate route: `/dev/opportunities/tasks/{task_id}/`  Alternate route: `/legacy/opportunities/tasks/{task_id}/`  Alternate route: `/v1/opportunities/tasks/{task_id}/`  --- This route expires daily at 11:05
         * @summary Get opportunities task
         * @param {number} taskId ID of an opportunities task
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpportunitiesTasksTaskId(taskId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetOpportunitiesTasksTaskIdOk> {
            const localVarFetchArgs = OpportunitiesApiFetchParamCreator(configuration).getOpportunitiesTasksTaskId(taskId, datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OpportunitiesApi - factory interface
 * @export
 */
export const OpportunitiesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Return a list of tasks finished by a character  --- Alternate route: `/dev/characters/{character_id}/opportunities/`  Alternate route: `/legacy/characters/{character_id}/opportunities/`  Alternate route: `/v1/characters/{character_id}/opportunities/`  --- This route is cached for up to 3600 seconds
         * @summary Get a character's completed tasks
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdOpportunities(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return OpportunitiesApiFp(configuration).getCharactersCharacterIdOpportunities(characterId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Return a list of opportunities groups  --- Alternate route: `/dev/opportunities/groups/`  Alternate route: `/legacy/opportunities/groups/`  Alternate route: `/v1/opportunities/groups/`  --- This route expires daily at 11:05
         * @summary Get opportunities groups
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpportunitiesGroups(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return OpportunitiesApiFp(configuration).getOpportunitiesGroups(datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Return information of an opportunities group  --- Alternate route: `/dev/opportunities/groups/{group_id}/`  Alternate route: `/legacy/opportunities/groups/{group_id}/`  Alternate route: `/v1/opportunities/groups/{group_id}/`  --- This route expires daily at 11:05
         * @summary Get opportunities group
         * @param {number} groupId ID of an opportunities group
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpportunitiesGroupsGroupId(groupId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any) {
            return OpportunitiesApiFp(configuration).getOpportunitiesGroupsGroupId(groupId, acceptLanguage, datasource, ifNoneMatch, language, options)(fetch, basePath);
        },
        /**
         * Return a list of opportunities tasks  --- Alternate route: `/dev/opportunities/tasks/`  Alternate route: `/legacy/opportunities/tasks/`  Alternate route: `/v1/opportunities/tasks/`  --- This route expires daily at 11:05
         * @summary Get opportunities tasks
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpportunitiesTasks(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return OpportunitiesApiFp(configuration).getOpportunitiesTasks(datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Return information of an opportunities task  --- Alternate route: `/dev/opportunities/tasks/{task_id}/`  Alternate route: `/legacy/opportunities/tasks/{task_id}/`  Alternate route: `/v1/opportunities/tasks/{task_id}/`  --- This route expires daily at 11:05
         * @summary Get opportunities task
         * @param {number} taskId ID of an opportunities task
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpportunitiesTasksTaskId(taskId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return OpportunitiesApiFp(configuration).getOpportunitiesTasksTaskId(taskId, datasource, ifNoneMatch, options)(fetch, basePath);
        },
    };
};

/**
 * OpportunitiesApi - object-oriented interface
 * @export
 * @class OpportunitiesApi
 * @extends {BaseAPI}
 */
export class OpportunitiesApi extends BaseAPI {
    /**
     * Return a list of tasks finished by a character  --- Alternate route: `/dev/characters/{character_id}/opportunities/`  Alternate route: `/legacy/characters/{character_id}/opportunities/`  Alternate route: `/v1/characters/{character_id}/opportunities/`  --- This route is cached for up to 3600 seconds
     * @summary Get a character's completed tasks
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpportunitiesApi
     */
    public getCharactersCharacterIdOpportunities(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return OpportunitiesApiFp(this.configuration).getCharactersCharacterIdOpportunities(characterId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Return a list of opportunities groups  --- Alternate route: `/dev/opportunities/groups/`  Alternate route: `/legacy/opportunities/groups/`  Alternate route: `/v1/opportunities/groups/`  --- This route expires daily at 11:05
     * @summary Get opportunities groups
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpportunitiesApi
     */
    public getOpportunitiesGroups(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return OpportunitiesApiFp(this.configuration).getOpportunitiesGroups(datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Return information of an opportunities group  --- Alternate route: `/dev/opportunities/groups/{group_id}/`  Alternate route: `/legacy/opportunities/groups/{group_id}/`  Alternate route: `/v1/opportunities/groups/{group_id}/`  --- This route expires daily at 11:05
     * @summary Get opportunities group
     * @param {number} groupId ID of an opportunities group
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpportunitiesApi
     */
    public getOpportunitiesGroupsGroupId(groupId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any) {
        return OpportunitiesApiFp(this.configuration).getOpportunitiesGroupsGroupId(groupId, acceptLanguage, datasource, ifNoneMatch, language, options)(this.fetch, this.basePath);
    }

    /**
     * Return a list of opportunities tasks  --- Alternate route: `/dev/opportunities/tasks/`  Alternate route: `/legacy/opportunities/tasks/`  Alternate route: `/v1/opportunities/tasks/`  --- This route expires daily at 11:05
     * @summary Get opportunities tasks
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpportunitiesApi
     */
    public getOpportunitiesTasks(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return OpportunitiesApiFp(this.configuration).getOpportunitiesTasks(datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Return information of an opportunities task  --- Alternate route: `/dev/opportunities/tasks/{task_id}/`  Alternate route: `/legacy/opportunities/tasks/{task_id}/`  Alternate route: `/v1/opportunities/tasks/{task_id}/`  --- This route expires daily at 11:05
     * @summary Get opportunities task
     * @param {number} taskId ID of an opportunities task
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpportunitiesApi
     */
    public getOpportunitiesTasksTaskId(taskId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return OpportunitiesApiFp(this.configuration).getOpportunitiesTasksTaskId(taskId, datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

}

/**
 * PlanetaryInteractionApi - fetch parameter creator
 * @export
 */
export const PlanetaryInteractionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of all planetary colonies owned by a character.  --- Alternate route: `/dev/characters/{character_id}/planets/`  Alternate route: `/legacy/characters/{character_id}/planets/`  Alternate route: `/v1/characters/{character_id}/planets/`  --- This route is cached for up to 600 seconds
         * @summary Get colonies
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdPlanets(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdPlanets.');
            }
            const localVarPath = `/characters/{character_id}/planets/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-planets.manage_planets.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns full details on the layout of a single planetary colony, including links, pins and routes. Note: Planetary information is only recalculated when the colony is viewed through the client. Information will not update until this criteria is met.  --- Alternate route: `/dev/characters/{character_id}/planets/{planet_id}/`  Alternate route: `/v3/characters/{character_id}/planets/{planet_id}/` 
         * @summary Get colony layout
         * @param {number} characterId An EVE character ID
         * @param {number} planetId Planet id of the target planet
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdPlanetsPlanetId(characterId: number, planetId: number, datasource?: 'tranquility', token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdPlanetsPlanetId.');
            }
            // verify required parameter 'planetId' is not null or undefined
            if (planetId === null || planetId === undefined) {
                throw new RequiredError('planetId','Required parameter planetId was null or undefined when calling getCharactersCharacterIdPlanetsPlanetId.');
            }
            const localVarPath = `/characters/{character_id}/planets/{planet_id}/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)))
                .replace(`{${"planet_id"}}`, encodeURIComponent(String(planetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-planets.manage_planets.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List customs offices owned by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/customs_offices/`  Alternate route: `/legacy/corporations/{corporation_id}/customs_offices/`  Alternate route: `/v1/corporations/{corporation_id}/customs_offices/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary List corporation customs offices
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdCustomsOffices(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdCustomsOffices.');
            }
            const localVarPath = `/corporations/{corporation_id}/customs_offices/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-planets.read_customs_offices.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on a planetary factory schematic  --- Alternate route: `/dev/universe/schematics/{schematic_id}/`  Alternate route: `/legacy/universe/schematics/{schematic_id}/`  Alternate route: `/v1/universe/schematics/{schematic_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get schematic information
         * @param {number} schematicId A PI schematic ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseSchematicsSchematicId(schematicId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'schematicId' is not null or undefined
            if (schematicId === null || schematicId === undefined) {
                throw new RequiredError('schematicId','Required parameter schematicId was null or undefined when calling getUniverseSchematicsSchematicId.');
            }
            const localVarPath = `/universe/schematics/{schematic_id}/`
                .replace(`{${"schematic_id"}}`, encodeURIComponent(String(schematicId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlanetaryInteractionApi - functional programming interface
 * @export
 */
export const PlanetaryInteractionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a list of all planetary colonies owned by a character.  --- Alternate route: `/dev/characters/{character_id}/planets/`  Alternate route: `/legacy/characters/{character_id}/planets/`  Alternate route: `/v1/characters/{character_id}/planets/`  --- This route is cached for up to 600 seconds
         * @summary Get colonies
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdPlanets(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCharactersCharacterIdPlanets200Ok>> {
            const localVarFetchArgs = PlanetaryInteractionApiFetchParamCreator(configuration).getCharactersCharacterIdPlanets(characterId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns full details on the layout of a single planetary colony, including links, pins and routes. Note: Planetary information is only recalculated when the colony is viewed through the client. Information will not update until this criteria is met.  --- Alternate route: `/dev/characters/{character_id}/planets/{planet_id}/`  Alternate route: `/v3/characters/{character_id}/planets/{planet_id}/` 
         * @summary Get colony layout
         * @param {number} characterId An EVE character ID
         * @param {number} planetId Planet id of the target planet
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdPlanetsPlanetId(characterId: number, planetId: number, datasource?: 'tranquility', token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCharactersCharacterIdPlanetsPlanetIdOk> {
            const localVarFetchArgs = PlanetaryInteractionApiFetchParamCreator(configuration).getCharactersCharacterIdPlanetsPlanetId(characterId, planetId, datasource, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List customs offices owned by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/customs_offices/`  Alternate route: `/legacy/corporations/{corporation_id}/customs_offices/`  Alternate route: `/v1/corporations/{corporation_id}/customs_offices/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary List corporation customs offices
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdCustomsOffices(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationsCorporationIdCustomsOffices200Ok>> {
            const localVarFetchArgs = PlanetaryInteractionApiFetchParamCreator(configuration).getCorporationsCorporationIdCustomsOffices(corporationId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information on a planetary factory schematic  --- Alternate route: `/dev/universe/schematics/{schematic_id}/`  Alternate route: `/legacy/universe/schematics/{schematic_id}/`  Alternate route: `/v1/universe/schematics/{schematic_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get schematic information
         * @param {number} schematicId A PI schematic ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseSchematicsSchematicId(schematicId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetUniverseSchematicsSchematicIdOk> {
            const localVarFetchArgs = PlanetaryInteractionApiFetchParamCreator(configuration).getUniverseSchematicsSchematicId(schematicId, datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PlanetaryInteractionApi - factory interface
 * @export
 */
export const PlanetaryInteractionApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns a list of all planetary colonies owned by a character.  --- Alternate route: `/dev/characters/{character_id}/planets/`  Alternate route: `/legacy/characters/{character_id}/planets/`  Alternate route: `/v1/characters/{character_id}/planets/`  --- This route is cached for up to 600 seconds
         * @summary Get colonies
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdPlanets(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return PlanetaryInteractionApiFp(configuration).getCharactersCharacterIdPlanets(characterId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Returns full details on the layout of a single planetary colony, including links, pins and routes. Note: Planetary information is only recalculated when the colony is viewed through the client. Information will not update until this criteria is met.  --- Alternate route: `/dev/characters/{character_id}/planets/{planet_id}/`  Alternate route: `/v3/characters/{character_id}/planets/{planet_id}/` 
         * @summary Get colony layout
         * @param {number} characterId An EVE character ID
         * @param {number} planetId Planet id of the target planet
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdPlanetsPlanetId(characterId: number, planetId: number, datasource?: 'tranquility', token?: string, options?: any) {
            return PlanetaryInteractionApiFp(configuration).getCharactersCharacterIdPlanetsPlanetId(characterId, planetId, datasource, token, options)(fetch, basePath);
        },
        /**
         * List customs offices owned by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/customs_offices/`  Alternate route: `/legacy/corporations/{corporation_id}/customs_offices/`  Alternate route: `/v1/corporations/{corporation_id}/customs_offices/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary List corporation customs offices
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdCustomsOffices(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return PlanetaryInteractionApiFp(configuration).getCorporationsCorporationIdCustomsOffices(corporationId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
        /**
         * Get information on a planetary factory schematic  --- Alternate route: `/dev/universe/schematics/{schematic_id}/`  Alternate route: `/legacy/universe/schematics/{schematic_id}/`  Alternate route: `/v1/universe/schematics/{schematic_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get schematic information
         * @param {number} schematicId A PI schematic ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseSchematicsSchematicId(schematicId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return PlanetaryInteractionApiFp(configuration).getUniverseSchematicsSchematicId(schematicId, datasource, ifNoneMatch, options)(fetch, basePath);
        },
    };
};

/**
 * PlanetaryInteractionApi - object-oriented interface
 * @export
 * @class PlanetaryInteractionApi
 * @extends {BaseAPI}
 */
export class PlanetaryInteractionApi extends BaseAPI {
    /**
     * Returns a list of all planetary colonies owned by a character.  --- Alternate route: `/dev/characters/{character_id}/planets/`  Alternate route: `/legacy/characters/{character_id}/planets/`  Alternate route: `/v1/characters/{character_id}/planets/`  --- This route is cached for up to 600 seconds
     * @summary Get colonies
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanetaryInteractionApi
     */
    public getCharactersCharacterIdPlanets(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return PlanetaryInteractionApiFp(this.configuration).getCharactersCharacterIdPlanets(characterId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Returns full details on the layout of a single planetary colony, including links, pins and routes. Note: Planetary information is only recalculated when the colony is viewed through the client. Information will not update until this criteria is met.  --- Alternate route: `/dev/characters/{character_id}/planets/{planet_id}/`  Alternate route: `/v3/characters/{character_id}/planets/{planet_id}/` 
     * @summary Get colony layout
     * @param {number} characterId An EVE character ID
     * @param {number} planetId Planet id of the target planet
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanetaryInteractionApi
     */
    public getCharactersCharacterIdPlanetsPlanetId(characterId: number, planetId: number, datasource?: 'tranquility', token?: string, options?: any) {
        return PlanetaryInteractionApiFp(this.configuration).getCharactersCharacterIdPlanetsPlanetId(characterId, planetId, datasource, token, options)(this.fetch, this.basePath);
    }

    /**
     * List customs offices owned by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/customs_offices/`  Alternate route: `/legacy/corporations/{corporation_id}/customs_offices/`  Alternate route: `/v1/corporations/{corporation_id}/customs_offices/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary List corporation customs offices
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanetaryInteractionApi
     */
    public getCorporationsCorporationIdCustomsOffices(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return PlanetaryInteractionApiFp(this.configuration).getCorporationsCorporationIdCustomsOffices(corporationId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * Get information on a planetary factory schematic  --- Alternate route: `/dev/universe/schematics/{schematic_id}/`  Alternate route: `/legacy/universe/schematics/{schematic_id}/`  Alternate route: `/v1/universe/schematics/{schematic_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get schematic information
     * @param {number} schematicId A PI schematic ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanetaryInteractionApi
     */
    public getUniverseSchematicsSchematicId(schematicId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return PlanetaryInteractionApiFp(this.configuration).getUniverseSchematicsSchematicId(schematicId, datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

}

/**
 * RoutesApi - fetch parameter creator
 * @export
 */
export const RoutesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the systems between origin and destination  --- Alternate route: `/dev/route/{origin}/{destination}/`  Alternate route: `/legacy/route/{origin}/{destination}/`  Alternate route: `/v1/route/{origin}/{destination}/`  --- This route is cached for up to 86400 seconds
         * @summary Get route
         * @param {number} destination destination solar system ID
         * @param {number} origin origin solar system ID
         * @param {Array<number>} [avoid] avoid solar system ID(s)
         * @param {Array<Array<number>>} [connections] connected solar system pairs
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {'shortest' | 'secure' | 'insecure'} [flag] route security preference
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteOriginDestination(destination: number, origin: number, avoid?: Array<number>, connections?: Array<Array<number>>, datasource?: 'tranquility', flag?: 'shortest' | 'secure' | 'insecure', ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'destination' is not null or undefined
            if (destination === null || destination === undefined) {
                throw new RequiredError('destination','Required parameter destination was null or undefined when calling getRouteOriginDestination.');
            }
            // verify required parameter 'origin' is not null or undefined
            if (origin === null || origin === undefined) {
                throw new RequiredError('origin','Required parameter origin was null or undefined when calling getRouteOriginDestination.');
            }
            const localVarPath = `/route/{origin}/{destination}/`
                .replace(`{${"destination"}}`, encodeURIComponent(String(destination)))
                .replace(`{${"origin"}}`, encodeURIComponent(String(origin)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (avoid) {
                localVarQueryParameter['avoid'] = avoid;
            }

            if (connections) {
                localVarQueryParameter['connections'] = connections;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (flag !== undefined) {
                localVarQueryParameter['flag'] = flag;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoutesApi - functional programming interface
 * @export
 */
export const RoutesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get the systems between origin and destination  --- Alternate route: `/dev/route/{origin}/{destination}/`  Alternate route: `/legacy/route/{origin}/{destination}/`  Alternate route: `/v1/route/{origin}/{destination}/`  --- This route is cached for up to 86400 seconds
         * @summary Get route
         * @param {number} destination destination solar system ID
         * @param {number} origin origin solar system ID
         * @param {Array<number>} [avoid] avoid solar system ID(s)
         * @param {Array<Array<number>>} [connections] connected solar system pairs
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {'shortest' | 'secure' | 'insecure'} [flag] route security preference
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteOriginDestination(destination: number, origin: number, avoid?: Array<number>, connections?: Array<Array<number>>, datasource?: 'tranquility', flag?: 'shortest' | 'secure' | 'insecure', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = RoutesApiFetchParamCreator(configuration).getRouteOriginDestination(destination, origin, avoid, connections, datasource, flag, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RoutesApi - factory interface
 * @export
 */
export const RoutesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get the systems between origin and destination  --- Alternate route: `/dev/route/{origin}/{destination}/`  Alternate route: `/legacy/route/{origin}/{destination}/`  Alternate route: `/v1/route/{origin}/{destination}/`  --- This route is cached for up to 86400 seconds
         * @summary Get route
         * @param {number} destination destination solar system ID
         * @param {number} origin origin solar system ID
         * @param {Array<number>} [avoid] avoid solar system ID(s)
         * @param {Array<Array<number>>} [connections] connected solar system pairs
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {'shortest' | 'secure' | 'insecure'} [flag] route security preference
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteOriginDestination(destination: number, origin: number, avoid?: Array<number>, connections?: Array<Array<number>>, datasource?: 'tranquility', flag?: 'shortest' | 'secure' | 'insecure', ifNoneMatch?: string, options?: any) {
            return RoutesApiFp(configuration).getRouteOriginDestination(destination, origin, avoid, connections, datasource, flag, ifNoneMatch, options)(fetch, basePath);
        },
    };
};

/**
 * RoutesApi - object-oriented interface
 * @export
 * @class RoutesApi
 * @extends {BaseAPI}
 */
export class RoutesApi extends BaseAPI {
    /**
     * Get the systems between origin and destination  --- Alternate route: `/dev/route/{origin}/{destination}/`  Alternate route: `/legacy/route/{origin}/{destination}/`  Alternate route: `/v1/route/{origin}/{destination}/`  --- This route is cached for up to 86400 seconds
     * @summary Get route
     * @param {number} destination destination solar system ID
     * @param {number} origin origin solar system ID
     * @param {Array<number>} [avoid] avoid solar system ID(s)
     * @param {Array<Array<number>>} [connections] connected solar system pairs
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {'shortest' | 'secure' | 'insecure'} [flag] route security preference
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutesApi
     */
    public getRouteOriginDestination(destination: number, origin: number, avoid?: Array<number>, connections?: Array<Array<number>>, datasource?: 'tranquility', flag?: 'shortest' | 'secure' | 'insecure', ifNoneMatch?: string, options?: any) {
        return RoutesApiFp(this.configuration).getRouteOriginDestination(destination, origin, avoid, connections, datasource, flag, ifNoneMatch, options)(this.fetch, this.basePath);
    }

}

/**
 * SearchApi - fetch parameter creator
 * @export
 */
export const SearchApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Search for entities that match a given sub-string.  --- Alternate route: `/dev/characters/{character_id}/search/`  Alternate route: `/legacy/characters/{character_id}/search/`  Alternate route: `/v3/characters/{character_id}/search/`  --- This route is cached for up to 3600 seconds
         * @summary Search on a string
         * @param {Array<'agent' | 'alliance' | 'character' | 'constellation' | 'corporation' | 'faction' | 'inventory_type' | 'region' | 'solar_system' | 'station' | 'structure'>} categories Type of entities to search for
         * @param {number} characterId An EVE character ID
         * @param {string} search The string to search on
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {boolean} [strict] Whether the search should be a strict match
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdSearch(categories: Array<'agent' | 'alliance' | 'character' | 'constellation' | 'corporation' | 'faction' | 'inventory_type' | 'region' | 'solar_system' | 'station' | 'structure'>, characterId: number, search: string, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', strict?: boolean, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'categories' is not null or undefined
            if (categories === null || categories === undefined) {
                throw new RequiredError('categories','Required parameter categories was null or undefined when calling getCharactersCharacterIdSearch.');
            }
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdSearch.');
            }
            // verify required parameter 'search' is not null or undefined
            if (search === null || search === undefined) {
                throw new RequiredError('search','Required parameter search was null or undefined when calling getCharactersCharacterIdSearch.');
            }
            const localVarPath = `/characters/{character_id}/search/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-search.search_structures.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (categories) {
                localVarQueryParameter['categories'] = categories;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (strict !== undefined) {
                localVarQueryParameter['strict'] = strict;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Search for entities that match a given sub-string.  --- Alternate route: `/dev/characters/{character_id}/search/`  Alternate route: `/legacy/characters/{character_id}/search/`  Alternate route: `/v3/characters/{character_id}/search/`  --- This route is cached for up to 3600 seconds
         * @summary Search on a string
         * @param {Array<'agent' | 'alliance' | 'character' | 'constellation' | 'corporation' | 'faction' | 'inventory_type' | 'region' | 'solar_system' | 'station' | 'structure'>} categories Type of entities to search for
         * @param {number} characterId An EVE character ID
         * @param {string} search The string to search on
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {boolean} [strict] Whether the search should be a strict match
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdSearch(categories: Array<'agent' | 'alliance' | 'character' | 'constellation' | 'corporation' | 'faction' | 'inventory_type' | 'region' | 'solar_system' | 'station' | 'structure'>, characterId: number, search: string, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', strict?: boolean, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCharactersCharacterIdSearchOk> {
            const localVarFetchArgs = SearchApiFetchParamCreator(configuration).getCharactersCharacterIdSearch(categories, characterId, search, acceptLanguage, datasource, ifNoneMatch, language, strict, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Search for entities that match a given sub-string.  --- Alternate route: `/dev/characters/{character_id}/search/`  Alternate route: `/legacy/characters/{character_id}/search/`  Alternate route: `/v3/characters/{character_id}/search/`  --- This route is cached for up to 3600 seconds
         * @summary Search on a string
         * @param {Array<'agent' | 'alliance' | 'character' | 'constellation' | 'corporation' | 'faction' | 'inventory_type' | 'region' | 'solar_system' | 'station' | 'structure'>} categories Type of entities to search for
         * @param {number} characterId An EVE character ID
         * @param {string} search The string to search on
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {boolean} [strict] Whether the search should be a strict match
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdSearch(categories: Array<'agent' | 'alliance' | 'character' | 'constellation' | 'corporation' | 'faction' | 'inventory_type' | 'region' | 'solar_system' | 'station' | 'structure'>, characterId: number, search: string, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', strict?: boolean, token?: string, options?: any) {
            return SearchApiFp(configuration).getCharactersCharacterIdSearch(categories, characterId, search, acceptLanguage, datasource, ifNoneMatch, language, strict, token, options)(fetch, basePath);
        },
    };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * Search for entities that match a given sub-string.  --- Alternate route: `/dev/characters/{character_id}/search/`  Alternate route: `/legacy/characters/{character_id}/search/`  Alternate route: `/v3/characters/{character_id}/search/`  --- This route is cached for up to 3600 seconds
     * @summary Search on a string
     * @param {Array<'agent' | 'alliance' | 'character' | 'constellation' | 'corporation' | 'faction' | 'inventory_type' | 'region' | 'solar_system' | 'station' | 'structure'>} categories Type of entities to search for
     * @param {number} characterId An EVE character ID
     * @param {string} search The string to search on
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {boolean} [strict] Whether the search should be a strict match
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public getCharactersCharacterIdSearch(categories: Array<'agent' | 'alliance' | 'character' | 'constellation' | 'corporation' | 'faction' | 'inventory_type' | 'region' | 'solar_system' | 'station' | 'structure'>, characterId: number, search: string, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', strict?: boolean, token?: string, options?: any) {
        return SearchApiFp(this.configuration).getCharactersCharacterIdSearch(categories, characterId, search, acceptLanguage, datasource, ifNoneMatch, language, strict, token, options)(this.fetch, this.basePath);
    }

}

/**
 * SkillsApi - fetch parameter creator
 * @export
 */
export const SkillsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return attributes of a character  --- Alternate route: `/dev/characters/{character_id}/attributes/`  Alternate route: `/legacy/characters/{character_id}/attributes/`  Alternate route: `/v1/characters/{character_id}/attributes/`  --- This route is cached for up to 120 seconds
         * @summary Get character attributes
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdAttributes(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdAttributes.');
            }
            const localVarPath = `/characters/{character_id}/attributes/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-skills.read_skills.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the configured skill queue for the given character  --- Alternate route: `/dev/characters/{character_id}/skillqueue/`  Alternate route: `/legacy/characters/{character_id}/skillqueue/`  Alternate route: `/v2/characters/{character_id}/skillqueue/`  --- This route is cached for up to 120 seconds
         * @summary Get character's skill queue
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdSkillqueue(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdSkillqueue.');
            }
            const localVarPath = `/characters/{character_id}/skillqueue/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-skills.read_skillqueue.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all trained skills for the given character  --- Alternate route: `/dev/characters/{character_id}/skills/`  Alternate route: `/v4/characters/{character_id}/skills/`  --- This route is cached for up to 120 seconds
         * @summary Get character skills
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdSkills(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdSkills.');
            }
            const localVarPath = `/characters/{character_id}/skills/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-skills.read_skills.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SkillsApi - functional programming interface
 * @export
 */
export const SkillsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Return attributes of a character  --- Alternate route: `/dev/characters/{character_id}/attributes/`  Alternate route: `/legacy/characters/{character_id}/attributes/`  Alternate route: `/v1/characters/{character_id}/attributes/`  --- This route is cached for up to 120 seconds
         * @summary Get character attributes
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdAttributes(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCharactersCharacterIdAttributesOk> {
            const localVarFetchArgs = SkillsApiFetchParamCreator(configuration).getCharactersCharacterIdAttributes(characterId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List the configured skill queue for the given character  --- Alternate route: `/dev/characters/{character_id}/skillqueue/`  Alternate route: `/legacy/characters/{character_id}/skillqueue/`  Alternate route: `/v2/characters/{character_id}/skillqueue/`  --- This route is cached for up to 120 seconds
         * @summary Get character's skill queue
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdSkillqueue(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCharactersCharacterIdSkillqueue200Ok>> {
            const localVarFetchArgs = SkillsApiFetchParamCreator(configuration).getCharactersCharacterIdSkillqueue(characterId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all trained skills for the given character  --- Alternate route: `/dev/characters/{character_id}/skills/`  Alternate route: `/v4/characters/{character_id}/skills/`  --- This route is cached for up to 120 seconds
         * @summary Get character skills
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdSkills(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCharactersCharacterIdSkillsOk> {
            const localVarFetchArgs = SkillsApiFetchParamCreator(configuration).getCharactersCharacterIdSkills(characterId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SkillsApi - factory interface
 * @export
 */
export const SkillsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Return attributes of a character  --- Alternate route: `/dev/characters/{character_id}/attributes/`  Alternate route: `/legacy/characters/{character_id}/attributes/`  Alternate route: `/v1/characters/{character_id}/attributes/`  --- This route is cached for up to 120 seconds
         * @summary Get character attributes
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdAttributes(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return SkillsApiFp(configuration).getCharactersCharacterIdAttributes(characterId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * List the configured skill queue for the given character  --- Alternate route: `/dev/characters/{character_id}/skillqueue/`  Alternate route: `/legacy/characters/{character_id}/skillqueue/`  Alternate route: `/v2/characters/{character_id}/skillqueue/`  --- This route is cached for up to 120 seconds
         * @summary Get character's skill queue
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdSkillqueue(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return SkillsApiFp(configuration).getCharactersCharacterIdSkillqueue(characterId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * List all trained skills for the given character  --- Alternate route: `/dev/characters/{character_id}/skills/`  Alternate route: `/v4/characters/{character_id}/skills/`  --- This route is cached for up to 120 seconds
         * @summary Get character skills
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdSkills(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return SkillsApiFp(configuration).getCharactersCharacterIdSkills(characterId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
    };
};

/**
 * SkillsApi - object-oriented interface
 * @export
 * @class SkillsApi
 * @extends {BaseAPI}
 */
export class SkillsApi extends BaseAPI {
    /**
     * Return attributes of a character  --- Alternate route: `/dev/characters/{character_id}/attributes/`  Alternate route: `/legacy/characters/{character_id}/attributes/`  Alternate route: `/v1/characters/{character_id}/attributes/`  --- This route is cached for up to 120 seconds
     * @summary Get character attributes
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public getCharactersCharacterIdAttributes(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return SkillsApiFp(this.configuration).getCharactersCharacterIdAttributes(characterId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * List the configured skill queue for the given character  --- Alternate route: `/dev/characters/{character_id}/skillqueue/`  Alternate route: `/legacy/characters/{character_id}/skillqueue/`  Alternate route: `/v2/characters/{character_id}/skillqueue/`  --- This route is cached for up to 120 seconds
     * @summary Get character's skill queue
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public getCharactersCharacterIdSkillqueue(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return SkillsApiFp(this.configuration).getCharactersCharacterIdSkillqueue(characterId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * List all trained skills for the given character  --- Alternate route: `/dev/characters/{character_id}/skills/`  Alternate route: `/v4/characters/{character_id}/skills/`  --- This route is cached for up to 120 seconds
     * @summary Get character skills
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public getCharactersCharacterIdSkills(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return SkillsApiFp(this.configuration).getCharactersCharacterIdSkills(characterId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

}

/**
 * SovereigntyApi - fetch parameter creator
 * @export
 */
export const SovereigntyApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Shows sovereignty data for campaigns.  --- Alternate route: `/dev/sovereignty/campaigns/`  Alternate route: `/legacy/sovereignty/campaigns/`  Alternate route: `/v1/sovereignty/campaigns/`  --- This route is cached for up to 5 seconds
         * @summary List sovereignty campaigns
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSovereigntyCampaigns(datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            const localVarPath = `/sovereignty/campaigns/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Shows sovereignty information for solar systems  --- Alternate route: `/dev/sovereignty/map/`  Alternate route: `/legacy/sovereignty/map/`  Alternate route: `/v1/sovereignty/map/`  --- This route is cached for up to 3600 seconds
         * @summary List sovereignty of systems
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSovereigntyMap(datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            const localVarPath = `/sovereignty/map/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Shows sovereignty data for structures.  --- Alternate route: `/dev/sovereignty/structures/`  Alternate route: `/legacy/sovereignty/structures/`  Alternate route: `/v1/sovereignty/structures/`  --- This route is cached for up to 120 seconds
         * @summary List sovereignty structures
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSovereigntyStructures(datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            const localVarPath = `/sovereignty/structures/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SovereigntyApi - functional programming interface
 * @export
 */
export const SovereigntyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Shows sovereignty data for campaigns.  --- Alternate route: `/dev/sovereignty/campaigns/`  Alternate route: `/legacy/sovereignty/campaigns/`  Alternate route: `/v1/sovereignty/campaigns/`  --- This route is cached for up to 5 seconds
         * @summary List sovereignty campaigns
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSovereigntyCampaigns(datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetSovereigntyCampaigns200Ok>> {
            const localVarFetchArgs = SovereigntyApiFetchParamCreator(configuration).getSovereigntyCampaigns(datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Shows sovereignty information for solar systems  --- Alternate route: `/dev/sovereignty/map/`  Alternate route: `/legacy/sovereignty/map/`  Alternate route: `/v1/sovereignty/map/`  --- This route is cached for up to 3600 seconds
         * @summary List sovereignty of systems
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSovereigntyMap(datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetSovereigntyMap200Ok>> {
            const localVarFetchArgs = SovereigntyApiFetchParamCreator(configuration).getSovereigntyMap(datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Shows sovereignty data for structures.  --- Alternate route: `/dev/sovereignty/structures/`  Alternate route: `/legacy/sovereignty/structures/`  Alternate route: `/v1/sovereignty/structures/`  --- This route is cached for up to 120 seconds
         * @summary List sovereignty structures
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSovereigntyStructures(datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetSovereigntyStructures200Ok>> {
            const localVarFetchArgs = SovereigntyApiFetchParamCreator(configuration).getSovereigntyStructures(datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SovereigntyApi - factory interface
 * @export
 */
export const SovereigntyApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Shows sovereignty data for campaigns.  --- Alternate route: `/dev/sovereignty/campaigns/`  Alternate route: `/legacy/sovereignty/campaigns/`  Alternate route: `/v1/sovereignty/campaigns/`  --- This route is cached for up to 5 seconds
         * @summary List sovereignty campaigns
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSovereigntyCampaigns(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return SovereigntyApiFp(configuration).getSovereigntyCampaigns(datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Shows sovereignty information for solar systems  --- Alternate route: `/dev/sovereignty/map/`  Alternate route: `/legacy/sovereignty/map/`  Alternate route: `/v1/sovereignty/map/`  --- This route is cached for up to 3600 seconds
         * @summary List sovereignty of systems
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSovereigntyMap(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return SovereigntyApiFp(configuration).getSovereigntyMap(datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Shows sovereignty data for structures.  --- Alternate route: `/dev/sovereignty/structures/`  Alternate route: `/legacy/sovereignty/structures/`  Alternate route: `/v1/sovereignty/structures/`  --- This route is cached for up to 120 seconds
         * @summary List sovereignty structures
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSovereigntyStructures(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return SovereigntyApiFp(configuration).getSovereigntyStructures(datasource, ifNoneMatch, options)(fetch, basePath);
        },
    };
};

/**
 * SovereigntyApi - object-oriented interface
 * @export
 * @class SovereigntyApi
 * @extends {BaseAPI}
 */
export class SovereigntyApi extends BaseAPI {
    /**
     * Shows sovereignty data for campaigns.  --- Alternate route: `/dev/sovereignty/campaigns/`  Alternate route: `/legacy/sovereignty/campaigns/`  Alternate route: `/v1/sovereignty/campaigns/`  --- This route is cached for up to 5 seconds
     * @summary List sovereignty campaigns
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SovereigntyApi
     */
    public getSovereigntyCampaigns(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return SovereigntyApiFp(this.configuration).getSovereigntyCampaigns(datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Shows sovereignty information for solar systems  --- Alternate route: `/dev/sovereignty/map/`  Alternate route: `/legacy/sovereignty/map/`  Alternate route: `/v1/sovereignty/map/`  --- This route is cached for up to 3600 seconds
     * @summary List sovereignty of systems
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SovereigntyApi
     */
    public getSovereigntyMap(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return SovereigntyApiFp(this.configuration).getSovereigntyMap(datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Shows sovereignty data for structures.  --- Alternate route: `/dev/sovereignty/structures/`  Alternate route: `/legacy/sovereignty/structures/`  Alternate route: `/v1/sovereignty/structures/`  --- This route is cached for up to 120 seconds
     * @summary List sovereignty structures
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SovereigntyApi
     */
    public getSovereigntyStructures(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return SovereigntyApiFp(this.configuration).getSovereigntyStructures(datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

}

/**
 * StatusApi - fetch parameter creator
 * @export
 */
export const StatusApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * EVE Server status  --- Alternate route: `/dev/status/`  Alternate route: `/legacy/status/`  Alternate route: `/v1/status/`  Alternate route: `/v2/status/`  --- This route is cached for up to 30 seconds
         * @summary Retrieve the uptime and player counts
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            const localVarPath = `/status/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function(configuration?: Configuration) {
    return {
        /**
         * EVE Server status  --- Alternate route: `/dev/status/`  Alternate route: `/legacy/status/`  Alternate route: `/v1/status/`  Alternate route: `/v2/status/`  --- This route is cached for up to 30 seconds
         * @summary Retrieve the uptime and player counts
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetStatusOk> {
            const localVarFetchArgs = StatusApiFetchParamCreator(configuration).getStatus(datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * EVE Server status  --- Alternate route: `/dev/status/`  Alternate route: `/legacy/status/`  Alternate route: `/v1/status/`  Alternate route: `/v2/status/`  --- This route is cached for up to 30 seconds
         * @summary Retrieve the uptime and player counts
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return StatusApiFp(configuration).getStatus(datasource, ifNoneMatch, options)(fetch, basePath);
        },
    };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
    /**
     * EVE Server status  --- Alternate route: `/dev/status/`  Alternate route: `/legacy/status/`  Alternate route: `/v1/status/`  Alternate route: `/v2/status/`  --- This route is cached for up to 30 seconds
     * @summary Retrieve the uptime and player counts
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public getStatus(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return StatusApiFp(this.configuration).getStatus(datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

}

/**
 * UniverseApi - fetch parameter creator
 * @export
 */
export const UniverseApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all character ancestries  --- Alternate route: `/legacy/universe/ancestries/`  Alternate route: `/v1/universe/ancestries/`  --- This route expires daily at 11:05
         * @summary Get ancestries
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseAncestries(acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options: any = {}): FetchArgs {
            const localVarPath = `/universe/ancestries/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on an asteroid belt  --- Alternate route: `/legacy/universe/asteroid_belts/{asteroid_belt_id}/`  Alternate route: `/v1/universe/asteroid_belts/{asteroid_belt_id}/`  --- This route expires daily at 11:05
         * @summary Get asteroid belt information
         * @param {number} asteroidBeltId asteroid_belt_id integer
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseAsteroidBeltsAsteroidBeltId(asteroidBeltId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'asteroidBeltId' is not null or undefined
            if (asteroidBeltId === null || asteroidBeltId === undefined) {
                throw new RequiredError('asteroidBeltId','Required parameter asteroidBeltId was null or undefined when calling getUniverseAsteroidBeltsAsteroidBeltId.');
            }
            const localVarPath = `/universe/asteroid_belts/{asteroid_belt_id}/`
                .replace(`{${"asteroid_belt_id"}}`, encodeURIComponent(String(asteroidBeltId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of bloodlines  --- Alternate route: `/legacy/universe/bloodlines/`  Alternate route: `/v1/universe/bloodlines/`  --- This route expires daily at 11:05
         * @summary Get bloodlines
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseBloodlines(acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options: any = {}): FetchArgs {
            const localVarPath = `/universe/bloodlines/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of item categories  --- Alternate route: `/legacy/universe/categories/`  Alternate route: `/v1/universe/categories/`  --- This route expires daily at 11:05
         * @summary Get item categories
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseCategories(datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            const localVarPath = `/universe/categories/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information of an item category  --- Alternate route: `/legacy/universe/categories/{category_id}/`  Alternate route: `/v1/universe/categories/{category_id}/`  --- This route expires daily at 11:05
         * @summary Get item category information
         * @param {number} categoryId An Eve item category ID
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseCategoriesCategoryId(categoryId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options: any = {}): FetchArgs {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling getUniverseCategoriesCategoryId.');
            }
            const localVarPath = `/universe/categories/{category_id}/`
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of constellations  --- Alternate route: `/legacy/universe/constellations/`  Alternate route: `/v1/universe/constellations/`  --- This route expires daily at 11:05
         * @summary Get constellations
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseConstellations(datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            const localVarPath = `/universe/constellations/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on a constellation  --- Alternate route: `/legacy/universe/constellations/{constellation_id}/`  Alternate route: `/v1/universe/constellations/{constellation_id}/`  --- This route expires daily at 11:05
         * @summary Get constellation information
         * @param {number} constellationId constellation_id integer
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseConstellationsConstellationId(constellationId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options: any = {}): FetchArgs {
            // verify required parameter 'constellationId' is not null or undefined
            if (constellationId === null || constellationId === undefined) {
                throw new RequiredError('constellationId','Required parameter constellationId was null or undefined when calling getUniverseConstellationsConstellationId.');
            }
            const localVarPath = `/universe/constellations/{constellation_id}/`
                .replace(`{${"constellation_id"}}`, encodeURIComponent(String(constellationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of factions  --- Alternate route: `/dev/universe/factions/`  Alternate route: `/v2/universe/factions/`  --- This route expires daily at 11:05
         * @summary Get factions
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseFactions(acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options: any = {}): FetchArgs {
            const localVarPath = `/universe/factions/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of graphics  --- Alternate route: `/legacy/universe/graphics/`  Alternate route: `/v1/universe/graphics/`  --- This route expires daily at 11:05
         * @summary Get graphics
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseGraphics(datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            const localVarPath = `/universe/graphics/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on a graphic  --- Alternate route: `/dev/universe/graphics/{graphic_id}/`  Alternate route: `/legacy/universe/graphics/{graphic_id}/`  Alternate route: `/v1/universe/graphics/{graphic_id}/`  --- This route expires daily at 11:05
         * @summary Get graphic information
         * @param {number} graphicId graphic_id integer
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseGraphicsGraphicId(graphicId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'graphicId' is not null or undefined
            if (graphicId === null || graphicId === undefined) {
                throw new RequiredError('graphicId','Required parameter graphicId was null or undefined when calling getUniverseGraphicsGraphicId.');
            }
            const localVarPath = `/universe/graphics/{graphic_id}/`
                .replace(`{${"graphic_id"}}`, encodeURIComponent(String(graphicId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of item groups  --- Alternate route: `/legacy/universe/groups/`  Alternate route: `/v1/universe/groups/`  --- This route expires daily at 11:05
         * @summary Get item groups
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseGroups(datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options: any = {}): FetchArgs {
            const localVarPath = `/universe/groups/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on an item group  --- Alternate route: `/dev/universe/groups/{group_id}/`  Alternate route: `/legacy/universe/groups/{group_id}/`  Alternate route: `/v1/universe/groups/{group_id}/`  --- This route expires daily at 11:05
         * @summary Get item group information
         * @param {number} groupId An Eve item group ID
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseGroupsGroupId(groupId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options: any = {}): FetchArgs {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling getUniverseGroupsGroupId.');
            }
            const localVarPath = `/universe/groups/{group_id}/`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on a moon  --- Alternate route: `/legacy/universe/moons/{moon_id}/`  Alternate route: `/v1/universe/moons/{moon_id}/`  --- This route expires daily at 11:05
         * @summary Get moon information
         * @param {number} moonId moon_id integer
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseMoonsMoonId(moonId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'moonId' is not null or undefined
            if (moonId === null || moonId === undefined) {
                throw new RequiredError('moonId','Required parameter moonId was null or undefined when calling getUniverseMoonsMoonId.');
            }
            const localVarPath = `/universe/moons/{moon_id}/`
                .replace(`{${"moon_id"}}`, encodeURIComponent(String(moonId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on a planet  --- Alternate route: `/legacy/universe/planets/{planet_id}/`  Alternate route: `/v1/universe/planets/{planet_id}/`  --- This route expires daily at 11:05
         * @summary Get planet information
         * @param {number} planetId planet_id integer
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniversePlanetsPlanetId(planetId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'planetId' is not null or undefined
            if (planetId === null || planetId === undefined) {
                throw new RequiredError('planetId','Required parameter planetId was null or undefined when calling getUniversePlanetsPlanetId.');
            }
            const localVarPath = `/universe/planets/{planet_id}/`
                .replace(`{${"planet_id"}}`, encodeURIComponent(String(planetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of character races  --- Alternate route: `/dev/universe/races/`  Alternate route: `/legacy/universe/races/`  Alternate route: `/v1/universe/races/`  --- This route expires daily at 11:05
         * @summary Get character races
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseRaces(acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options: any = {}): FetchArgs {
            const localVarPath = `/universe/races/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of regions  --- Alternate route: `/legacy/universe/regions/`  Alternate route: `/v1/universe/regions/`  --- This route expires daily at 11:05
         * @summary Get regions
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseRegions(datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            const localVarPath = `/universe/regions/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on a region  --- Alternate route: `/legacy/universe/regions/{region_id}/`  Alternate route: `/v1/universe/regions/{region_id}/`  --- This route expires daily at 11:05
         * @summary Get region information
         * @param {number} regionId region_id integer
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseRegionsRegionId(regionId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options: any = {}): FetchArgs {
            // verify required parameter 'regionId' is not null or undefined
            if (regionId === null || regionId === undefined) {
                throw new RequiredError('regionId','Required parameter regionId was null or undefined when calling getUniverseRegionsRegionId.');
            }
            const localVarPath = `/universe/regions/{region_id}/`
                .replace(`{${"region_id"}}`, encodeURIComponent(String(regionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on a stargate  --- Alternate route: `/legacy/universe/stargates/{stargate_id}/`  Alternate route: `/v1/universe/stargates/{stargate_id}/`  --- This route expires daily at 11:05
         * @summary Get stargate information
         * @param {number} stargateId stargate_id integer
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseStargatesStargateId(stargateId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'stargateId' is not null or undefined
            if (stargateId === null || stargateId === undefined) {
                throw new RequiredError('stargateId','Required parameter stargateId was null or undefined when calling getUniverseStargatesStargateId.');
            }
            const localVarPath = `/universe/stargates/{stargate_id}/`
                .replace(`{${"stargate_id"}}`, encodeURIComponent(String(stargateId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on a star  --- Alternate route: `/legacy/universe/stars/{star_id}/`  Alternate route: `/v1/universe/stars/{star_id}/`  --- This route expires daily at 11:05
         * @summary Get star information
         * @param {number} starId star_id integer
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseStarsStarId(starId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'starId' is not null or undefined
            if (starId === null || starId === undefined) {
                throw new RequiredError('starId','Required parameter starId was null or undefined when calling getUniverseStarsStarId.');
            }
            const localVarPath = `/universe/stars/{star_id}/`
                .replace(`{${"star_id"}}`, encodeURIComponent(String(starId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on a station  --- Alternate route: `/dev/universe/stations/{station_id}/`  Alternate route: `/v2/universe/stations/{station_id}/`  --- This route expires daily at 11:05
         * @summary Get station information
         * @param {number} stationId station_id integer
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseStationsStationId(stationId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'stationId' is not null or undefined
            if (stationId === null || stationId === undefined) {
                throw new RequiredError('stationId','Required parameter stationId was null or undefined when calling getUniverseStationsStationId.');
            }
            const localVarPath = `/universe/stations/{station_id}/`
                .replace(`{${"station_id"}}`, encodeURIComponent(String(stationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all public structures  --- Alternate route: `/dev/universe/structures/`  Alternate route: `/legacy/universe/structures/`  Alternate route: `/v1/universe/structures/`  --- This route is cached for up to 3600 seconds
         * @summary List all public structures
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {'market' | 'manufacturing_basic'} [filter] Only list public structures that have this service online
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseStructures(datasource?: 'tranquility', filter?: 'market' | 'manufacturing_basic', ifNoneMatch?: string, options: any = {}): FetchArgs {
            const localVarPath = `/universe/structures/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information on requested structure if you are on the ACL. Otherwise, returns \"Forbidden\" for all inputs.  --- Alternate route: `/v2/universe/structures/{structure_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get structure information
         * @param {number} structureId An Eve structure ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseStructuresStructureId(structureId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'structureId' is not null or undefined
            if (structureId === null || structureId === undefined) {
                throw new RequiredError('structureId','Required parameter structureId was null or undefined when calling getUniverseStructuresStructureId.');
            }
            const localVarPath = `/universe/structures/{structure_id}/`
                .replace(`{${"structure_id"}}`, encodeURIComponent(String(structureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-universe.read_structures.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the number of jumps in solar systems within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with jumps will be listed  --- Alternate route: `/legacy/universe/system_jumps/`  Alternate route: `/v1/universe/system_jumps/`  --- This route is cached for up to 3600 seconds
         * @summary Get system jumps
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseSystemJumps(datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            const localVarPath = `/universe/system_jumps/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the number of ship, pod and NPC kills per solar system within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with kills will be listed  --- Alternate route: `/v2/universe/system_kills/`  --- This route is cached for up to 3600 seconds
         * @summary Get system kills
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseSystemKills(datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            const localVarPath = `/universe/system_kills/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of solar systems  --- Alternate route: `/dev/universe/systems/`  Alternate route: `/legacy/universe/systems/`  Alternate route: `/v1/universe/systems/`  --- This route expires daily at 11:05
         * @summary Get solar systems
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseSystems(datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            const localVarPath = `/universe/systems/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on a solar system.  --- Alternate route: `/dev/universe/systems/{system_id}/`  Alternate route: `/v4/universe/systems/{system_id}/`  --- This route expires daily at 11:05
         * @summary Get solar system information
         * @param {number} systemId system_id integer
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseSystemsSystemId(systemId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options: any = {}): FetchArgs {
            // verify required parameter 'systemId' is not null or undefined
            if (systemId === null || systemId === undefined) {
                throw new RequiredError('systemId','Required parameter systemId was null or undefined when calling getUniverseSystemsSystemId.');
            }
            const localVarPath = `/universe/systems/{system_id}/`
                .replace(`{${"system_id"}}`, encodeURIComponent(String(systemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of type ids  --- Alternate route: `/legacy/universe/types/`  Alternate route: `/v1/universe/types/`  --- This route expires daily at 11:05
         * @summary Get types
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseTypes(datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options: any = {}): FetchArgs {
            const localVarPath = `/universe/types/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on a type  --- Alternate route: `/dev/universe/types/{type_id}/`  Alternate route: `/v3/universe/types/{type_id}/`  --- This route expires daily at 11:05
         * @summary Get type information
         * @param {number} typeId An Eve item type ID
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseTypesTypeId(typeId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options: any = {}): FetchArgs {
            // verify required parameter 'typeId' is not null or undefined
            if (typeId === null || typeId === undefined) {
                throw new RequiredError('typeId','Required parameter typeId was null or undefined when calling getUniverseTypesTypeId.');
            }
            const localVarPath = `/universe/types/{type_id}/`
                .replace(`{${"type_id"}}`, encodeURIComponent(String(typeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resolve a set of names to IDs in the following categories: agents, alliances, characters, constellations, corporations factions, inventory_types, regions, stations, and systems. Only exact matches will be returned. All names searched for are cached for 12 hours  --- Alternate route: `/dev/universe/ids/`  Alternate route: `/legacy/universe/ids/`  Alternate route: `/v1/universe/ids/` 
         * @summary Bulk names to IDs
         * @param {Array<string>} names The names to resolve
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUniverseIds(names: Array<string>, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options: any = {}): FetchArgs {
            // verify required parameter 'names' is not null or undefined
            if (names === null || names === undefined) {
                throw new RequiredError('names','Required parameter names was null or undefined when calling postUniverseIds.');
            }
            const localVarPath = `/universe/ids/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;string&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(names || {}) : (names || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resolve a set of IDs to names and categories. Supported ID's for resolving are: Characters, Corporations, Alliances, Stations, Solar Systems, Constellations, Regions, Types, Factions  --- Alternate route: `/dev/universe/names/`  Alternate route: `/v3/universe/names/` 
         * @summary Get names and categories for a set of IDs
         * @param {Array<number>} ids The ids to resolve
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUniverseNames(ids: Array<number>, datasource?: 'tranquility', options: any = {}): FetchArgs {
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError('ids','Required parameter ids was null or undefined when calling postUniverseNames.');
            }
            const localVarPath = `/universe/names/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;number&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(ids || {}) : (ids || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UniverseApi - functional programming interface
 * @export
 */
export const UniverseApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get all character ancestries  --- Alternate route: `/legacy/universe/ancestries/`  Alternate route: `/v1/universe/ancestries/`  --- This route expires daily at 11:05
         * @summary Get ancestries
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseAncestries(acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetUniverseAncestries200Ok>> {
            const localVarFetchArgs = UniverseApiFetchParamCreator(configuration).getUniverseAncestries(acceptLanguage, datasource, ifNoneMatch, language, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information on an asteroid belt  --- Alternate route: `/legacy/universe/asteroid_belts/{asteroid_belt_id}/`  Alternate route: `/v1/universe/asteroid_belts/{asteroid_belt_id}/`  --- This route expires daily at 11:05
         * @summary Get asteroid belt information
         * @param {number} asteroidBeltId asteroid_belt_id integer
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseAsteroidBeltsAsteroidBeltId(asteroidBeltId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetUniverseAsteroidBeltsAsteroidBeltIdOk> {
            const localVarFetchArgs = UniverseApiFetchParamCreator(configuration).getUniverseAsteroidBeltsAsteroidBeltId(asteroidBeltId, datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of bloodlines  --- Alternate route: `/legacy/universe/bloodlines/`  Alternate route: `/v1/universe/bloodlines/`  --- This route expires daily at 11:05
         * @summary Get bloodlines
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseBloodlines(acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetUniverseBloodlines200Ok>> {
            const localVarFetchArgs = UniverseApiFetchParamCreator(configuration).getUniverseBloodlines(acceptLanguage, datasource, ifNoneMatch, language, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of item categories  --- Alternate route: `/legacy/universe/categories/`  Alternate route: `/v1/universe/categories/`  --- This route expires daily at 11:05
         * @summary Get item categories
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseCategories(datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = UniverseApiFetchParamCreator(configuration).getUniverseCategories(datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information of an item category  --- Alternate route: `/legacy/universe/categories/{category_id}/`  Alternate route: `/v1/universe/categories/{category_id}/`  --- This route expires daily at 11:05
         * @summary Get item category information
         * @param {number} categoryId An Eve item category ID
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseCategoriesCategoryId(categoryId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetUniverseCategoriesCategoryIdOk> {
            const localVarFetchArgs = UniverseApiFetchParamCreator(configuration).getUniverseCategoriesCategoryId(categoryId, acceptLanguage, datasource, ifNoneMatch, language, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of constellations  --- Alternate route: `/legacy/universe/constellations/`  Alternate route: `/v1/universe/constellations/`  --- This route expires daily at 11:05
         * @summary Get constellations
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseConstellations(datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = UniverseApiFetchParamCreator(configuration).getUniverseConstellations(datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information on a constellation  --- Alternate route: `/legacy/universe/constellations/{constellation_id}/`  Alternate route: `/v1/universe/constellations/{constellation_id}/`  --- This route expires daily at 11:05
         * @summary Get constellation information
         * @param {number} constellationId constellation_id integer
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseConstellationsConstellationId(constellationId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetUniverseConstellationsConstellationIdOk> {
            const localVarFetchArgs = UniverseApiFetchParamCreator(configuration).getUniverseConstellationsConstellationId(constellationId, acceptLanguage, datasource, ifNoneMatch, language, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of factions  --- Alternate route: `/dev/universe/factions/`  Alternate route: `/v2/universe/factions/`  --- This route expires daily at 11:05
         * @summary Get factions
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseFactions(acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetUniverseFactions200Ok>> {
            const localVarFetchArgs = UniverseApiFetchParamCreator(configuration).getUniverseFactions(acceptLanguage, datasource, ifNoneMatch, language, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of graphics  --- Alternate route: `/legacy/universe/graphics/`  Alternate route: `/v1/universe/graphics/`  --- This route expires daily at 11:05
         * @summary Get graphics
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseGraphics(datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = UniverseApiFetchParamCreator(configuration).getUniverseGraphics(datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information on a graphic  --- Alternate route: `/dev/universe/graphics/{graphic_id}/`  Alternate route: `/legacy/universe/graphics/{graphic_id}/`  Alternate route: `/v1/universe/graphics/{graphic_id}/`  --- This route expires daily at 11:05
         * @summary Get graphic information
         * @param {number} graphicId graphic_id integer
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseGraphicsGraphicId(graphicId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetUniverseGraphicsGraphicIdOk> {
            const localVarFetchArgs = UniverseApiFetchParamCreator(configuration).getUniverseGraphicsGraphicId(graphicId, datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of item groups  --- Alternate route: `/legacy/universe/groups/`  Alternate route: `/v1/universe/groups/`  --- This route expires daily at 11:05
         * @summary Get item groups
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseGroups(datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = UniverseApiFetchParamCreator(configuration).getUniverseGroups(datasource, ifNoneMatch, page, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information on an item group  --- Alternate route: `/dev/universe/groups/{group_id}/`  Alternate route: `/legacy/universe/groups/{group_id}/`  Alternate route: `/v1/universe/groups/{group_id}/`  --- This route expires daily at 11:05
         * @summary Get item group information
         * @param {number} groupId An Eve item group ID
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseGroupsGroupId(groupId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetUniverseGroupsGroupIdOk> {
            const localVarFetchArgs = UniverseApiFetchParamCreator(configuration).getUniverseGroupsGroupId(groupId, acceptLanguage, datasource, ifNoneMatch, language, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information on a moon  --- Alternate route: `/legacy/universe/moons/{moon_id}/`  Alternate route: `/v1/universe/moons/{moon_id}/`  --- This route expires daily at 11:05
         * @summary Get moon information
         * @param {number} moonId moon_id integer
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseMoonsMoonId(moonId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetUniverseMoonsMoonIdOk> {
            const localVarFetchArgs = UniverseApiFetchParamCreator(configuration).getUniverseMoonsMoonId(moonId, datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information on a planet  --- Alternate route: `/legacy/universe/planets/{planet_id}/`  Alternate route: `/v1/universe/planets/{planet_id}/`  --- This route expires daily at 11:05
         * @summary Get planet information
         * @param {number} planetId planet_id integer
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniversePlanetsPlanetId(planetId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetUniversePlanetsPlanetIdOk> {
            const localVarFetchArgs = UniverseApiFetchParamCreator(configuration).getUniversePlanetsPlanetId(planetId, datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of character races  --- Alternate route: `/dev/universe/races/`  Alternate route: `/legacy/universe/races/`  Alternate route: `/v1/universe/races/`  --- This route expires daily at 11:05
         * @summary Get character races
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseRaces(acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetUniverseRaces200Ok>> {
            const localVarFetchArgs = UniverseApiFetchParamCreator(configuration).getUniverseRaces(acceptLanguage, datasource, ifNoneMatch, language, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of regions  --- Alternate route: `/legacy/universe/regions/`  Alternate route: `/v1/universe/regions/`  --- This route expires daily at 11:05
         * @summary Get regions
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseRegions(datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = UniverseApiFetchParamCreator(configuration).getUniverseRegions(datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information on a region  --- Alternate route: `/legacy/universe/regions/{region_id}/`  Alternate route: `/v1/universe/regions/{region_id}/`  --- This route expires daily at 11:05
         * @summary Get region information
         * @param {number} regionId region_id integer
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseRegionsRegionId(regionId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetUniverseRegionsRegionIdOk> {
            const localVarFetchArgs = UniverseApiFetchParamCreator(configuration).getUniverseRegionsRegionId(regionId, acceptLanguage, datasource, ifNoneMatch, language, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information on a stargate  --- Alternate route: `/legacy/universe/stargates/{stargate_id}/`  Alternate route: `/v1/universe/stargates/{stargate_id}/`  --- This route expires daily at 11:05
         * @summary Get stargate information
         * @param {number} stargateId stargate_id integer
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseStargatesStargateId(stargateId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetUniverseStargatesStargateIdOk> {
            const localVarFetchArgs = UniverseApiFetchParamCreator(configuration).getUniverseStargatesStargateId(stargateId, datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information on a star  --- Alternate route: `/legacy/universe/stars/{star_id}/`  Alternate route: `/v1/universe/stars/{star_id}/`  --- This route expires daily at 11:05
         * @summary Get star information
         * @param {number} starId star_id integer
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseStarsStarId(starId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetUniverseStarsStarIdOk> {
            const localVarFetchArgs = UniverseApiFetchParamCreator(configuration).getUniverseStarsStarId(starId, datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information on a station  --- Alternate route: `/dev/universe/stations/{station_id}/`  Alternate route: `/v2/universe/stations/{station_id}/`  --- This route expires daily at 11:05
         * @summary Get station information
         * @param {number} stationId station_id integer
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseStationsStationId(stationId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetUniverseStationsStationIdOk> {
            const localVarFetchArgs = UniverseApiFetchParamCreator(configuration).getUniverseStationsStationId(stationId, datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all public structures  --- Alternate route: `/dev/universe/structures/`  Alternate route: `/legacy/universe/structures/`  Alternate route: `/v1/universe/structures/`  --- This route is cached for up to 3600 seconds
         * @summary List all public structures
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {'market' | 'manufacturing_basic'} [filter] Only list public structures that have this service online
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseStructures(datasource?: 'tranquility', filter?: 'market' | 'manufacturing_basic', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = UniverseApiFetchParamCreator(configuration).getUniverseStructures(datasource, filter, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns information on requested structure if you are on the ACL. Otherwise, returns \"Forbidden\" for all inputs.  --- Alternate route: `/v2/universe/structures/{structure_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get structure information
         * @param {number} structureId An Eve structure ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseStructuresStructureId(structureId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetUniverseStructuresStructureIdOk> {
            const localVarFetchArgs = UniverseApiFetchParamCreator(configuration).getUniverseStructuresStructureId(structureId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the number of jumps in solar systems within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with jumps will be listed  --- Alternate route: `/legacy/universe/system_jumps/`  Alternate route: `/v1/universe/system_jumps/`  --- This route is cached for up to 3600 seconds
         * @summary Get system jumps
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseSystemJumps(datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetUniverseSystemJumps200Ok>> {
            const localVarFetchArgs = UniverseApiFetchParamCreator(configuration).getUniverseSystemJumps(datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the number of ship, pod and NPC kills per solar system within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with kills will be listed  --- Alternate route: `/v2/universe/system_kills/`  --- This route is cached for up to 3600 seconds
         * @summary Get system kills
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseSystemKills(datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetUniverseSystemKills200Ok>> {
            const localVarFetchArgs = UniverseApiFetchParamCreator(configuration).getUniverseSystemKills(datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of solar systems  --- Alternate route: `/dev/universe/systems/`  Alternate route: `/legacy/universe/systems/`  Alternate route: `/v1/universe/systems/`  --- This route expires daily at 11:05
         * @summary Get solar systems
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseSystems(datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = UniverseApiFetchParamCreator(configuration).getUniverseSystems(datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information on a solar system.  --- Alternate route: `/dev/universe/systems/{system_id}/`  Alternate route: `/v4/universe/systems/{system_id}/`  --- This route expires daily at 11:05
         * @summary Get solar system information
         * @param {number} systemId system_id integer
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseSystemsSystemId(systemId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetUniverseSystemsSystemIdOk> {
            const localVarFetchArgs = UniverseApiFetchParamCreator(configuration).getUniverseSystemsSystemId(systemId, acceptLanguage, datasource, ifNoneMatch, language, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of type ids  --- Alternate route: `/legacy/universe/types/`  Alternate route: `/v1/universe/types/`  --- This route expires daily at 11:05
         * @summary Get types
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseTypes(datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = UniverseApiFetchParamCreator(configuration).getUniverseTypes(datasource, ifNoneMatch, page, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information on a type  --- Alternate route: `/dev/universe/types/{type_id}/`  Alternate route: `/v3/universe/types/{type_id}/`  --- This route expires daily at 11:05
         * @summary Get type information
         * @param {number} typeId An Eve item type ID
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseTypesTypeId(typeId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetUniverseTypesTypeIdOk> {
            const localVarFetchArgs = UniverseApiFetchParamCreator(configuration).getUniverseTypesTypeId(typeId, acceptLanguage, datasource, ifNoneMatch, language, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Resolve a set of names to IDs in the following categories: agents, alliances, characters, constellations, corporations factions, inventory_types, regions, stations, and systems. Only exact matches will be returned. All names searched for are cached for 12 hours  --- Alternate route: `/dev/universe/ids/`  Alternate route: `/legacy/universe/ids/`  Alternate route: `/v1/universe/ids/` 
         * @summary Bulk names to IDs
         * @param {Array<string>} names The names to resolve
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUniverseIds(names: Array<string>, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PostUniverseIdsOk> {
            const localVarFetchArgs = UniverseApiFetchParamCreator(configuration).postUniverseIds(names, acceptLanguage, datasource, language, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Resolve a set of IDs to names and categories. Supported ID's for resolving are: Characters, Corporations, Alliances, Stations, Solar Systems, Constellations, Regions, Types, Factions  --- Alternate route: `/dev/universe/names/`  Alternate route: `/v3/universe/names/` 
         * @summary Get names and categories for a set of IDs
         * @param {Array<number>} ids The ids to resolve
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUniverseNames(ids: Array<number>, datasource?: 'tranquility', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PostUniverseNames200Ok>> {
            const localVarFetchArgs = UniverseApiFetchParamCreator(configuration).postUniverseNames(ids, datasource, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UniverseApi - factory interface
 * @export
 */
export const UniverseApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get all character ancestries  --- Alternate route: `/legacy/universe/ancestries/`  Alternate route: `/v1/universe/ancestries/`  --- This route expires daily at 11:05
         * @summary Get ancestries
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseAncestries(acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any) {
            return UniverseApiFp(configuration).getUniverseAncestries(acceptLanguage, datasource, ifNoneMatch, language, options)(fetch, basePath);
        },
        /**
         * Get information on an asteroid belt  --- Alternate route: `/legacy/universe/asteroid_belts/{asteroid_belt_id}/`  Alternate route: `/v1/universe/asteroid_belts/{asteroid_belt_id}/`  --- This route expires daily at 11:05
         * @summary Get asteroid belt information
         * @param {number} asteroidBeltId asteroid_belt_id integer
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseAsteroidBeltsAsteroidBeltId(asteroidBeltId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return UniverseApiFp(configuration).getUniverseAsteroidBeltsAsteroidBeltId(asteroidBeltId, datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Get a list of bloodlines  --- Alternate route: `/legacy/universe/bloodlines/`  Alternate route: `/v1/universe/bloodlines/`  --- This route expires daily at 11:05
         * @summary Get bloodlines
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseBloodlines(acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any) {
            return UniverseApiFp(configuration).getUniverseBloodlines(acceptLanguage, datasource, ifNoneMatch, language, options)(fetch, basePath);
        },
        /**
         * Get a list of item categories  --- Alternate route: `/legacy/universe/categories/`  Alternate route: `/v1/universe/categories/`  --- This route expires daily at 11:05
         * @summary Get item categories
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseCategories(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return UniverseApiFp(configuration).getUniverseCategories(datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Get information of an item category  --- Alternate route: `/legacy/universe/categories/{category_id}/`  Alternate route: `/v1/universe/categories/{category_id}/`  --- This route expires daily at 11:05
         * @summary Get item category information
         * @param {number} categoryId An Eve item category ID
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseCategoriesCategoryId(categoryId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any) {
            return UniverseApiFp(configuration).getUniverseCategoriesCategoryId(categoryId, acceptLanguage, datasource, ifNoneMatch, language, options)(fetch, basePath);
        },
        /**
         * Get a list of constellations  --- Alternate route: `/legacy/universe/constellations/`  Alternate route: `/v1/universe/constellations/`  --- This route expires daily at 11:05
         * @summary Get constellations
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseConstellations(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return UniverseApiFp(configuration).getUniverseConstellations(datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Get information on a constellation  --- Alternate route: `/legacy/universe/constellations/{constellation_id}/`  Alternate route: `/v1/universe/constellations/{constellation_id}/`  --- This route expires daily at 11:05
         * @summary Get constellation information
         * @param {number} constellationId constellation_id integer
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseConstellationsConstellationId(constellationId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any) {
            return UniverseApiFp(configuration).getUniverseConstellationsConstellationId(constellationId, acceptLanguage, datasource, ifNoneMatch, language, options)(fetch, basePath);
        },
        /**
         * Get a list of factions  --- Alternate route: `/dev/universe/factions/`  Alternate route: `/v2/universe/factions/`  --- This route expires daily at 11:05
         * @summary Get factions
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseFactions(acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any) {
            return UniverseApiFp(configuration).getUniverseFactions(acceptLanguage, datasource, ifNoneMatch, language, options)(fetch, basePath);
        },
        /**
         * Get a list of graphics  --- Alternate route: `/legacy/universe/graphics/`  Alternate route: `/v1/universe/graphics/`  --- This route expires daily at 11:05
         * @summary Get graphics
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseGraphics(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return UniverseApiFp(configuration).getUniverseGraphics(datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Get information on a graphic  --- Alternate route: `/dev/universe/graphics/{graphic_id}/`  Alternate route: `/legacy/universe/graphics/{graphic_id}/`  Alternate route: `/v1/universe/graphics/{graphic_id}/`  --- This route expires daily at 11:05
         * @summary Get graphic information
         * @param {number} graphicId graphic_id integer
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseGraphicsGraphicId(graphicId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return UniverseApiFp(configuration).getUniverseGraphicsGraphicId(graphicId, datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Get a list of item groups  --- Alternate route: `/legacy/universe/groups/`  Alternate route: `/v1/universe/groups/`  --- This route expires daily at 11:05
         * @summary Get item groups
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseGroups(datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options?: any) {
            return UniverseApiFp(configuration).getUniverseGroups(datasource, ifNoneMatch, page, options)(fetch, basePath);
        },
        /**
         * Get information on an item group  --- Alternate route: `/dev/universe/groups/{group_id}/`  Alternate route: `/legacy/universe/groups/{group_id}/`  Alternate route: `/v1/universe/groups/{group_id}/`  --- This route expires daily at 11:05
         * @summary Get item group information
         * @param {number} groupId An Eve item group ID
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseGroupsGroupId(groupId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any) {
            return UniverseApiFp(configuration).getUniverseGroupsGroupId(groupId, acceptLanguage, datasource, ifNoneMatch, language, options)(fetch, basePath);
        },
        /**
         * Get information on a moon  --- Alternate route: `/legacy/universe/moons/{moon_id}/`  Alternate route: `/v1/universe/moons/{moon_id}/`  --- This route expires daily at 11:05
         * @summary Get moon information
         * @param {number} moonId moon_id integer
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseMoonsMoonId(moonId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return UniverseApiFp(configuration).getUniverseMoonsMoonId(moonId, datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Get information on a planet  --- Alternate route: `/legacy/universe/planets/{planet_id}/`  Alternate route: `/v1/universe/planets/{planet_id}/`  --- This route expires daily at 11:05
         * @summary Get planet information
         * @param {number} planetId planet_id integer
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniversePlanetsPlanetId(planetId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return UniverseApiFp(configuration).getUniversePlanetsPlanetId(planetId, datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Get a list of character races  --- Alternate route: `/dev/universe/races/`  Alternate route: `/legacy/universe/races/`  Alternate route: `/v1/universe/races/`  --- This route expires daily at 11:05
         * @summary Get character races
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseRaces(acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any) {
            return UniverseApiFp(configuration).getUniverseRaces(acceptLanguage, datasource, ifNoneMatch, language, options)(fetch, basePath);
        },
        /**
         * Get a list of regions  --- Alternate route: `/legacy/universe/regions/`  Alternate route: `/v1/universe/regions/`  --- This route expires daily at 11:05
         * @summary Get regions
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseRegions(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return UniverseApiFp(configuration).getUniverseRegions(datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Get information on a region  --- Alternate route: `/legacy/universe/regions/{region_id}/`  Alternate route: `/v1/universe/regions/{region_id}/`  --- This route expires daily at 11:05
         * @summary Get region information
         * @param {number} regionId region_id integer
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseRegionsRegionId(regionId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any) {
            return UniverseApiFp(configuration).getUniverseRegionsRegionId(regionId, acceptLanguage, datasource, ifNoneMatch, language, options)(fetch, basePath);
        },
        /**
         * Get information on a stargate  --- Alternate route: `/legacy/universe/stargates/{stargate_id}/`  Alternate route: `/v1/universe/stargates/{stargate_id}/`  --- This route expires daily at 11:05
         * @summary Get stargate information
         * @param {number} stargateId stargate_id integer
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseStargatesStargateId(stargateId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return UniverseApiFp(configuration).getUniverseStargatesStargateId(stargateId, datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Get information on a star  --- Alternate route: `/legacy/universe/stars/{star_id}/`  Alternate route: `/v1/universe/stars/{star_id}/`  --- This route expires daily at 11:05
         * @summary Get star information
         * @param {number} starId star_id integer
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseStarsStarId(starId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return UniverseApiFp(configuration).getUniverseStarsStarId(starId, datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Get information on a station  --- Alternate route: `/dev/universe/stations/{station_id}/`  Alternate route: `/v2/universe/stations/{station_id}/`  --- This route expires daily at 11:05
         * @summary Get station information
         * @param {number} stationId station_id integer
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseStationsStationId(stationId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return UniverseApiFp(configuration).getUniverseStationsStationId(stationId, datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * List all public structures  --- Alternate route: `/dev/universe/structures/`  Alternate route: `/legacy/universe/structures/`  Alternate route: `/v1/universe/structures/`  --- This route is cached for up to 3600 seconds
         * @summary List all public structures
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {'market' | 'manufacturing_basic'} [filter] Only list public structures that have this service online
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseStructures(datasource?: 'tranquility', filter?: 'market' | 'manufacturing_basic', ifNoneMatch?: string, options?: any) {
            return UniverseApiFp(configuration).getUniverseStructures(datasource, filter, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Returns information on requested structure if you are on the ACL. Otherwise, returns \"Forbidden\" for all inputs.  --- Alternate route: `/v2/universe/structures/{structure_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get structure information
         * @param {number} structureId An Eve structure ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseStructuresStructureId(structureId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return UniverseApiFp(configuration).getUniverseStructuresStructureId(structureId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Get the number of jumps in solar systems within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with jumps will be listed  --- Alternate route: `/legacy/universe/system_jumps/`  Alternate route: `/v1/universe/system_jumps/`  --- This route is cached for up to 3600 seconds
         * @summary Get system jumps
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseSystemJumps(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return UniverseApiFp(configuration).getUniverseSystemJumps(datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Get the number of ship, pod and NPC kills per solar system within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with kills will be listed  --- Alternate route: `/v2/universe/system_kills/`  --- This route is cached for up to 3600 seconds
         * @summary Get system kills
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseSystemKills(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return UniverseApiFp(configuration).getUniverseSystemKills(datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Get a list of solar systems  --- Alternate route: `/dev/universe/systems/`  Alternate route: `/legacy/universe/systems/`  Alternate route: `/v1/universe/systems/`  --- This route expires daily at 11:05
         * @summary Get solar systems
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseSystems(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return UniverseApiFp(configuration).getUniverseSystems(datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Get information on a solar system.  --- Alternate route: `/dev/universe/systems/{system_id}/`  Alternate route: `/v4/universe/systems/{system_id}/`  --- This route expires daily at 11:05
         * @summary Get solar system information
         * @param {number} systemId system_id integer
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseSystemsSystemId(systemId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any) {
            return UniverseApiFp(configuration).getUniverseSystemsSystemId(systemId, acceptLanguage, datasource, ifNoneMatch, language, options)(fetch, basePath);
        },
        /**
         * Get a list of type ids  --- Alternate route: `/legacy/universe/types/`  Alternate route: `/v1/universe/types/`  --- This route expires daily at 11:05
         * @summary Get types
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseTypes(datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options?: any) {
            return UniverseApiFp(configuration).getUniverseTypes(datasource, ifNoneMatch, page, options)(fetch, basePath);
        },
        /**
         * Get information on a type  --- Alternate route: `/dev/universe/types/{type_id}/`  Alternate route: `/v3/universe/types/{type_id}/`  --- This route expires daily at 11:05
         * @summary Get type information
         * @param {number} typeId An Eve item type ID
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseTypesTypeId(typeId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any) {
            return UniverseApiFp(configuration).getUniverseTypesTypeId(typeId, acceptLanguage, datasource, ifNoneMatch, language, options)(fetch, basePath);
        },
        /**
         * Resolve a set of names to IDs in the following categories: agents, alliances, characters, constellations, corporations factions, inventory_types, regions, stations, and systems. Only exact matches will be returned. All names searched for are cached for 12 hours  --- Alternate route: `/dev/universe/ids/`  Alternate route: `/legacy/universe/ids/`  Alternate route: `/v1/universe/ids/` 
         * @summary Bulk names to IDs
         * @param {Array<string>} names The names to resolve
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUniverseIds(names: Array<string>, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any) {
            return UniverseApiFp(configuration).postUniverseIds(names, acceptLanguage, datasource, language, options)(fetch, basePath);
        },
        /**
         * Resolve a set of IDs to names and categories. Supported ID's for resolving are: Characters, Corporations, Alliances, Stations, Solar Systems, Constellations, Regions, Types, Factions  --- Alternate route: `/dev/universe/names/`  Alternate route: `/v3/universe/names/` 
         * @summary Get names and categories for a set of IDs
         * @param {Array<number>} ids The ids to resolve
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUniverseNames(ids: Array<number>, datasource?: 'tranquility', options?: any) {
            return UniverseApiFp(configuration).postUniverseNames(ids, datasource, options)(fetch, basePath);
        },
    };
};

/**
 * UniverseApi - object-oriented interface
 * @export
 * @class UniverseApi
 * @extends {BaseAPI}
 */
export class UniverseApi extends BaseAPI {
    /**
     * Get all character ancestries  --- Alternate route: `/legacy/universe/ancestries/`  Alternate route: `/v1/universe/ancestries/`  --- This route expires daily at 11:05
     * @summary Get ancestries
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseApi
     */
    public getUniverseAncestries(acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any) {
        return UniverseApiFp(this.configuration).getUniverseAncestries(acceptLanguage, datasource, ifNoneMatch, language, options)(this.fetch, this.basePath);
    }

    /**
     * Get information on an asteroid belt  --- Alternate route: `/legacy/universe/asteroid_belts/{asteroid_belt_id}/`  Alternate route: `/v1/universe/asteroid_belts/{asteroid_belt_id}/`  --- This route expires daily at 11:05
     * @summary Get asteroid belt information
     * @param {number} asteroidBeltId asteroid_belt_id integer
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseApi
     */
    public getUniverseAsteroidBeltsAsteroidBeltId(asteroidBeltId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return UniverseApiFp(this.configuration).getUniverseAsteroidBeltsAsteroidBeltId(asteroidBeltId, datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of bloodlines  --- Alternate route: `/legacy/universe/bloodlines/`  Alternate route: `/v1/universe/bloodlines/`  --- This route expires daily at 11:05
     * @summary Get bloodlines
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseApi
     */
    public getUniverseBloodlines(acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any) {
        return UniverseApiFp(this.configuration).getUniverseBloodlines(acceptLanguage, datasource, ifNoneMatch, language, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of item categories  --- Alternate route: `/legacy/universe/categories/`  Alternate route: `/v1/universe/categories/`  --- This route expires daily at 11:05
     * @summary Get item categories
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseApi
     */
    public getUniverseCategories(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return UniverseApiFp(this.configuration).getUniverseCategories(datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Get information of an item category  --- Alternate route: `/legacy/universe/categories/{category_id}/`  Alternate route: `/v1/universe/categories/{category_id}/`  --- This route expires daily at 11:05
     * @summary Get item category information
     * @param {number} categoryId An Eve item category ID
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseApi
     */
    public getUniverseCategoriesCategoryId(categoryId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any) {
        return UniverseApiFp(this.configuration).getUniverseCategoriesCategoryId(categoryId, acceptLanguage, datasource, ifNoneMatch, language, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of constellations  --- Alternate route: `/legacy/universe/constellations/`  Alternate route: `/v1/universe/constellations/`  --- This route expires daily at 11:05
     * @summary Get constellations
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseApi
     */
    public getUniverseConstellations(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return UniverseApiFp(this.configuration).getUniverseConstellations(datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Get information on a constellation  --- Alternate route: `/legacy/universe/constellations/{constellation_id}/`  Alternate route: `/v1/universe/constellations/{constellation_id}/`  --- This route expires daily at 11:05
     * @summary Get constellation information
     * @param {number} constellationId constellation_id integer
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseApi
     */
    public getUniverseConstellationsConstellationId(constellationId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any) {
        return UniverseApiFp(this.configuration).getUniverseConstellationsConstellationId(constellationId, acceptLanguage, datasource, ifNoneMatch, language, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of factions  --- Alternate route: `/dev/universe/factions/`  Alternate route: `/v2/universe/factions/`  --- This route expires daily at 11:05
     * @summary Get factions
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseApi
     */
    public getUniverseFactions(acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any) {
        return UniverseApiFp(this.configuration).getUniverseFactions(acceptLanguage, datasource, ifNoneMatch, language, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of graphics  --- Alternate route: `/legacy/universe/graphics/`  Alternate route: `/v1/universe/graphics/`  --- This route expires daily at 11:05
     * @summary Get graphics
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseApi
     */
    public getUniverseGraphics(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return UniverseApiFp(this.configuration).getUniverseGraphics(datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Get information on a graphic  --- Alternate route: `/dev/universe/graphics/{graphic_id}/`  Alternate route: `/legacy/universe/graphics/{graphic_id}/`  Alternate route: `/v1/universe/graphics/{graphic_id}/`  --- This route expires daily at 11:05
     * @summary Get graphic information
     * @param {number} graphicId graphic_id integer
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseApi
     */
    public getUniverseGraphicsGraphicId(graphicId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return UniverseApiFp(this.configuration).getUniverseGraphicsGraphicId(graphicId, datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of item groups  --- Alternate route: `/legacy/universe/groups/`  Alternate route: `/v1/universe/groups/`  --- This route expires daily at 11:05
     * @summary Get item groups
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseApi
     */
    public getUniverseGroups(datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options?: any) {
        return UniverseApiFp(this.configuration).getUniverseGroups(datasource, ifNoneMatch, page, options)(this.fetch, this.basePath);
    }

    /**
     * Get information on an item group  --- Alternate route: `/dev/universe/groups/{group_id}/`  Alternate route: `/legacy/universe/groups/{group_id}/`  Alternate route: `/v1/universe/groups/{group_id}/`  --- This route expires daily at 11:05
     * @summary Get item group information
     * @param {number} groupId An Eve item group ID
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseApi
     */
    public getUniverseGroupsGroupId(groupId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any) {
        return UniverseApiFp(this.configuration).getUniverseGroupsGroupId(groupId, acceptLanguage, datasource, ifNoneMatch, language, options)(this.fetch, this.basePath);
    }

    /**
     * Get information on a moon  --- Alternate route: `/legacy/universe/moons/{moon_id}/`  Alternate route: `/v1/universe/moons/{moon_id}/`  --- This route expires daily at 11:05
     * @summary Get moon information
     * @param {number} moonId moon_id integer
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseApi
     */
    public getUniverseMoonsMoonId(moonId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return UniverseApiFp(this.configuration).getUniverseMoonsMoonId(moonId, datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Get information on a planet  --- Alternate route: `/legacy/universe/planets/{planet_id}/`  Alternate route: `/v1/universe/planets/{planet_id}/`  --- This route expires daily at 11:05
     * @summary Get planet information
     * @param {number} planetId planet_id integer
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseApi
     */
    public getUniversePlanetsPlanetId(planetId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return UniverseApiFp(this.configuration).getUniversePlanetsPlanetId(planetId, datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of character races  --- Alternate route: `/dev/universe/races/`  Alternate route: `/legacy/universe/races/`  Alternate route: `/v1/universe/races/`  --- This route expires daily at 11:05
     * @summary Get character races
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseApi
     */
    public getUniverseRaces(acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any) {
        return UniverseApiFp(this.configuration).getUniverseRaces(acceptLanguage, datasource, ifNoneMatch, language, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of regions  --- Alternate route: `/legacy/universe/regions/`  Alternate route: `/v1/universe/regions/`  --- This route expires daily at 11:05
     * @summary Get regions
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseApi
     */
    public getUniverseRegions(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return UniverseApiFp(this.configuration).getUniverseRegions(datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Get information on a region  --- Alternate route: `/legacy/universe/regions/{region_id}/`  Alternate route: `/v1/universe/regions/{region_id}/`  --- This route expires daily at 11:05
     * @summary Get region information
     * @param {number} regionId region_id integer
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseApi
     */
    public getUniverseRegionsRegionId(regionId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any) {
        return UniverseApiFp(this.configuration).getUniverseRegionsRegionId(regionId, acceptLanguage, datasource, ifNoneMatch, language, options)(this.fetch, this.basePath);
    }

    /**
     * Get information on a stargate  --- Alternate route: `/legacy/universe/stargates/{stargate_id}/`  Alternate route: `/v1/universe/stargates/{stargate_id}/`  --- This route expires daily at 11:05
     * @summary Get stargate information
     * @param {number} stargateId stargate_id integer
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseApi
     */
    public getUniverseStargatesStargateId(stargateId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return UniverseApiFp(this.configuration).getUniverseStargatesStargateId(stargateId, datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Get information on a star  --- Alternate route: `/legacy/universe/stars/{star_id}/`  Alternate route: `/v1/universe/stars/{star_id}/`  --- This route expires daily at 11:05
     * @summary Get star information
     * @param {number} starId star_id integer
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseApi
     */
    public getUniverseStarsStarId(starId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return UniverseApiFp(this.configuration).getUniverseStarsStarId(starId, datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Get information on a station  --- Alternate route: `/dev/universe/stations/{station_id}/`  Alternate route: `/v2/universe/stations/{station_id}/`  --- This route expires daily at 11:05
     * @summary Get station information
     * @param {number} stationId station_id integer
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseApi
     */
    public getUniverseStationsStationId(stationId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return UniverseApiFp(this.configuration).getUniverseStationsStationId(stationId, datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * List all public structures  --- Alternate route: `/dev/universe/structures/`  Alternate route: `/legacy/universe/structures/`  Alternate route: `/v1/universe/structures/`  --- This route is cached for up to 3600 seconds
     * @summary List all public structures
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {'market' | 'manufacturing_basic'} [filter] Only list public structures that have this service online
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseApi
     */
    public getUniverseStructures(datasource?: 'tranquility', filter?: 'market' | 'manufacturing_basic', ifNoneMatch?: string, options?: any) {
        return UniverseApiFp(this.configuration).getUniverseStructures(datasource, filter, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Returns information on requested structure if you are on the ACL. Otherwise, returns \"Forbidden\" for all inputs.  --- Alternate route: `/v2/universe/structures/{structure_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get structure information
     * @param {number} structureId An Eve structure ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseApi
     */
    public getUniverseStructuresStructureId(structureId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return UniverseApiFp(this.configuration).getUniverseStructuresStructureId(structureId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Get the number of jumps in solar systems within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with jumps will be listed  --- Alternate route: `/legacy/universe/system_jumps/`  Alternate route: `/v1/universe/system_jumps/`  --- This route is cached for up to 3600 seconds
     * @summary Get system jumps
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseApi
     */
    public getUniverseSystemJumps(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return UniverseApiFp(this.configuration).getUniverseSystemJumps(datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Get the number of ship, pod and NPC kills per solar system within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with kills will be listed  --- Alternate route: `/v2/universe/system_kills/`  --- This route is cached for up to 3600 seconds
     * @summary Get system kills
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseApi
     */
    public getUniverseSystemKills(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return UniverseApiFp(this.configuration).getUniverseSystemKills(datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of solar systems  --- Alternate route: `/dev/universe/systems/`  Alternate route: `/legacy/universe/systems/`  Alternate route: `/v1/universe/systems/`  --- This route expires daily at 11:05
     * @summary Get solar systems
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseApi
     */
    public getUniverseSystems(datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return UniverseApiFp(this.configuration).getUniverseSystems(datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Get information on a solar system.  --- Alternate route: `/dev/universe/systems/{system_id}/`  Alternate route: `/v4/universe/systems/{system_id}/`  --- This route expires daily at 11:05
     * @summary Get solar system information
     * @param {number} systemId system_id integer
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseApi
     */
    public getUniverseSystemsSystemId(systemId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any) {
        return UniverseApiFp(this.configuration).getUniverseSystemsSystemId(systemId, acceptLanguage, datasource, ifNoneMatch, language, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of type ids  --- Alternate route: `/legacy/universe/types/`  Alternate route: `/v1/universe/types/`  --- This route expires daily at 11:05
     * @summary Get types
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseApi
     */
    public getUniverseTypes(datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options?: any) {
        return UniverseApiFp(this.configuration).getUniverseTypes(datasource, ifNoneMatch, page, options)(this.fetch, this.basePath);
    }

    /**
     * Get information on a type  --- Alternate route: `/dev/universe/types/{type_id}/`  Alternate route: `/v3/universe/types/{type_id}/`  --- This route expires daily at 11:05
     * @summary Get type information
     * @param {number} typeId An Eve item type ID
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseApi
     */
    public getUniverseTypesTypeId(typeId: number, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', ifNoneMatch?: string, language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any) {
        return UniverseApiFp(this.configuration).getUniverseTypesTypeId(typeId, acceptLanguage, datasource, ifNoneMatch, language, options)(this.fetch, this.basePath);
    }

    /**
     * Resolve a set of names to IDs in the following categories: agents, alliances, characters, constellations, corporations factions, inventory_types, regions, stations, and systems. Only exact matches will be returned. All names searched for are cached for 12 hours  --- Alternate route: `/dev/universe/ids/`  Alternate route: `/legacy/universe/ids/`  Alternate route: `/v1/universe/ids/` 
     * @summary Bulk names to IDs
     * @param {Array<string>} names The names to resolve
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [acceptLanguage] Language to use in the response
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es'} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseApi
     */
    public postUniverseIds(names: Array<string>, acceptLanguage?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', datasource?: 'tranquility', language?: 'en' | 'en-us' | 'de' | 'fr' | 'ja' | 'ru' | 'zh' | 'ko' | 'es', options?: any) {
        return UniverseApiFp(this.configuration).postUniverseIds(names, acceptLanguage, datasource, language, options)(this.fetch, this.basePath);
    }

    /**
     * Resolve a set of IDs to names and categories. Supported ID's for resolving are: Characters, Corporations, Alliances, Stations, Solar Systems, Constellations, Regions, Types, Factions  --- Alternate route: `/dev/universe/names/`  Alternate route: `/v3/universe/names/` 
     * @summary Get names and categories for a set of IDs
     * @param {Array<number>} ids The ids to resolve
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseApi
     */
    public postUniverseNames(ids: Array<number>, datasource?: 'tranquility', options?: any) {
        return UniverseApiFp(this.configuration).postUniverseNames(ids, datasource, options)(this.fetch, this.basePath);
    }

}

/**
 * UserInterfaceApi - fetch parameter creator
 * @export
 */
export const UserInterfaceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Set a solar system as autopilot waypoint  --- Alternate route: `/dev/ui/autopilot/waypoint/`  Alternate route: `/legacy/ui/autopilot/waypoint/`  Alternate route: `/v2/ui/autopilot/waypoint/` 
         * @summary Set Autopilot Waypoint
         * @param {boolean} addToBeginning Whether this solar system should be added to the beginning of all waypoints
         * @param {boolean} clearOtherWaypoints Whether clean other waypoints beforing adding this one
         * @param {number} destinationId The destination to travel to, can be solar system, station or structure&#39;s id
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUiAutopilotWaypoint(addToBeginning: boolean, clearOtherWaypoints: boolean, destinationId: number, datasource?: 'tranquility', token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'addToBeginning' is not null or undefined
            if (addToBeginning === null || addToBeginning === undefined) {
                throw new RequiredError('addToBeginning','Required parameter addToBeginning was null or undefined when calling postUiAutopilotWaypoint.');
            }
            // verify required parameter 'clearOtherWaypoints' is not null or undefined
            if (clearOtherWaypoints === null || clearOtherWaypoints === undefined) {
                throw new RequiredError('clearOtherWaypoints','Required parameter clearOtherWaypoints was null or undefined when calling postUiAutopilotWaypoint.');
            }
            // verify required parameter 'destinationId' is not null or undefined
            if (destinationId === null || destinationId === undefined) {
                throw new RequiredError('destinationId','Required parameter destinationId was null or undefined when calling postUiAutopilotWaypoint.');
            }
            const localVarPath = `/ui/autopilot/waypoint/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-ui.write_waypoint.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (addToBeginning !== undefined) {
                localVarQueryParameter['add_to_beginning'] = addToBeginning;
            }

            if (clearOtherWaypoints !== undefined) {
                localVarQueryParameter['clear_other_waypoints'] = clearOtherWaypoints;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (destinationId !== undefined) {
                localVarQueryParameter['destination_id'] = destinationId;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Open the contract window inside the client  --- Alternate route: `/dev/ui/openwindow/contract/`  Alternate route: `/legacy/ui/openwindow/contract/`  Alternate route: `/v1/ui/openwindow/contract/` 
         * @summary Open Contract Window
         * @param {number} contractId The contract to open
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUiOpenwindowContract(contractId: number, datasource?: 'tranquility', token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'contractId' is not null or undefined
            if (contractId === null || contractId === undefined) {
                throw new RequiredError('contractId','Required parameter contractId was null or undefined when calling postUiOpenwindowContract.');
            }
            const localVarPath = `/ui/openwindow/contract/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-ui.open_window.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (contractId !== undefined) {
                localVarQueryParameter['contract_id'] = contractId;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Open the information window for a character, corporation or alliance inside the client  --- Alternate route: `/dev/ui/openwindow/information/`  Alternate route: `/legacy/ui/openwindow/information/`  Alternate route: `/v1/ui/openwindow/information/` 
         * @summary Open Information Window
         * @param {number} targetId The target to open
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUiOpenwindowInformation(targetId: number, datasource?: 'tranquility', token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'targetId' is not null or undefined
            if (targetId === null || targetId === undefined) {
                throw new RequiredError('targetId','Required parameter targetId was null or undefined when calling postUiOpenwindowInformation.');
            }
            const localVarPath = `/ui/openwindow/information/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-ui.open_window.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (targetId !== undefined) {
                localVarQueryParameter['target_id'] = targetId;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Open the market details window for a specific typeID inside the client  --- Alternate route: `/dev/ui/openwindow/marketdetails/`  Alternate route: `/legacy/ui/openwindow/marketdetails/`  Alternate route: `/v1/ui/openwindow/marketdetails/` 
         * @summary Open Market Details
         * @param {number} typeId The item type to open in market window
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUiOpenwindowMarketdetails(typeId: number, datasource?: 'tranquility', token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'typeId' is not null or undefined
            if (typeId === null || typeId === undefined) {
                throw new RequiredError('typeId','Required parameter typeId was null or undefined when calling postUiOpenwindowMarketdetails.');
            }
            const localVarPath = `/ui/openwindow/marketdetails/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-ui.open_window.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (typeId !== undefined) {
                localVarQueryParameter['type_id'] = typeId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Open the New Mail window, according to settings from the request if applicable  --- Alternate route: `/dev/ui/openwindow/newmail/`  Alternate route: `/legacy/ui/openwindow/newmail/`  Alternate route: `/v1/ui/openwindow/newmail/` 
         * @summary Open New Mail Window
         * @param {PostUiOpenwindowNewmailNewMail} newMail The details of mail to create
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUiOpenwindowNewmail(newMail: PostUiOpenwindowNewmailNewMail, datasource?: 'tranquility', token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'newMail' is not null or undefined
            if (newMail === null || newMail === undefined) {
                throw new RequiredError('newMail','Required parameter newMail was null or undefined when calling postUiOpenwindowNewmail.');
            }
            const localVarPath = `/ui/openwindow/newmail/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-ui.open_window.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PostUiOpenwindowNewmailNewMail" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(newMail || {}) : (newMail || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserInterfaceApi - functional programming interface
 * @export
 */
export const UserInterfaceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Set a solar system as autopilot waypoint  --- Alternate route: `/dev/ui/autopilot/waypoint/`  Alternate route: `/legacy/ui/autopilot/waypoint/`  Alternate route: `/v2/ui/autopilot/waypoint/` 
         * @summary Set Autopilot Waypoint
         * @param {boolean} addToBeginning Whether this solar system should be added to the beginning of all waypoints
         * @param {boolean} clearOtherWaypoints Whether clean other waypoints beforing adding this one
         * @param {number} destinationId The destination to travel to, can be solar system, station or structure&#39;s id
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUiAutopilotWaypoint(addToBeginning: boolean, clearOtherWaypoints: boolean, destinationId: number, datasource?: 'tranquility', token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserInterfaceApiFetchParamCreator(configuration).postUiAutopilotWaypoint(addToBeginning, clearOtherWaypoints, destinationId, datasource, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Open the contract window inside the client  --- Alternate route: `/dev/ui/openwindow/contract/`  Alternate route: `/legacy/ui/openwindow/contract/`  Alternate route: `/v1/ui/openwindow/contract/` 
         * @summary Open Contract Window
         * @param {number} contractId The contract to open
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUiOpenwindowContract(contractId: number, datasource?: 'tranquility', token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserInterfaceApiFetchParamCreator(configuration).postUiOpenwindowContract(contractId, datasource, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Open the information window for a character, corporation or alliance inside the client  --- Alternate route: `/dev/ui/openwindow/information/`  Alternate route: `/legacy/ui/openwindow/information/`  Alternate route: `/v1/ui/openwindow/information/` 
         * @summary Open Information Window
         * @param {number} targetId The target to open
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUiOpenwindowInformation(targetId: number, datasource?: 'tranquility', token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserInterfaceApiFetchParamCreator(configuration).postUiOpenwindowInformation(targetId, datasource, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Open the market details window for a specific typeID inside the client  --- Alternate route: `/dev/ui/openwindow/marketdetails/`  Alternate route: `/legacy/ui/openwindow/marketdetails/`  Alternate route: `/v1/ui/openwindow/marketdetails/` 
         * @summary Open Market Details
         * @param {number} typeId The item type to open in market window
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUiOpenwindowMarketdetails(typeId: number, datasource?: 'tranquility', token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserInterfaceApiFetchParamCreator(configuration).postUiOpenwindowMarketdetails(typeId, datasource, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Open the New Mail window, according to settings from the request if applicable  --- Alternate route: `/dev/ui/openwindow/newmail/`  Alternate route: `/legacy/ui/openwindow/newmail/`  Alternate route: `/v1/ui/openwindow/newmail/` 
         * @summary Open New Mail Window
         * @param {PostUiOpenwindowNewmailNewMail} newMail The details of mail to create
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUiOpenwindowNewmail(newMail: PostUiOpenwindowNewmailNewMail, datasource?: 'tranquility', token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserInterfaceApiFetchParamCreator(configuration).postUiOpenwindowNewmail(newMail, datasource, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserInterfaceApi - factory interface
 * @export
 */
export const UserInterfaceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Set a solar system as autopilot waypoint  --- Alternate route: `/dev/ui/autopilot/waypoint/`  Alternate route: `/legacy/ui/autopilot/waypoint/`  Alternate route: `/v2/ui/autopilot/waypoint/` 
         * @summary Set Autopilot Waypoint
         * @param {boolean} addToBeginning Whether this solar system should be added to the beginning of all waypoints
         * @param {boolean} clearOtherWaypoints Whether clean other waypoints beforing adding this one
         * @param {number} destinationId The destination to travel to, can be solar system, station or structure&#39;s id
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUiAutopilotWaypoint(addToBeginning: boolean, clearOtherWaypoints: boolean, destinationId: number, datasource?: 'tranquility', token?: string, options?: any) {
            return UserInterfaceApiFp(configuration).postUiAutopilotWaypoint(addToBeginning, clearOtherWaypoints, destinationId, datasource, token, options)(fetch, basePath);
        },
        /**
         * Open the contract window inside the client  --- Alternate route: `/dev/ui/openwindow/contract/`  Alternate route: `/legacy/ui/openwindow/contract/`  Alternate route: `/v1/ui/openwindow/contract/` 
         * @summary Open Contract Window
         * @param {number} contractId The contract to open
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUiOpenwindowContract(contractId: number, datasource?: 'tranquility', token?: string, options?: any) {
            return UserInterfaceApiFp(configuration).postUiOpenwindowContract(contractId, datasource, token, options)(fetch, basePath);
        },
        /**
         * Open the information window for a character, corporation or alliance inside the client  --- Alternate route: `/dev/ui/openwindow/information/`  Alternate route: `/legacy/ui/openwindow/information/`  Alternate route: `/v1/ui/openwindow/information/` 
         * @summary Open Information Window
         * @param {number} targetId The target to open
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUiOpenwindowInformation(targetId: number, datasource?: 'tranquility', token?: string, options?: any) {
            return UserInterfaceApiFp(configuration).postUiOpenwindowInformation(targetId, datasource, token, options)(fetch, basePath);
        },
        /**
         * Open the market details window for a specific typeID inside the client  --- Alternate route: `/dev/ui/openwindow/marketdetails/`  Alternate route: `/legacy/ui/openwindow/marketdetails/`  Alternate route: `/v1/ui/openwindow/marketdetails/` 
         * @summary Open Market Details
         * @param {number} typeId The item type to open in market window
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUiOpenwindowMarketdetails(typeId: number, datasource?: 'tranquility', token?: string, options?: any) {
            return UserInterfaceApiFp(configuration).postUiOpenwindowMarketdetails(typeId, datasource, token, options)(fetch, basePath);
        },
        /**
         * Open the New Mail window, according to settings from the request if applicable  --- Alternate route: `/dev/ui/openwindow/newmail/`  Alternate route: `/legacy/ui/openwindow/newmail/`  Alternate route: `/v1/ui/openwindow/newmail/` 
         * @summary Open New Mail Window
         * @param {PostUiOpenwindowNewmailNewMail} newMail The details of mail to create
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUiOpenwindowNewmail(newMail: PostUiOpenwindowNewmailNewMail, datasource?: 'tranquility', token?: string, options?: any) {
            return UserInterfaceApiFp(configuration).postUiOpenwindowNewmail(newMail, datasource, token, options)(fetch, basePath);
        },
    };
};

/**
 * UserInterfaceApi - object-oriented interface
 * @export
 * @class UserInterfaceApi
 * @extends {BaseAPI}
 */
export class UserInterfaceApi extends BaseAPI {
    /**
     * Set a solar system as autopilot waypoint  --- Alternate route: `/dev/ui/autopilot/waypoint/`  Alternate route: `/legacy/ui/autopilot/waypoint/`  Alternate route: `/v2/ui/autopilot/waypoint/` 
     * @summary Set Autopilot Waypoint
     * @param {boolean} addToBeginning Whether this solar system should be added to the beginning of all waypoints
     * @param {boolean} clearOtherWaypoints Whether clean other waypoints beforing adding this one
     * @param {number} destinationId The destination to travel to, can be solar system, station or structure&#39;s id
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserInterfaceApi
     */
    public postUiAutopilotWaypoint(addToBeginning: boolean, clearOtherWaypoints: boolean, destinationId: number, datasource?: 'tranquility', token?: string, options?: any) {
        return UserInterfaceApiFp(this.configuration).postUiAutopilotWaypoint(addToBeginning, clearOtherWaypoints, destinationId, datasource, token, options)(this.fetch, this.basePath);
    }

    /**
     * Open the contract window inside the client  --- Alternate route: `/dev/ui/openwindow/contract/`  Alternate route: `/legacy/ui/openwindow/contract/`  Alternate route: `/v1/ui/openwindow/contract/` 
     * @summary Open Contract Window
     * @param {number} contractId The contract to open
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserInterfaceApi
     */
    public postUiOpenwindowContract(contractId: number, datasource?: 'tranquility', token?: string, options?: any) {
        return UserInterfaceApiFp(this.configuration).postUiOpenwindowContract(contractId, datasource, token, options)(this.fetch, this.basePath);
    }

    /**
     * Open the information window for a character, corporation or alliance inside the client  --- Alternate route: `/dev/ui/openwindow/information/`  Alternate route: `/legacy/ui/openwindow/information/`  Alternate route: `/v1/ui/openwindow/information/` 
     * @summary Open Information Window
     * @param {number} targetId The target to open
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserInterfaceApi
     */
    public postUiOpenwindowInformation(targetId: number, datasource?: 'tranquility', token?: string, options?: any) {
        return UserInterfaceApiFp(this.configuration).postUiOpenwindowInformation(targetId, datasource, token, options)(this.fetch, this.basePath);
    }

    /**
     * Open the market details window for a specific typeID inside the client  --- Alternate route: `/dev/ui/openwindow/marketdetails/`  Alternate route: `/legacy/ui/openwindow/marketdetails/`  Alternate route: `/v1/ui/openwindow/marketdetails/` 
     * @summary Open Market Details
     * @param {number} typeId The item type to open in market window
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserInterfaceApi
     */
    public postUiOpenwindowMarketdetails(typeId: number, datasource?: 'tranquility', token?: string, options?: any) {
        return UserInterfaceApiFp(this.configuration).postUiOpenwindowMarketdetails(typeId, datasource, token, options)(this.fetch, this.basePath);
    }

    /**
     * Open the New Mail window, according to settings from the request if applicable  --- Alternate route: `/dev/ui/openwindow/newmail/`  Alternate route: `/legacy/ui/openwindow/newmail/`  Alternate route: `/v1/ui/openwindow/newmail/` 
     * @summary Open New Mail Window
     * @param {PostUiOpenwindowNewmailNewMail} newMail The details of mail to create
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserInterfaceApi
     */
    public postUiOpenwindowNewmail(newMail: PostUiOpenwindowNewmailNewMail, datasource?: 'tranquility', token?: string, options?: any) {
        return UserInterfaceApiFp(this.configuration).postUiOpenwindowNewmail(newMail, datasource, token, options)(this.fetch, this.basePath);
    }

}

/**
 * WalletApi - fetch parameter creator
 * @export
 */
export const WalletApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a character's wallet balance  --- Alternate route: `/legacy/characters/{character_id}/wallet/`  Alternate route: `/v1/characters/{character_id}/wallet/`  --- This route is cached for up to 120 seconds  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/characters/{character_id}/wallet/)
         * @summary Get a character's wallet balance
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdWallet(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdWallet.');
            }
            const localVarPath = `/characters/{character_id}/wallet/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-wallet.read_character_wallet.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the given character's wallet journal going 30 days back  --- Alternate route: `/dev/characters/{character_id}/wallet/journal/`  Alternate route: `/v6/characters/{character_id}/wallet/journal/`  --- This route is cached for up to 3600 seconds
         * @summary Get character wallet journal
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdWalletJournal(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdWalletJournal.');
            }
            const localVarPath = `/characters/{character_id}/wallet/journal/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-wallet.read_character_wallet.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get wallet transactions of a character  --- Alternate route: `/dev/characters/{character_id}/wallet/transactions/`  Alternate route: `/legacy/characters/{character_id}/wallet/transactions/`  Alternate route: `/v1/characters/{character_id}/wallet/transactions/`  --- This route is cached for up to 3600 seconds
         * @summary Get wallet transactions
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {number} [fromId] Only show transactions happened before the one referenced by this id
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdWalletTransactions(characterId: number, datasource?: 'tranquility', fromId?: number, ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'characterId' is not null or undefined
            if (characterId === null || characterId === undefined) {
                throw new RequiredError('characterId','Required parameter characterId was null or undefined when calling getCharactersCharacterIdWalletTransactions.');
            }
            const localVarPath = `/characters/{character_id}/wallet/transactions/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-wallet.read_character_wallet.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['from_id'] = fromId;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a corporation's wallets  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/`  Alternate route: `/legacy/corporations/{corporation_id}/wallets/`  Alternate route: `/v1/corporations/{corporation_id}/wallets/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant 
         * @summary Returns a corporation's wallet balance
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdWallets(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdWallets.');
            }
            const localVarPath = `/corporations/{corporation_id}/wallets/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-wallet.read_corporation_wallets.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the given corporation's wallet journal for the given division going 30 days back  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/{division}/journal/`  Alternate route: `/v4/corporations/{corporation_id}/wallets/{division}/journal/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant 
         * @summary Get corporation wallet journal
         * @param {number} corporationId An EVE corporation ID
         * @param {number} division Wallet key of the division to fetch journals from
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdWalletsDivisionJournal(corporationId: number, division: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdWalletsDivisionJournal.');
            }
            // verify required parameter 'division' is not null or undefined
            if (division === null || division === undefined) {
                throw new RequiredError('division','Required parameter division was null or undefined when calling getCorporationsCorporationIdWalletsDivisionJournal.');
            }
            const localVarPath = `/corporations/{corporation_id}/wallets/{division}/journal/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)))
                .replace(`{${"division"}}`, encodeURIComponent(String(division)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-wallet.read_corporation_wallets.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get wallet transactions of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/{division}/transactions/`  Alternate route: `/legacy/corporations/{corporation_id}/wallets/{division}/transactions/`  Alternate route: `/v1/corporations/{corporation_id}/wallets/{division}/transactions/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant 
         * @summary Get corporation wallet transactions
         * @param {number} corporationId An EVE corporation ID
         * @param {number} division Wallet key of the division to fetch journals from
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {number} [fromId] Only show journal entries happened before the transaction referenced by this id
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdWalletsDivisionTransactions(corporationId: number, division: number, datasource?: 'tranquility', fromId?: number, ifNoneMatch?: string, token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'corporationId' is not null or undefined
            if (corporationId === null || corporationId === undefined) {
                throw new RequiredError('corporationId','Required parameter corporationId was null or undefined when calling getCorporationsCorporationIdWalletsDivisionTransactions.');
            }
            // verify required parameter 'division' is not null or undefined
            if (division === null || division === undefined) {
                throw new RequiredError('division','Required parameter division was null or undefined when calling getCorporationsCorporationIdWalletsDivisionTransactions.');
            }
            const localVarPath = `/corporations/{corporation_id}/wallets/{division}/transactions/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)))
                .replace(`{${"division"}}`, encodeURIComponent(String(division)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("evesso", ["esi-wallet.read_corporation_wallets.v1"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['from_id'] = fromId;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletApi - functional programming interface
 * @export
 */
export const WalletApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a character's wallet balance  --- Alternate route: `/legacy/characters/{character_id}/wallet/`  Alternate route: `/v1/characters/{character_id}/wallet/`  --- This route is cached for up to 120 seconds  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/characters/{character_id}/wallet/)
         * @summary Get a character's wallet balance
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdWallet(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = WalletApiFetchParamCreator(configuration).getCharactersCharacterIdWallet(characterId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve the given character's wallet journal going 30 days back  --- Alternate route: `/dev/characters/{character_id}/wallet/journal/`  Alternate route: `/v6/characters/{character_id}/wallet/journal/`  --- This route is cached for up to 3600 seconds
         * @summary Get character wallet journal
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdWalletJournal(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCharactersCharacterIdWalletJournal200Ok>> {
            const localVarFetchArgs = WalletApiFetchParamCreator(configuration).getCharactersCharacterIdWalletJournal(characterId, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get wallet transactions of a character  --- Alternate route: `/dev/characters/{character_id}/wallet/transactions/`  Alternate route: `/legacy/characters/{character_id}/wallet/transactions/`  Alternate route: `/v1/characters/{character_id}/wallet/transactions/`  --- This route is cached for up to 3600 seconds
         * @summary Get wallet transactions
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {number} [fromId] Only show transactions happened before the one referenced by this id
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdWalletTransactions(characterId: number, datasource?: 'tranquility', fromId?: number, ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCharactersCharacterIdWalletTransactions200Ok>> {
            const localVarFetchArgs = WalletApiFetchParamCreator(configuration).getCharactersCharacterIdWalletTransactions(characterId, datasource, fromId, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a corporation's wallets  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/`  Alternate route: `/legacy/corporations/{corporation_id}/wallets/`  Alternate route: `/v1/corporations/{corporation_id}/wallets/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant 
         * @summary Returns a corporation's wallet balance
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdWallets(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationsCorporationIdWallets200Ok>> {
            const localVarFetchArgs = WalletApiFetchParamCreator(configuration).getCorporationsCorporationIdWallets(corporationId, datasource, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve the given corporation's wallet journal for the given division going 30 days back  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/{division}/journal/`  Alternate route: `/v4/corporations/{corporation_id}/wallets/{division}/journal/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant 
         * @summary Get corporation wallet journal
         * @param {number} corporationId An EVE corporation ID
         * @param {number} division Wallet key of the division to fetch journals from
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdWalletsDivisionJournal(corporationId: number, division: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationsCorporationIdWalletsDivisionJournal200Ok>> {
            const localVarFetchArgs = WalletApiFetchParamCreator(configuration).getCorporationsCorporationIdWalletsDivisionJournal(corporationId, division, datasource, ifNoneMatch, page, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get wallet transactions of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/{division}/transactions/`  Alternate route: `/legacy/corporations/{corporation_id}/wallets/{division}/transactions/`  Alternate route: `/v1/corporations/{corporation_id}/wallets/{division}/transactions/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant 
         * @summary Get corporation wallet transactions
         * @param {number} corporationId An EVE corporation ID
         * @param {number} division Wallet key of the division to fetch journals from
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {number} [fromId] Only show journal entries happened before the transaction referenced by this id
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdWalletsDivisionTransactions(corporationId: number, division: number, datasource?: 'tranquility', fromId?: number, ifNoneMatch?: string, token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetCorporationsCorporationIdWalletsDivisionTransactions200Ok>> {
            const localVarFetchArgs = WalletApiFetchParamCreator(configuration).getCorporationsCorporationIdWalletsDivisionTransactions(corporationId, division, datasource, fromId, ifNoneMatch, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WalletApi - factory interface
 * @export
 */
export const WalletApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns a character's wallet balance  --- Alternate route: `/legacy/characters/{character_id}/wallet/`  Alternate route: `/v1/characters/{character_id}/wallet/`  --- This route is cached for up to 120 seconds  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/characters/{character_id}/wallet/)
         * @summary Get a character's wallet balance
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdWallet(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return WalletApiFp(configuration).getCharactersCharacterIdWallet(characterId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Retrieve the given character's wallet journal going 30 days back  --- Alternate route: `/dev/characters/{character_id}/wallet/journal/`  Alternate route: `/v6/characters/{character_id}/wallet/journal/`  --- This route is cached for up to 3600 seconds
         * @summary Get character wallet journal
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdWalletJournal(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return WalletApiFp(configuration).getCharactersCharacterIdWalletJournal(characterId, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
        /**
         * Get wallet transactions of a character  --- Alternate route: `/dev/characters/{character_id}/wallet/transactions/`  Alternate route: `/legacy/characters/{character_id}/wallet/transactions/`  Alternate route: `/v1/characters/{character_id}/wallet/transactions/`  --- This route is cached for up to 3600 seconds
         * @summary Get wallet transactions
         * @param {number} characterId An EVE character ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {number} [fromId] Only show transactions happened before the one referenced by this id
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdWalletTransactions(characterId: number, datasource?: 'tranquility', fromId?: number, ifNoneMatch?: string, token?: string, options?: any) {
            return WalletApiFp(configuration).getCharactersCharacterIdWalletTransactions(characterId, datasource, fromId, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Get a corporation's wallets  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/`  Alternate route: `/legacy/corporations/{corporation_id}/wallets/`  Alternate route: `/v1/corporations/{corporation_id}/wallets/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant 
         * @summary Returns a corporation's wallet balance
         * @param {number} corporationId An EVE corporation ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdWallets(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
            return WalletApiFp(configuration).getCorporationsCorporationIdWallets(corporationId, datasource, ifNoneMatch, token, options)(fetch, basePath);
        },
        /**
         * Retrieve the given corporation's wallet journal for the given division going 30 days back  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/{division}/journal/`  Alternate route: `/v4/corporations/{corporation_id}/wallets/{division}/journal/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant 
         * @summary Get corporation wallet journal
         * @param {number} corporationId An EVE corporation ID
         * @param {number} division Wallet key of the division to fetch journals from
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdWalletsDivisionJournal(corporationId: number, division: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
            return WalletApiFp(configuration).getCorporationsCorporationIdWalletsDivisionJournal(corporationId, division, datasource, ifNoneMatch, page, token, options)(fetch, basePath);
        },
        /**
         * Get wallet transactions of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/{division}/transactions/`  Alternate route: `/legacy/corporations/{corporation_id}/wallets/{division}/transactions/`  Alternate route: `/v1/corporations/{corporation_id}/wallets/{division}/transactions/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant 
         * @summary Get corporation wallet transactions
         * @param {number} corporationId An EVE corporation ID
         * @param {number} division Wallet key of the division to fetch journals from
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {number} [fromId] Only show journal entries happened before the transaction referenced by this id
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdWalletsDivisionTransactions(corporationId: number, division: number, datasource?: 'tranquility', fromId?: number, ifNoneMatch?: string, token?: string, options?: any) {
            return WalletApiFp(configuration).getCorporationsCorporationIdWalletsDivisionTransactions(corporationId, division, datasource, fromId, ifNoneMatch, token, options)(fetch, basePath);
        },
    };
};

/**
 * WalletApi - object-oriented interface
 * @export
 * @class WalletApi
 * @extends {BaseAPI}
 */
export class WalletApi extends BaseAPI {
    /**
     * Returns a character's wallet balance  --- Alternate route: `/legacy/characters/{character_id}/wallet/`  Alternate route: `/v1/characters/{character_id}/wallet/`  --- This route is cached for up to 120 seconds  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/characters/{character_id}/wallet/)
     * @summary Get a character's wallet balance
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public getCharactersCharacterIdWallet(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return WalletApiFp(this.configuration).getCharactersCharacterIdWallet(characterId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve the given character's wallet journal going 30 days back  --- Alternate route: `/dev/characters/{character_id}/wallet/journal/`  Alternate route: `/v6/characters/{character_id}/wallet/journal/`  --- This route is cached for up to 3600 seconds
     * @summary Get character wallet journal
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public getCharactersCharacterIdWalletJournal(characterId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return WalletApiFp(this.configuration).getCharactersCharacterIdWalletJournal(characterId, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * Get wallet transactions of a character  --- Alternate route: `/dev/characters/{character_id}/wallet/transactions/`  Alternate route: `/legacy/characters/{character_id}/wallet/transactions/`  Alternate route: `/v1/characters/{character_id}/wallet/transactions/`  --- This route is cached for up to 3600 seconds
     * @summary Get wallet transactions
     * @param {number} characterId An EVE character ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {number} [fromId] Only show transactions happened before the one referenced by this id
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public getCharactersCharacterIdWalletTransactions(characterId: number, datasource?: 'tranquility', fromId?: number, ifNoneMatch?: string, token?: string, options?: any) {
        return WalletApiFp(this.configuration).getCharactersCharacterIdWalletTransactions(characterId, datasource, fromId, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Get a corporation's wallets  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/`  Alternate route: `/legacy/corporations/{corporation_id}/wallets/`  Alternate route: `/v1/corporations/{corporation_id}/wallets/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant 
     * @summary Returns a corporation's wallet balance
     * @param {number} corporationId An EVE corporation ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public getCorporationsCorporationIdWallets(corporationId: number, datasource?: 'tranquility', ifNoneMatch?: string, token?: string, options?: any) {
        return WalletApiFp(this.configuration).getCorporationsCorporationIdWallets(corporationId, datasource, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve the given corporation's wallet journal for the given division going 30 days back  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/{division}/journal/`  Alternate route: `/v4/corporations/{corporation_id}/wallets/{division}/journal/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant 
     * @summary Get corporation wallet journal
     * @param {number} corporationId An EVE corporation ID
     * @param {number} division Wallet key of the division to fetch journals from
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public getCorporationsCorporationIdWalletsDivisionJournal(corporationId: number, division: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, token?: string, options?: any) {
        return WalletApiFp(this.configuration).getCorporationsCorporationIdWalletsDivisionJournal(corporationId, division, datasource, ifNoneMatch, page, token, options)(this.fetch, this.basePath);
    }

    /**
     * Get wallet transactions of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/{division}/transactions/`  Alternate route: `/legacy/corporations/{corporation_id}/wallets/{division}/transactions/`  Alternate route: `/v1/corporations/{corporation_id}/wallets/{division}/transactions/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant 
     * @summary Get corporation wallet transactions
     * @param {number} corporationId An EVE corporation ID
     * @param {number} division Wallet key of the division to fetch journals from
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {number} [fromId] Only show journal entries happened before the transaction referenced by this id
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public getCorporationsCorporationIdWalletsDivisionTransactions(corporationId: number, division: number, datasource?: 'tranquility', fromId?: number, ifNoneMatch?: string, token?: string, options?: any) {
        return WalletApiFp(this.configuration).getCorporationsCorporationIdWalletsDivisionTransactions(corporationId, division, datasource, fromId, ifNoneMatch, token, options)(this.fetch, this.basePath);
    }

}

/**
 * WarsApi - fetch parameter creator
 * @export
 */
export const WarsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return a list of wars  --- Alternate route: `/dev/wars/`  Alternate route: `/legacy/wars/`  Alternate route: `/v1/wars/`  --- This route is cached for up to 3600 seconds
         * @summary List wars
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [maxWarId] Only return wars with ID smaller than this
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWars(datasource?: 'tranquility', ifNoneMatch?: string, maxWarId?: number, options: any = {}): FetchArgs {
            const localVarPath = `/wars/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (maxWarId !== undefined) {
                localVarQueryParameter['max_war_id'] = maxWarId;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return details about a war  --- Alternate route: `/dev/wars/{war_id}/`  Alternate route: `/legacy/wars/{war_id}/`  Alternate route: `/v1/wars/{war_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get war information
         * @param {number} warId ID for a war
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWarsWarId(warId: number, datasource?: 'tranquility', ifNoneMatch?: string, options: any = {}): FetchArgs {
            // verify required parameter 'warId' is not null or undefined
            if (warId === null || warId === undefined) {
                throw new RequiredError('warId','Required parameter warId was null or undefined when calling getWarsWarId.');
            }
            const localVarPath = `/wars/{war_id}/`
                .replace(`{${"war_id"}}`, encodeURIComponent(String(warId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of kills related to a war  --- Alternate route: `/dev/wars/{war_id}/killmails/`  Alternate route: `/legacy/wars/{war_id}/killmails/`  Alternate route: `/v1/wars/{war_id}/killmails/`  --- This route is cached for up to 3600 seconds
         * @summary List kills for a war
         * @param {number} warId A valid war ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWarsWarIdKillmails(warId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options: any = {}): FetchArgs {
            // verify required parameter 'warId' is not null or undefined
            if (warId === null || warId === undefined) {
                throw new RequiredError('warId','Required parameter warId was null or undefined when calling getWarsWarIdKillmails.');
            }
            const localVarPath = `/wars/{war_id}/killmails/`
                .replace(`{${"war_id"}}`, encodeURIComponent(String(warId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WarsApi - functional programming interface
 * @export
 */
export const WarsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Return a list of wars  --- Alternate route: `/dev/wars/`  Alternate route: `/legacy/wars/`  Alternate route: `/v1/wars/`  --- This route is cached for up to 3600 seconds
         * @summary List wars
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [maxWarId] Only return wars with ID smaller than this
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWars(datasource?: 'tranquility', ifNoneMatch?: string, maxWarId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = WarsApiFetchParamCreator(configuration).getWars(datasource, ifNoneMatch, maxWarId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return details about a war  --- Alternate route: `/dev/wars/{war_id}/`  Alternate route: `/legacy/wars/{war_id}/`  Alternate route: `/v1/wars/{war_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get war information
         * @param {number} warId ID for a war
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWarsWarId(warId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetWarsWarIdOk> {
            const localVarFetchArgs = WarsApiFetchParamCreator(configuration).getWarsWarId(warId, datasource, ifNoneMatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a list of kills related to a war  --- Alternate route: `/dev/wars/{war_id}/killmails/`  Alternate route: `/legacy/wars/{war_id}/killmails/`  Alternate route: `/v1/wars/{war_id}/killmails/`  --- This route is cached for up to 3600 seconds
         * @summary List kills for a war
         * @param {number} warId A valid war ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWarsWarIdKillmails(warId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetWarsWarIdKillmails200Ok>> {
            const localVarFetchArgs = WarsApiFetchParamCreator(configuration).getWarsWarIdKillmails(warId, datasource, ifNoneMatch, page, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WarsApi - factory interface
 * @export
 */
export const WarsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Return a list of wars  --- Alternate route: `/dev/wars/`  Alternate route: `/legacy/wars/`  Alternate route: `/v1/wars/`  --- This route is cached for up to 3600 seconds
         * @summary List wars
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [maxWarId] Only return wars with ID smaller than this
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWars(datasource?: 'tranquility', ifNoneMatch?: string, maxWarId?: number, options?: any) {
            return WarsApiFp(configuration).getWars(datasource, ifNoneMatch, maxWarId, options)(fetch, basePath);
        },
        /**
         * Return details about a war  --- Alternate route: `/dev/wars/{war_id}/`  Alternate route: `/legacy/wars/{war_id}/`  Alternate route: `/v1/wars/{war_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get war information
         * @param {number} warId ID for a war
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWarsWarId(warId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
            return WarsApiFp(configuration).getWarsWarId(warId, datasource, ifNoneMatch, options)(fetch, basePath);
        },
        /**
         * Return a list of kills related to a war  --- Alternate route: `/dev/wars/{war_id}/killmails/`  Alternate route: `/legacy/wars/{war_id}/killmails/`  Alternate route: `/v1/wars/{war_id}/killmails/`  --- This route is cached for up to 3600 seconds
         * @summary List kills for a war
         * @param {number} warId A valid war ID
         * @param {'tranquility'} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWarsWarIdKillmails(warId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options?: any) {
            return WarsApiFp(configuration).getWarsWarIdKillmails(warId, datasource, ifNoneMatch, page, options)(fetch, basePath);
        },
    };
};

/**
 * WarsApi - object-oriented interface
 * @export
 * @class WarsApi
 * @extends {BaseAPI}
 */
export class WarsApi extends BaseAPI {
    /**
     * Return a list of wars  --- Alternate route: `/dev/wars/`  Alternate route: `/legacy/wars/`  Alternate route: `/v1/wars/`  --- This route is cached for up to 3600 seconds
     * @summary List wars
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [maxWarId] Only return wars with ID smaller than this
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarsApi
     */
    public getWars(datasource?: 'tranquility', ifNoneMatch?: string, maxWarId?: number, options?: any) {
        return WarsApiFp(this.configuration).getWars(datasource, ifNoneMatch, maxWarId, options)(this.fetch, this.basePath);
    }

    /**
     * Return details about a war  --- Alternate route: `/dev/wars/{war_id}/`  Alternate route: `/legacy/wars/{war_id}/`  Alternate route: `/v1/wars/{war_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get war information
     * @param {number} warId ID for a war
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarsApi
     */
    public getWarsWarId(warId: number, datasource?: 'tranquility', ifNoneMatch?: string, options?: any) {
        return WarsApiFp(this.configuration).getWarsWarId(warId, datasource, ifNoneMatch, options)(this.fetch, this.basePath);
    }

    /**
     * Return a list of kills related to a war  --- Alternate route: `/dev/wars/{war_id}/killmails/`  Alternate route: `/legacy/wars/{war_id}/killmails/`  Alternate route: `/v1/wars/{war_id}/killmails/`  --- This route is cached for up to 3600 seconds
     * @summary List kills for a war
     * @param {number} warId A valid war ID
     * @param {'tranquility'} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WarsApi
     */
    public getWarsWarIdKillmails(warId: number, datasource?: 'tranquility', ifNoneMatch?: string, page?: number, options?: any) {
        return WarsApiFp(this.configuration).getWarsWarIdKillmails(warId, datasource, ifNoneMatch, page, options)(this.fetch, this.basePath);
    }

}

